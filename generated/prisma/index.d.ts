
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model EmployeeProfile
 * 
 */
export type EmployeeProfile = $Result.DefaultSelection<Prisma.$EmployeeProfilePayload>
/**
 * Model JobPost
 * 
 */
export type JobPost = $Result.DefaultSelection<Prisma.$JobPostPayload>
/**
 * Model Chemist
 * 
 */
export type Chemist = $Result.DefaultSelection<Prisma.$ChemistPayload>
/**
 * Model Depo
 * 
 */
export type Depo = $Result.DefaultSelection<Prisma.$DepoPayload>
/**
 * Model Party
 * 
 */
export type Party = $Result.DefaultSelection<Prisma.$PartyPayload>
/**
 * Model Stakeholder
 * 
 */
export type Stakeholder = $Result.DefaultSelection<Prisma.$StakeholderPayload>
/**
 * Model StakeholderDeisgnation
 * 
 */
export type StakeholderDeisgnation = $Result.DefaultSelection<Prisma.$StakeholderDeisgnationPayload>
/**
 * Model StakeholderDegree
 * 
 */
export type StakeholderDegree = $Result.DefaultSelection<Prisma.$StakeholderDegreePayload>
/**
 * Model stakeholderChember
 * 
 */
export type stakeholderChember = $Result.DefaultSelection<Prisma.$stakeholderChemberPayload>
/**
 * Model StakeholderOcation
 * 
 */
export type StakeholderOcation = $Result.DefaultSelection<Prisma.$StakeholderOcationPayload>
/**
 * Model Customers
 * 
 */
export type Customers = $Result.DefaultSelection<Prisma.$CustomersPayload>
/**
 * Model Scope
 * 
 */
export type Scope = $Result.DefaultSelection<Prisma.$ScopePayload>
/**
 * Model MpoTarget
 * 
 */
export type MpoTarget = $Result.DefaultSelection<Prisma.$MpoTargetPayload>
/**
 * Model ProductWiseTarget
 * 
 */
export type ProductWiseTarget = $Result.DefaultSelection<Prisma.$ProductWiseTargetPayload>
/**
 * Model TargetProductBatch
 * 
 */
export type TargetProductBatch = $Result.DefaultSelection<Prisma.$TargetProductBatchPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model SubCategory
 * 
 */
export type SubCategory = $Result.DefaultSelection<Prisma.$SubCategoryPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model AccountHead
 * 
 */
export type AccountHead = $Result.DefaultSelection<Prisma.$AccountHeadPayload>
/**
 * Model LedgerHead
 * 
 */
export type LedgerHead = $Result.DefaultSelection<Prisma.$LedgerHeadPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model BankTransaction
 * 
 */
export type BankTransaction = $Result.DefaultSelection<Prisma.$BankTransactionPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model TransactionInfo
 * 
 */
export type TransactionInfo = $Result.DefaultSelection<Prisma.$TransactionInfoPayload>
/**
 * Model Journal
 * 
 */
export type Journal = $Result.DefaultSelection<Prisma.$JournalPayload>
/**
 * Model FixedJournal
 * 
 */
export type FixedJournal = $Result.DefaultSelection<Prisma.$FixedJournalPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderStatus
 * 
 */
export type OrderStatus = $Result.DefaultSelection<Prisma.$OrderStatusPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Overtime
 * 
 */
export type Overtime = $Result.DefaultSelection<Prisma.$OvertimePayload>
/**
 * Model LeaveType
 * 
 */
export type LeaveType = $Result.DefaultSelection<Prisma.$LeaveTypePayload>
/**
 * Model Leves
 * 
 */
export type Leves = $Result.DefaultSelection<Prisma.$LevesPayload>
/**
 * Model EmployeeBankDetails
 * 
 */
export type EmployeeBankDetails = $Result.DefaultSelection<Prisma.$EmployeeBankDetailsPayload>
/**
 * Model SalaryInfo
 * 
 */
export type SalaryInfo = $Result.DefaultSelection<Prisma.$SalaryInfoPayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TargetType: {
  MONTHLY: 'MONTHLY',
  QUERTERLY: 'QUERTERLY',
  HALF_YEARLY: 'HALF_YEARLY',
  YEARLY: 'YEARLY'
};

export type TargetType = (typeof TargetType)[keyof typeof TargetType]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  BLOCK: 'BLOCK',
  DELETED: 'DELETED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Status: {
  IN_STOCK: 'IN_STOCK',
  OUT_OF_STOCK: 'OUT_OF_STOCK',
  ACTIVE: 'ACTIVE',
  DELETED: 'DELETED',
  PUSH: 'PUSH',
  BLOCK: 'BLOCK',
  PENDING: 'PENDING',
  CHECKED: 'CHECKED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const PaymentType: {
  PAID: 'PAID',
  DUE: 'DUE',
  PARTIAL: 'PARTIAL'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const VoucherType: {
  SALES: 'SALES',
  PURCHASE: 'PURCHASE',
  RECEIVED: 'RECEIVED',
  PAYMENT: 'PAYMENT',
  JOURNAL: 'JOURNAL',
  CONTRA: 'CONTRA',
  TRANSFER: 'TRANSFER',
  ALLOCATION: 'ALLOCATION',
  GIFT: 'GIFT',
  MONEY_RECEIVED: 'MONEY_RECEIVED',
  OTHER: 'OTHER',
  SALES_RETURN: 'SALES_RETURN'
};

export type VoucherType = (typeof VoucherType)[keyof typeof VoucherType]


export const OrdStatus: {
  PENDING: 'PENDING',
  REVIEWING: 'REVIEWING',
  CONFIRMED: 'CONFIRMED',
  ON_THE_WAY: 'ON_THE_WAY',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  RETURNED: 'RETURNED'
};

export type OrdStatus = (typeof OrdStatus)[keyof typeof OrdStatus]


export const PartyType: {
  SUPPLIER: 'SUPPLIER',
  VENDOR: 'VENDOR'
};

export type PartyType = (typeof PartyType)[keyof typeof PartyType]


export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  ACCOUNTS: 'ACCOUNTS',
  OFFICE_ADMIN: 'OFFICE_ADMIN',
  GM: 'GM',
  ASM: 'ASM',
  RSM: 'RSM',
  AM: 'AM',
  MPO: 'MPO',
  SR: 'SR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type TargetType = $Enums.TargetType

export const TargetType: typeof $Enums.TargetType

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type VoucherType = $Enums.VoucherType

export const VoucherType: typeof $Enums.VoucherType

export type OrdStatus = $Enums.OrdStatus

export const OrdStatus: typeof $Enums.OrdStatus

export type PartyType = $Enums.PartyType

export const PartyType: typeof $Enums.PartyType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeProfile`: Exposes CRUD operations for the **EmployeeProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeProfiles
    * const employeeProfiles = await prisma.employeeProfile.findMany()
    * ```
    */
  get employeeProfile(): Prisma.EmployeeProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPost`: Exposes CRUD operations for the **JobPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPosts
    * const jobPosts = await prisma.jobPost.findMany()
    * ```
    */
  get jobPost(): Prisma.JobPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chemist`: Exposes CRUD operations for the **Chemist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chemists
    * const chemists = await prisma.chemist.findMany()
    * ```
    */
  get chemist(): Prisma.ChemistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.depo`: Exposes CRUD operations for the **Depo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Depos
    * const depos = await prisma.depo.findMany()
    * ```
    */
  get depo(): Prisma.DepoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.party`: Exposes CRUD operations for the **Party** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parties
    * const parties = await prisma.party.findMany()
    * ```
    */
  get party(): Prisma.PartyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakeholder`: Exposes CRUD operations for the **Stakeholder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stakeholders
    * const stakeholders = await prisma.stakeholder.findMany()
    * ```
    */
  get stakeholder(): Prisma.StakeholderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakeholderDeisgnation`: Exposes CRUD operations for the **StakeholderDeisgnation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakeholderDeisgnations
    * const stakeholderDeisgnations = await prisma.stakeholderDeisgnation.findMany()
    * ```
    */
  get stakeholderDeisgnation(): Prisma.StakeholderDeisgnationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakeholderDegree`: Exposes CRUD operations for the **StakeholderDegree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakeholderDegrees
    * const stakeholderDegrees = await prisma.stakeholderDegree.findMany()
    * ```
    */
  get stakeholderDegree(): Prisma.StakeholderDegreeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakeholderChember`: Exposes CRUD operations for the **stakeholderChember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakeholderChembers
    * const stakeholderChembers = await prisma.stakeholderChember.findMany()
    * ```
    */
  get stakeholderChember(): Prisma.stakeholderChemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakeholderOcation`: Exposes CRUD operations for the **StakeholderOcation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakeholderOcations
    * const stakeholderOcations = await prisma.stakeholderOcation.findMany()
    * ```
    */
  get stakeholderOcation(): Prisma.StakeholderOcationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scope`: Exposes CRUD operations for the **Scope** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scopes
    * const scopes = await prisma.scope.findMany()
    * ```
    */
  get scope(): Prisma.ScopeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mpoTarget`: Exposes CRUD operations for the **MpoTarget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MpoTargets
    * const mpoTargets = await prisma.mpoTarget.findMany()
    * ```
    */
  get mpoTarget(): Prisma.MpoTargetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productWiseTarget`: Exposes CRUD operations for the **ProductWiseTarget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductWiseTargets
    * const productWiseTargets = await prisma.productWiseTarget.findMany()
    * ```
    */
  get productWiseTarget(): Prisma.ProductWiseTargetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.targetProductBatch`: Exposes CRUD operations for the **TargetProductBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TargetProductBatches
    * const targetProductBatches = await prisma.targetProductBatch.findMany()
    * ```
    */
  get targetProductBatch(): Prisma.TargetProductBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subCategory`: Exposes CRUD operations for the **SubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategories
    * const subCategories = await prisma.subCategory.findMany()
    * ```
    */
  get subCategory(): Prisma.SubCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountHead`: Exposes CRUD operations for the **AccountHead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountHeads
    * const accountHeads = await prisma.accountHead.findMany()
    * ```
    */
  get accountHead(): Prisma.AccountHeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ledgerHead`: Exposes CRUD operations for the **LedgerHead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerHeads
    * const ledgerHeads = await prisma.ledgerHead.findMany()
    * ```
    */
  get ledgerHead(): Prisma.LedgerHeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankTransaction`: Exposes CRUD operations for the **BankTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankTransactions
    * const bankTransactions = await prisma.bankTransaction.findMany()
    * ```
    */
  get bankTransaction(): Prisma.BankTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionInfo`: Exposes CRUD operations for the **TransactionInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionInfos
    * const transactionInfos = await prisma.transactionInfo.findMany()
    * ```
    */
  get transactionInfo(): Prisma.TransactionInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journal`: Exposes CRUD operations for the **Journal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journal.findMany()
    * ```
    */
  get journal(): Prisma.JournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fixedJournal`: Exposes CRUD operations for the **FixedJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FixedJournals
    * const fixedJournals = await prisma.fixedJournal.findMany()
    * ```
    */
  get fixedJournal(): Prisma.FixedJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderStatus`: Exposes CRUD operations for the **OrderStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderStatuses
    * const orderStatuses = await prisma.orderStatus.findMany()
    * ```
    */
  get orderStatus(): Prisma.OrderStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.overtime`: Exposes CRUD operations for the **Overtime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Overtimes
    * const overtimes = await prisma.overtime.findMany()
    * ```
    */
  get overtime(): Prisma.OvertimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveType`: Exposes CRUD operations for the **LeaveType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveTypes
    * const leaveTypes = await prisma.leaveType.findMany()
    * ```
    */
  get leaveType(): Prisma.LeaveTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leves`: Exposes CRUD operations for the **Leves** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leves
    * const leves = await prisma.leves.findMany()
    * ```
    */
  get leves(): Prisma.LevesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeBankDetails`: Exposes CRUD operations for the **EmployeeBankDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeBankDetails
    * const employeeBankDetails = await prisma.employeeBankDetails.findMany()
    * ```
    */
  get employeeBankDetails(): Prisma.EmployeeBankDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryInfo`: Exposes CRUD operations for the **SalaryInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryInfos
    * const salaryInfos = await prisma.salaryInfo.findMany()
    * ```
    */
  get salaryInfo(): Prisma.SalaryInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.1.0
   * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    EmployeeProfile: 'EmployeeProfile',
    JobPost: 'JobPost',
    Chemist: 'Chemist',
    Depo: 'Depo',
    Party: 'Party',
    Stakeholder: 'Stakeholder',
    StakeholderDeisgnation: 'StakeholderDeisgnation',
    StakeholderDegree: 'StakeholderDegree',
    stakeholderChember: 'stakeholderChember',
    StakeholderOcation: 'StakeholderOcation',
    Customers: 'Customers',
    Scope: 'Scope',
    MpoTarget: 'MpoTarget',
    ProductWiseTarget: 'ProductWiseTarget',
    TargetProductBatch: 'TargetProductBatch',
    Category: 'Category',
    SubCategory: 'SubCategory',
    Unit: 'Unit',
    AccountHead: 'AccountHead',
    LedgerHead: 'LedgerHead',
    Product: 'Product',
    BankAccount: 'BankAccount',
    BankTransaction: 'BankTransaction',
    Inventory: 'Inventory',
    TransactionInfo: 'TransactionInfo',
    Journal: 'Journal',
    FixedJournal: 'FixedJournal',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderStatus: 'OrderStatus',
    Attendance: 'Attendance',
    Overtime: 'Overtime',
    LeaveType: 'LeaveType',
    Leves: 'Leves',
    EmployeeBankDetails: 'EmployeeBankDetails',
    SalaryInfo: 'SalaryInfo',
    Payroll: 'Payroll'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "employeeProfile" | "jobPost" | "chemist" | "depo" | "party" | "stakeholder" | "stakeholderDeisgnation" | "stakeholderDegree" | "stakeholderChember" | "stakeholderOcation" | "customers" | "scope" | "mpoTarget" | "productWiseTarget" | "targetProductBatch" | "category" | "subCategory" | "unit" | "accountHead" | "ledgerHead" | "product" | "bankAccount" | "bankTransaction" | "inventory" | "transactionInfo" | "journal" | "fixedJournal" | "order" | "orderItem" | "orderStatus" | "attendance" | "overtime" | "leaveType" | "leves" | "employeeBankDetails" | "salaryInfo" | "payroll"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      EmployeeProfile: {
        payload: Prisma.$EmployeeProfilePayload<ExtArgs>
        fields: Prisma.EmployeeProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findFirst: {
            args: Prisma.EmployeeProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findMany: {
            args: Prisma.EmployeeProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          create: {
            args: Prisma.EmployeeProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          createMany: {
            args: Prisma.EmployeeProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          update: {
            args: Prisma.EmployeeProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          aggregate: {
            args: Prisma.EmployeeProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeProfile>
          }
          groupBy: {
            args: Prisma.EmployeeProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileCountAggregateOutputType> | number
          }
        }
      }
      JobPost: {
        payload: Prisma.$JobPostPayload<ExtArgs>
        fields: Prisma.JobPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findFirst: {
            args: Prisma.JobPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findMany: {
            args: Prisma.JobPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>[]
          }
          create: {
            args: Prisma.JobPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          createMany: {
            args: Prisma.JobPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          update: {
            args: Prisma.JobPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          deleteMany: {
            args: Prisma.JobPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          aggregate: {
            args: Prisma.JobPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPost>
          }
          groupBy: {
            args: Prisma.JobPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostCountAggregateOutputType> | number
          }
        }
      }
      Chemist: {
        payload: Prisma.$ChemistPayload<ExtArgs>
        fields: Prisma.ChemistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChemistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChemistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload>
          }
          findFirst: {
            args: Prisma.ChemistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChemistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload>
          }
          findMany: {
            args: Prisma.ChemistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload>[]
          }
          create: {
            args: Prisma.ChemistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload>
          }
          createMany: {
            args: Prisma.ChemistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChemistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload>
          }
          update: {
            args: Prisma.ChemistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload>
          }
          deleteMany: {
            args: Prisma.ChemistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChemistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChemistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemistPayload>
          }
          aggregate: {
            args: Prisma.ChemistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChemist>
          }
          groupBy: {
            args: Prisma.ChemistGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChemistGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChemistCountArgs<ExtArgs>
            result: $Utils.Optional<ChemistCountAggregateOutputType> | number
          }
        }
      }
      Depo: {
        payload: Prisma.$DepoPayload<ExtArgs>
        fields: Prisma.DepoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload>
          }
          findFirst: {
            args: Prisma.DepoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload>
          }
          findMany: {
            args: Prisma.DepoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload>[]
          }
          create: {
            args: Prisma.DepoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload>
          }
          createMany: {
            args: Prisma.DepoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload>
          }
          update: {
            args: Prisma.DepoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload>
          }
          deleteMany: {
            args: Prisma.DepoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepoPayload>
          }
          aggregate: {
            args: Prisma.DepoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepo>
          }
          groupBy: {
            args: Prisma.DepoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepoCountArgs<ExtArgs>
            result: $Utils.Optional<DepoCountAggregateOutputType> | number
          }
        }
      }
      Party: {
        payload: Prisma.$PartyPayload<ExtArgs>
        fields: Prisma.PartyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          findFirst: {
            args: Prisma.PartyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          findMany: {
            args: Prisma.PartyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>[]
          }
          create: {
            args: Prisma.PartyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          createMany: {
            args: Prisma.PartyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PartyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          update: {
            args: Prisma.PartyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          deleteMany: {
            args: Prisma.PartyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          aggregate: {
            args: Prisma.PartyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParty>
          }
          groupBy: {
            args: Prisma.PartyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartyCountArgs<ExtArgs>
            result: $Utils.Optional<PartyCountAggregateOutputType> | number
          }
        }
      }
      Stakeholder: {
        payload: Prisma.$StakeholderPayload<ExtArgs>
        fields: Prisma.StakeholderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StakeholderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StakeholderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload>
          }
          findFirst: {
            args: Prisma.StakeholderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StakeholderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload>
          }
          findMany: {
            args: Prisma.StakeholderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload>[]
          }
          create: {
            args: Prisma.StakeholderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload>
          }
          createMany: {
            args: Prisma.StakeholderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StakeholderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload>
          }
          update: {
            args: Prisma.StakeholderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload>
          }
          deleteMany: {
            args: Prisma.StakeholderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StakeholderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StakeholderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderPayload>
          }
          aggregate: {
            args: Prisma.StakeholderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakeholder>
          }
          groupBy: {
            args: Prisma.StakeholderGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakeholderGroupByOutputType>[]
          }
          count: {
            args: Prisma.StakeholderCountArgs<ExtArgs>
            result: $Utils.Optional<StakeholderCountAggregateOutputType> | number
          }
        }
      }
      StakeholderDeisgnation: {
        payload: Prisma.$StakeholderDeisgnationPayload<ExtArgs>
        fields: Prisma.StakeholderDeisgnationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StakeholderDeisgnationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StakeholderDeisgnationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload>
          }
          findFirst: {
            args: Prisma.StakeholderDeisgnationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StakeholderDeisgnationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload>
          }
          findMany: {
            args: Prisma.StakeholderDeisgnationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload>[]
          }
          create: {
            args: Prisma.StakeholderDeisgnationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload>
          }
          createMany: {
            args: Prisma.StakeholderDeisgnationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StakeholderDeisgnationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload>
          }
          update: {
            args: Prisma.StakeholderDeisgnationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload>
          }
          deleteMany: {
            args: Prisma.StakeholderDeisgnationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StakeholderDeisgnationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StakeholderDeisgnationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDeisgnationPayload>
          }
          aggregate: {
            args: Prisma.StakeholderDeisgnationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakeholderDeisgnation>
          }
          groupBy: {
            args: Prisma.StakeholderDeisgnationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakeholderDeisgnationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StakeholderDeisgnationCountArgs<ExtArgs>
            result: $Utils.Optional<StakeholderDeisgnationCountAggregateOutputType> | number
          }
        }
      }
      StakeholderDegree: {
        payload: Prisma.$StakeholderDegreePayload<ExtArgs>
        fields: Prisma.StakeholderDegreeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StakeholderDegreeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StakeholderDegreeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload>
          }
          findFirst: {
            args: Prisma.StakeholderDegreeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StakeholderDegreeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload>
          }
          findMany: {
            args: Prisma.StakeholderDegreeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload>[]
          }
          create: {
            args: Prisma.StakeholderDegreeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload>
          }
          createMany: {
            args: Prisma.StakeholderDegreeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StakeholderDegreeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload>
          }
          update: {
            args: Prisma.StakeholderDegreeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload>
          }
          deleteMany: {
            args: Prisma.StakeholderDegreeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StakeholderDegreeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StakeholderDegreeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderDegreePayload>
          }
          aggregate: {
            args: Prisma.StakeholderDegreeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakeholderDegree>
          }
          groupBy: {
            args: Prisma.StakeholderDegreeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakeholderDegreeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StakeholderDegreeCountArgs<ExtArgs>
            result: $Utils.Optional<StakeholderDegreeCountAggregateOutputType> | number
          }
        }
      }
      stakeholderChember: {
        payload: Prisma.$stakeholderChemberPayload<ExtArgs>
        fields: Prisma.stakeholderChemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stakeholderChemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stakeholderChemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload>
          }
          findFirst: {
            args: Prisma.stakeholderChemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stakeholderChemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload>
          }
          findMany: {
            args: Prisma.stakeholderChemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload>[]
          }
          create: {
            args: Prisma.stakeholderChemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload>
          }
          createMany: {
            args: Prisma.stakeholderChemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.stakeholderChemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload>
          }
          update: {
            args: Prisma.stakeholderChemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload>
          }
          deleteMany: {
            args: Prisma.stakeholderChemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stakeholderChemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.stakeholderChemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderChemberPayload>
          }
          aggregate: {
            args: Prisma.StakeholderChemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakeholderChember>
          }
          groupBy: {
            args: Prisma.stakeholderChemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakeholderChemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.stakeholderChemberCountArgs<ExtArgs>
            result: $Utils.Optional<StakeholderChemberCountAggregateOutputType> | number
          }
        }
      }
      StakeholderOcation: {
        payload: Prisma.$StakeholderOcationPayload<ExtArgs>
        fields: Prisma.StakeholderOcationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StakeholderOcationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StakeholderOcationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload>
          }
          findFirst: {
            args: Prisma.StakeholderOcationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StakeholderOcationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload>
          }
          findMany: {
            args: Prisma.StakeholderOcationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload>[]
          }
          create: {
            args: Prisma.StakeholderOcationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload>
          }
          createMany: {
            args: Prisma.StakeholderOcationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StakeholderOcationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload>
          }
          update: {
            args: Prisma.StakeholderOcationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload>
          }
          deleteMany: {
            args: Prisma.StakeholderOcationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StakeholderOcationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StakeholderOcationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StakeholderOcationPayload>
          }
          aggregate: {
            args: Prisma.StakeholderOcationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakeholderOcation>
          }
          groupBy: {
            args: Prisma.StakeholderOcationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakeholderOcationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StakeholderOcationCountArgs<ExtArgs>
            result: $Utils.Optional<StakeholderOcationCountAggregateOutputType> | number
          }
        }
      }
      Customers: {
        payload: Prisma.$CustomersPayload<ExtArgs>
        fields: Prisma.CustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findFirst: {
            args: Prisma.CustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findMany: {
            args: Prisma.CustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          create: {
            args: Prisma.CustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          createMany: {
            args: Prisma.CustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          update: {
            args: Prisma.CustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          deleteMany: {
            args: Prisma.CustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.CustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      Scope: {
        payload: Prisma.$ScopePayload<ExtArgs>
        fields: Prisma.ScopeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScopeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScopeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload>
          }
          findFirst: {
            args: Prisma.ScopeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScopeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload>
          }
          findMany: {
            args: Prisma.ScopeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload>[]
          }
          create: {
            args: Prisma.ScopeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload>
          }
          createMany: {
            args: Prisma.ScopeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScopeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload>
          }
          update: {
            args: Prisma.ScopeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload>
          }
          deleteMany: {
            args: Prisma.ScopeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScopeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScopeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopePayload>
          }
          aggregate: {
            args: Prisma.ScopeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScope>
          }
          groupBy: {
            args: Prisma.ScopeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScopeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScopeCountArgs<ExtArgs>
            result: $Utils.Optional<ScopeCountAggregateOutputType> | number
          }
        }
      }
      MpoTarget: {
        payload: Prisma.$MpoTargetPayload<ExtArgs>
        fields: Prisma.MpoTargetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MpoTargetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MpoTargetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload>
          }
          findFirst: {
            args: Prisma.MpoTargetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MpoTargetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload>
          }
          findMany: {
            args: Prisma.MpoTargetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload>[]
          }
          create: {
            args: Prisma.MpoTargetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload>
          }
          createMany: {
            args: Prisma.MpoTargetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MpoTargetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload>
          }
          update: {
            args: Prisma.MpoTargetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload>
          }
          deleteMany: {
            args: Prisma.MpoTargetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MpoTargetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MpoTargetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpoTargetPayload>
          }
          aggregate: {
            args: Prisma.MpoTargetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMpoTarget>
          }
          groupBy: {
            args: Prisma.MpoTargetGroupByArgs<ExtArgs>
            result: $Utils.Optional<MpoTargetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MpoTargetCountArgs<ExtArgs>
            result: $Utils.Optional<MpoTargetCountAggregateOutputType> | number
          }
        }
      }
      ProductWiseTarget: {
        payload: Prisma.$ProductWiseTargetPayload<ExtArgs>
        fields: Prisma.ProductWiseTargetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductWiseTargetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductWiseTargetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload>
          }
          findFirst: {
            args: Prisma.ProductWiseTargetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductWiseTargetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload>
          }
          findMany: {
            args: Prisma.ProductWiseTargetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload>[]
          }
          create: {
            args: Prisma.ProductWiseTargetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload>
          }
          createMany: {
            args: Prisma.ProductWiseTargetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductWiseTargetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload>
          }
          update: {
            args: Prisma.ProductWiseTargetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload>
          }
          deleteMany: {
            args: Prisma.ProductWiseTargetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductWiseTargetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductWiseTargetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWiseTargetPayload>
          }
          aggregate: {
            args: Prisma.ProductWiseTargetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductWiseTarget>
          }
          groupBy: {
            args: Prisma.ProductWiseTargetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductWiseTargetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductWiseTargetCountArgs<ExtArgs>
            result: $Utils.Optional<ProductWiseTargetCountAggregateOutputType> | number
          }
        }
      }
      TargetProductBatch: {
        payload: Prisma.$TargetProductBatchPayload<ExtArgs>
        fields: Prisma.TargetProductBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TargetProductBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TargetProductBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload>
          }
          findFirst: {
            args: Prisma.TargetProductBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TargetProductBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload>
          }
          findMany: {
            args: Prisma.TargetProductBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload>[]
          }
          create: {
            args: Prisma.TargetProductBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload>
          }
          createMany: {
            args: Prisma.TargetProductBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TargetProductBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload>
          }
          update: {
            args: Prisma.TargetProductBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload>
          }
          deleteMany: {
            args: Prisma.TargetProductBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TargetProductBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TargetProductBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetProductBatchPayload>
          }
          aggregate: {
            args: Prisma.TargetProductBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTargetProductBatch>
          }
          groupBy: {
            args: Prisma.TargetProductBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<TargetProductBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.TargetProductBatchCountArgs<ExtArgs>
            result: $Utils.Optional<TargetProductBatchCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      SubCategory: {
        payload: Prisma.$SubCategoryPayload<ExtArgs>
        fields: Prisma.SubCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findFirst: {
            args: Prisma.SubCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findMany: {
            args: Prisma.SubCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>[]
          }
          create: {
            args: Prisma.SubCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          createMany: {
            args: Prisma.SubCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          update: {
            args: Prisma.SubCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          aggregate: {
            args: Prisma.SubCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubCategory>
          }
          groupBy: {
            args: Prisma.SubCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      AccountHead: {
        payload: Prisma.$AccountHeadPayload<ExtArgs>
        fields: Prisma.AccountHeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountHeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountHeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          findFirst: {
            args: Prisma.AccountHeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountHeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          findMany: {
            args: Prisma.AccountHeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>[]
          }
          create: {
            args: Prisma.AccountHeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          createMany: {
            args: Prisma.AccountHeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountHeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          update: {
            args: Prisma.AccountHeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          deleteMany: {
            args: Prisma.AccountHeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountHeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountHeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          aggregate: {
            args: Prisma.AccountHeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountHead>
          }
          groupBy: {
            args: Prisma.AccountHeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountHeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountHeadCountArgs<ExtArgs>
            result: $Utils.Optional<AccountHeadCountAggregateOutputType> | number
          }
        }
      }
      LedgerHead: {
        payload: Prisma.$LedgerHeadPayload<ExtArgs>
        fields: Prisma.LedgerHeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerHeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerHeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload>
          }
          findFirst: {
            args: Prisma.LedgerHeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerHeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload>
          }
          findMany: {
            args: Prisma.LedgerHeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload>[]
          }
          create: {
            args: Prisma.LedgerHeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload>
          }
          createMany: {
            args: Prisma.LedgerHeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LedgerHeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload>
          }
          update: {
            args: Prisma.LedgerHeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload>
          }
          deleteMany: {
            args: Prisma.LedgerHeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerHeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerHeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerHeadPayload>
          }
          aggregate: {
            args: Prisma.LedgerHeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerHead>
          }
          groupBy: {
            args: Prisma.LedgerHeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerHeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerHeadCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerHeadCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      BankTransaction: {
        payload: Prisma.$BankTransactionPayload<ExtArgs>
        fields: Prisma.BankTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findFirst: {
            args: Prisma.BankTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findMany: {
            args: Prisma.BankTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          create: {
            args: Prisma.BankTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          createMany: {
            args: Prisma.BankTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BankTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          update: {
            args: Prisma.BankTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BankTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          aggregate: {
            args: Prisma.BankTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankTransaction>
          }
          groupBy: {
            args: Prisma.BankTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      TransactionInfo: {
        payload: Prisma.$TransactionInfoPayload<ExtArgs>
        fields: Prisma.TransactionInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload>
          }
          findFirst: {
            args: Prisma.TransactionInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload>
          }
          findMany: {
            args: Prisma.TransactionInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload>[]
          }
          create: {
            args: Prisma.TransactionInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload>
          }
          createMany: {
            args: Prisma.TransactionInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload>
          }
          update: {
            args: Prisma.TransactionInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload>
          }
          deleteMany: {
            args: Prisma.TransactionInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionInfoPayload>
          }
          aggregate: {
            args: Prisma.TransactionInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionInfo>
          }
          groupBy: {
            args: Prisma.TransactionInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionInfoCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionInfoCountAggregateOutputType> | number
          }
        }
      }
      Journal: {
        payload: Prisma.$JournalPayload<ExtArgs>
        fields: Prisma.JournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findFirst: {
            args: Prisma.JournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findMany: {
            args: Prisma.JournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          create: {
            args: Prisma.JournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          createMany: {
            args: Prisma.JournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          update: {
            args: Prisma.JournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          deleteMany: {
            args: Prisma.JournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          aggregate: {
            args: Prisma.JournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournal>
          }
          groupBy: {
            args: Prisma.JournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCountAggregateOutputType> | number
          }
        }
      }
      FixedJournal: {
        payload: Prisma.$FixedJournalPayload<ExtArgs>
        fields: Prisma.FixedJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FixedJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FixedJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload>
          }
          findFirst: {
            args: Prisma.FixedJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FixedJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload>
          }
          findMany: {
            args: Prisma.FixedJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload>[]
          }
          create: {
            args: Prisma.FixedJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload>
          }
          createMany: {
            args: Prisma.FixedJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FixedJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload>
          }
          update: {
            args: Prisma.FixedJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload>
          }
          deleteMany: {
            args: Prisma.FixedJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FixedJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FixedJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedJournalPayload>
          }
          aggregate: {
            args: Prisma.FixedJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFixedJournal>
          }
          groupBy: {
            args: Prisma.FixedJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<FixedJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.FixedJournalCountArgs<ExtArgs>
            result: $Utils.Optional<FixedJournalCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderStatus: {
        payload: Prisma.$OrderStatusPayload<ExtArgs>
        fields: Prisma.OrderStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findFirst: {
            args: Prisma.OrderStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findMany: {
            args: Prisma.OrderStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>[]
          }
          create: {
            args: Prisma.OrderStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          createMany: {
            args: Prisma.OrderStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          update: {
            args: Prisma.OrderStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          deleteMany: {
            args: Prisma.OrderStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          aggregate: {
            args: Prisma.OrderStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderStatus>
          }
          groupBy: {
            args: Prisma.OrderStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderStatusCountArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Overtime: {
        payload: Prisma.$OvertimePayload<ExtArgs>
        fields: Prisma.OvertimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OvertimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OvertimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          findFirst: {
            args: Prisma.OvertimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OvertimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          findMany: {
            args: Prisma.OvertimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>[]
          }
          create: {
            args: Prisma.OvertimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          createMany: {
            args: Prisma.OvertimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OvertimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          update: {
            args: Prisma.OvertimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          deleteMany: {
            args: Prisma.OvertimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OvertimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OvertimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          aggregate: {
            args: Prisma.OvertimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOvertime>
          }
          groupBy: {
            args: Prisma.OvertimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OvertimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OvertimeCountArgs<ExtArgs>
            result: $Utils.Optional<OvertimeCountAggregateOutputType> | number
          }
        }
      }
      LeaveType: {
        payload: Prisma.$LeaveTypePayload<ExtArgs>
        fields: Prisma.LeaveTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findFirst: {
            args: Prisma.LeaveTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findMany: {
            args: Prisma.LeaveTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          create: {
            args: Prisma.LeaveTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          createMany: {
            args: Prisma.LeaveTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeaveTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          update: {
            args: Prisma.LeaveTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          deleteMany: {
            args: Prisma.LeaveTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          aggregate: {
            args: Prisma.LeaveTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveType>
          }
          groupBy: {
            args: Prisma.LeaveTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveTypeCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeCountAggregateOutputType> | number
          }
        }
      }
      Leves: {
        payload: Prisma.$LevesPayload<ExtArgs>
        fields: Prisma.LevesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload>
          }
          findFirst: {
            args: Prisma.LevesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload>
          }
          findMany: {
            args: Prisma.LevesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload>[]
          }
          create: {
            args: Prisma.LevesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload>
          }
          createMany: {
            args: Prisma.LevesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LevesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload>
          }
          update: {
            args: Prisma.LevesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload>
          }
          deleteMany: {
            args: Prisma.LevesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevesPayload>
          }
          aggregate: {
            args: Prisma.LevesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeves>
          }
          groupBy: {
            args: Prisma.LevesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevesCountArgs<ExtArgs>
            result: $Utils.Optional<LevesCountAggregateOutputType> | number
          }
        }
      }
      EmployeeBankDetails: {
        payload: Prisma.$EmployeeBankDetailsPayload<ExtArgs>
        fields: Prisma.EmployeeBankDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeBankDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeBankDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload>
          }
          findFirst: {
            args: Prisma.EmployeeBankDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeBankDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload>
          }
          findMany: {
            args: Prisma.EmployeeBankDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload>[]
          }
          create: {
            args: Prisma.EmployeeBankDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload>
          }
          createMany: {
            args: Prisma.EmployeeBankDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeBankDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload>
          }
          update: {
            args: Prisma.EmployeeBankDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeBankDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeBankDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeBankDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBankDetailsPayload>
          }
          aggregate: {
            args: Prisma.EmployeeBankDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeBankDetails>
          }
          groupBy: {
            args: Prisma.EmployeeBankDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBankDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeBankDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBankDetailsCountAggregateOutputType> | number
          }
        }
      }
      SalaryInfo: {
        payload: Prisma.$SalaryInfoPayload<ExtArgs>
        fields: Prisma.SalaryInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload>
          }
          findFirst: {
            args: Prisma.SalaryInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload>
          }
          findMany: {
            args: Prisma.SalaryInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload>[]
          }
          create: {
            args: Prisma.SalaryInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload>
          }
          createMany: {
            args: Prisma.SalaryInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SalaryInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload>
          }
          update: {
            args: Prisma.SalaryInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload>
          }
          deleteMany: {
            args: Prisma.SalaryInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryInfoPayload>
          }
          aggregate: {
            args: Prisma.SalaryInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryInfo>
          }
          groupBy: {
            args: Prisma.SalaryInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryInfoCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryInfoCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    employeeProfile?: EmployeeProfileOmit
    jobPost?: JobPostOmit
    chemist?: ChemistOmit
    depo?: DepoOmit
    party?: PartyOmit
    stakeholder?: StakeholderOmit
    stakeholderDeisgnation?: StakeholderDeisgnationOmit
    stakeholderDegree?: StakeholderDegreeOmit
    stakeholderChember?: stakeholderChemberOmit
    stakeholderOcation?: StakeholderOcationOmit
    customers?: CustomersOmit
    scope?: ScopeOmit
    mpoTarget?: MpoTargetOmit
    productWiseTarget?: ProductWiseTargetOmit
    targetProductBatch?: TargetProductBatchOmit
    category?: CategoryOmit
    subCategory?: SubCategoryOmit
    unit?: UnitOmit
    accountHead?: AccountHeadOmit
    ledgerHead?: LedgerHeadOmit
    product?: ProductOmit
    bankAccount?: BankAccountOmit
    bankTransaction?: BankTransactionOmit
    inventory?: InventoryOmit
    transactionInfo?: TransactionInfoOmit
    journal?: JournalOmit
    fixedJournal?: FixedJournalOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    orderStatus?: OrderStatusOmit
    attendance?: AttendanceOmit
    overtime?: OvertimeOmit
    leaveType?: LeaveTypeOmit
    leves?: LevesOmit
    employeeBankDetails?: EmployeeBankDetailsOmit
    salaryInfo?: SalaryInfoOmit
    payroll?: PayrollOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    attendance: number
    leves: number
    order: number
    overtime: number
    payroll: number
    salaryInfo: number
    transactionInfo: number
    inventories: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | UserCountOutputTypeCountAttendanceArgs
    leves?: boolean | UserCountOutputTypeCountLevesArgs
    order?: boolean | UserCountOutputTypeCountOrderArgs
    overtime?: boolean | UserCountOutputTypeCountOvertimeArgs
    payroll?: boolean | UserCountOutputTypeCountPayrollArgs
    salaryInfo?: boolean | UserCountOutputTypeCountSalaryInfoArgs
    transactionInfo?: boolean | UserCountOutputTypeCountTransactionInfoArgs
    inventories?: boolean | UserCountOutputTypeCountInventoriesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLevesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOvertimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryInfoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionInfoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * Count Type JobPostCountOutputType
   */

  export type JobPostCountOutputType = {
    scope: number
  }

  export type JobPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scope?: boolean | JobPostCountOutputTypeCountScopeArgs
  }

  // Custom InputTypes
  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostCountOutputType
     */
    select?: JobPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountScopeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScopeWhereInput
  }


  /**
   * Count Type ChemistCountOutputType
   */

  export type ChemistCountOutputType = {
    scopes: number
    FixedJournal: number
    order: number
    transactionInfo: number
  }

  export type ChemistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scopes?: boolean | ChemistCountOutputTypeCountScopesArgs
    FixedJournal?: boolean | ChemistCountOutputTypeCountFixedJournalArgs
    order?: boolean | ChemistCountOutputTypeCountOrderArgs
    transactionInfo?: boolean | ChemistCountOutputTypeCountTransactionInfoArgs
  }

  // Custom InputTypes
  /**
   * ChemistCountOutputType without action
   */
  export type ChemistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemistCountOutputType
     */
    select?: ChemistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChemistCountOutputType without action
   */
  export type ChemistCountOutputTypeCountScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScopeWhereInput
  }

  /**
   * ChemistCountOutputType without action
   */
  export type ChemistCountOutputTypeCountFixedJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixedJournalWhereInput
  }

  /**
   * ChemistCountOutputType without action
   */
  export type ChemistCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ChemistCountOutputType without action
   */
  export type ChemistCountOutputTypeCountTransactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionInfoWhereInput
  }


  /**
   * Count Type DepoCountOutputType
   */

  export type DepoCountOutputType = {
    chemist: number
    FixedJournal: number
    inventory: number
    jobPost: number
    journal: number
    scopes: number
  }

  export type DepoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chemist?: boolean | DepoCountOutputTypeCountChemistArgs
    FixedJournal?: boolean | DepoCountOutputTypeCountFixedJournalArgs
    inventory?: boolean | DepoCountOutputTypeCountInventoryArgs
    jobPost?: boolean | DepoCountOutputTypeCountJobPostArgs
    journal?: boolean | DepoCountOutputTypeCountJournalArgs
    scopes?: boolean | DepoCountOutputTypeCountScopesArgs
  }

  // Custom InputTypes
  /**
   * DepoCountOutputType without action
   */
  export type DepoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepoCountOutputType
     */
    select?: DepoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepoCountOutputType without action
   */
  export type DepoCountOutputTypeCountChemistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChemistWhereInput
  }

  /**
   * DepoCountOutputType without action
   */
  export type DepoCountOutputTypeCountFixedJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixedJournalWhereInput
  }

  /**
   * DepoCountOutputType without action
   */
  export type DepoCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * DepoCountOutputType without action
   */
  export type DepoCountOutputTypeCountJobPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
  }

  /**
   * DepoCountOutputType without action
   */
  export type DepoCountOutputTypeCountJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
  }

  /**
   * DepoCountOutputType without action
   */
  export type DepoCountOutputTypeCountScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScopeWhereInput
  }


  /**
   * Count Type PartyCountOutputType
   */

  export type PartyCountOutputType = {
    transactionInfo: number
  }

  export type PartyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionInfo?: boolean | PartyCountOutputTypeCountTransactionInfoArgs
  }

  // Custom InputTypes
  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyCountOutputType
     */
    select?: PartyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeCountTransactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionInfoWhereInput
  }


  /**
   * Count Type StakeholderCountOutputType
   */

  export type StakeholderCountOutputType = {
    product: number
    scopes: number
    stakeholderChember: number
    stakeholderOcation: number
    transactionInfo: number
  }

  export type StakeholderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | StakeholderCountOutputTypeCountProductArgs
    scopes?: boolean | StakeholderCountOutputTypeCountScopesArgs
    stakeholderChember?: boolean | StakeholderCountOutputTypeCountStakeholderChemberArgs
    stakeholderOcation?: boolean | StakeholderCountOutputTypeCountStakeholderOcationArgs
    transactionInfo?: boolean | StakeholderCountOutputTypeCountTransactionInfoArgs
  }

  // Custom InputTypes
  /**
   * StakeholderCountOutputType without action
   */
  export type StakeholderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderCountOutputType
     */
    select?: StakeholderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StakeholderCountOutputType without action
   */
  export type StakeholderCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * StakeholderCountOutputType without action
   */
  export type StakeholderCountOutputTypeCountScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScopeWhereInput
  }

  /**
   * StakeholderCountOutputType without action
   */
  export type StakeholderCountOutputTypeCountStakeholderChemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stakeholderChemberWhereInput
  }

  /**
   * StakeholderCountOutputType without action
   */
  export type StakeholderCountOutputTypeCountStakeholderOcationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderOcationWhereInput
  }

  /**
   * StakeholderCountOutputType without action
   */
  export type StakeholderCountOutputTypeCountTransactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionInfoWhereInput
  }


  /**
   * Count Type StakeholderDeisgnationCountOutputType
   */

  export type StakeholderDeisgnationCountOutputType = {
    stakeholder: number
  }

  export type StakeholderDeisgnationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholder?: boolean | StakeholderDeisgnationCountOutputTypeCountStakeholderArgs
  }

  // Custom InputTypes
  /**
   * StakeholderDeisgnationCountOutputType without action
   */
  export type StakeholderDeisgnationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnationCountOutputType
     */
    select?: StakeholderDeisgnationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StakeholderDeisgnationCountOutputType without action
   */
  export type StakeholderDeisgnationCountOutputTypeCountStakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderWhereInput
  }


  /**
   * Count Type StakeholderDegreeCountOutputType
   */

  export type StakeholderDegreeCountOutputType = {
    stakeholder: number
  }

  export type StakeholderDegreeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholder?: boolean | StakeholderDegreeCountOutputTypeCountStakeholderArgs
  }

  // Custom InputTypes
  /**
   * StakeholderDegreeCountOutputType without action
   */
  export type StakeholderDegreeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegreeCountOutputType
     */
    select?: StakeholderDegreeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StakeholderDegreeCountOutputType without action
   */
  export type StakeholderDegreeCountOutputTypeCountStakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderWhereInput
  }


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    transactionInfo: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionInfo?: boolean | CustomersCountOutputTypeCountTransactionInfoArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountTransactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionInfoWhereInput
  }


  /**
   * Count Type ScopeCountOutputType
   */

  export type ScopeCountOutputType = {
    chemist: number
    depo: number
    stakeholder: number
  }

  export type ScopeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chemist?: boolean | ScopeCountOutputTypeCountChemistArgs
    depo?: boolean | ScopeCountOutputTypeCountDepoArgs
    stakeholder?: boolean | ScopeCountOutputTypeCountStakeholderArgs
  }

  // Custom InputTypes
  /**
   * ScopeCountOutputType without action
   */
  export type ScopeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeCountOutputType
     */
    select?: ScopeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScopeCountOutputType without action
   */
  export type ScopeCountOutputTypeCountChemistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChemistWhereInput
  }

  /**
   * ScopeCountOutputType without action
   */
  export type ScopeCountOutputTypeCountDepoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepoWhereInput
  }

  /**
   * ScopeCountOutputType without action
   */
  export type ScopeCountOutputTypeCountStakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderWhereInput
  }


  /**
   * Count Type ProductWiseTargetCountOutputType
   */

  export type ProductWiseTargetCountOutputType = {
    targetProductBatch: number
  }

  export type ProductWiseTargetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetProductBatch?: boolean | ProductWiseTargetCountOutputTypeCountTargetProductBatchArgs
  }

  // Custom InputTypes
  /**
   * ProductWiseTargetCountOutputType without action
   */
  export type ProductWiseTargetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTargetCountOutputType
     */
    select?: ProductWiseTargetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductWiseTargetCountOutputType without action
   */
  export type ProductWiseTargetCountOutputTypeCountTargetProductBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetProductBatchWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    subCategory: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategory?: boolean | CategoryCountOutputTypeCountSubCategoryArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
  }


  /**
   * Count Type SubCategoryCountOutputType
   */

  export type SubCategoryCountOutputType = {
    product: number
  }

  export type SubCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | SubCategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryCountOutputType
     */
    select?: SubCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    product: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | UnitCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type AccountHeadCountOutputType
   */

  export type AccountHeadCountOutputType = {
    ledgerHead: number
  }

  export type AccountHeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerHead?: boolean | AccountHeadCountOutputTypeCountLedgerHeadArgs
  }

  // Custom InputTypes
  /**
   * AccountHeadCountOutputType without action
   */
  export type AccountHeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHeadCountOutputType
     */
    select?: AccountHeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountHeadCountOutputType without action
   */
  export type AccountHeadCountOutputTypeCountLedgerHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerHeadWhereInput
  }


  /**
   * Count Type LedgerHeadCountOutputType
   */

  export type LedgerHeadCountOutputType = {
    fixedJournal: number
    journal: number
  }

  export type LedgerHeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fixedJournal?: boolean | LedgerHeadCountOutputTypeCountFixedJournalArgs
    journal?: boolean | LedgerHeadCountOutputTypeCountJournalArgs
  }

  // Custom InputTypes
  /**
   * LedgerHeadCountOutputType without action
   */
  export type LedgerHeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHeadCountOutputType
     */
    select?: LedgerHeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LedgerHeadCountOutputType without action
   */
  export type LedgerHeadCountOutputTypeCountFixedJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixedJournalWhereInput
  }

  /**
   * LedgerHeadCountOutputType without action
   */
  export type LedgerHeadCountOutputTypeCountJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    targetProductBatch: number
    inventory: number
    orderItem: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetProductBatch?: boolean | ProductCountOutputTypeCountTargetProductBatchArgs
    inventory?: boolean | ProductCountOutputTypeCountInventoryArgs
    orderItem?: boolean | ProductCountOutputTypeCountOrderItemArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTargetProductBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetProductBatchWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type BankAccountCountOutputType
   */

  export type BankAccountCountOutputType = {
    bankTransaction: number
  }

  export type BankAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankTransaction?: boolean | BankAccountCountOutputTypeCountBankTransactionArgs
  }

  // Custom InputTypes
  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccountCountOutputType
     */
    select?: BankAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountBankTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
  }


  /**
   * Count Type TransactionInfoCountOutputType
   */

  export type TransactionInfoCountOutputType = {
    inventory: number
    journal: number
  }

  export type TransactionInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | TransactionInfoCountOutputTypeCountInventoryArgs
    journal?: boolean | TransactionInfoCountOutputTypeCountJournalArgs
  }

  // Custom InputTypes
  /**
   * TransactionInfoCountOutputType without action
   */
  export type TransactionInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfoCountOutputType
     */
    select?: TransactionInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionInfoCountOutputType without action
   */
  export type TransactionInfoCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * TransactionInfoCountOutputType without action
   */
  export type TransactionInfoCountOutputTypeCountJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
  }


  /**
   * Count Type JournalCountOutputType
   */

  export type JournalCountOutputType = {
    bankTransaction: number
  }

  export type JournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankTransaction?: boolean | JournalCountOutputTypeCountBankTransactionArgs
  }

  // Custom InputTypes
  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCountOutputType
     */
    select?: JournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeCountBankTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
  }


  /**
   * Count Type FixedJournalCountOutputType
   */

  export type FixedJournalCountOutputType = {
    inventory: number
  }

  export type FixedJournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | FixedJournalCountOutputTypeCountInventoryArgs
  }

  // Custom InputTypes
  /**
   * FixedJournalCountOutputType without action
   */
  export type FixedJournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournalCountOutputType
     */
    select?: FixedJournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FixedJournalCountOutputType without action
   */
  export type FixedJournalCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItem: number
    orderStatus: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderCountOutputTypeCountOrderItemArgs
    orderStatus?: boolean | OrderCountOutputTypeCountOrderStatusArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusWhereInput
  }


  /**
   * Count Type LeaveTypeCountOutputType
   */

  export type LeaveTypeCountOutputType = {
    leves: number
  }

  export type LeaveTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leves?: boolean | LeaveTypeCountOutputTypeCountLevesArgs
  }

  // Custom InputTypes
  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveTypeCountOutputType
     */
    select?: LeaveTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeCountLevesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    name: string | null
    email: string | null
    password: string | null
    photo: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    name: string | null
    email: string | null
    password: string | null
    photo: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    employeeId: number
    name: number
    email: number
    password: number
    photo: number
    roles: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    employeeId?: true
    name?: true
    email?: true
    password?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    employeeId?: true
    name?: true
    email?: true
    password?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    employeeId?: true
    name?: true
    email?: true
    password?: true
    photo?: true
    roles?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    employeeId: string
    name: string
    email: string
    password: string
    photo: string | null
    roles: JsonValue
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    photo?: boolean
    roles?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productWiseTarget?: boolean | User$productWiseTargetArgs<ExtArgs>
    attendance?: boolean | User$attendanceArgs<ExtArgs>
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    leves?: boolean | User$levesArgs<ExtArgs>
    mpoTarget?: boolean | User$mpoTargetArgs<ExtArgs>
    order?: boolean | User$orderArgs<ExtArgs>
    overtime?: boolean | User$overtimeArgs<ExtArgs>
    payroll?: boolean | User$payrollArgs<ExtArgs>
    salaryInfo?: boolean | User$salaryInfoArgs<ExtArgs>
    scope?: boolean | User$scopeArgs<ExtArgs>
    transactionInfo?: boolean | User$transactionInfoArgs<ExtArgs>
    inventories?: boolean | User$inventoriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    employeeId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    photo?: boolean
    roles?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "name" | "email" | "password" | "photo" | "roles" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productWiseTarget?: boolean | User$productWiseTargetArgs<ExtArgs>
    attendance?: boolean | User$attendanceArgs<ExtArgs>
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    leves?: boolean | User$levesArgs<ExtArgs>
    mpoTarget?: boolean | User$mpoTargetArgs<ExtArgs>
    order?: boolean | User$orderArgs<ExtArgs>
    overtime?: boolean | User$overtimeArgs<ExtArgs>
    payroll?: boolean | User$payrollArgs<ExtArgs>
    salaryInfo?: boolean | User$salaryInfoArgs<ExtArgs>
    scope?: boolean | User$scopeArgs<ExtArgs>
    transactionInfo?: boolean | User$transactionInfoArgs<ExtArgs>
    inventories?: boolean | User$inventoriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      productWiseTarget: Prisma.$ProductWiseTargetPayload<ExtArgs> | null
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      employeeProfile: Prisma.$EmployeeProfilePayload<ExtArgs> | null
      leves: Prisma.$LevesPayload<ExtArgs>[]
      mpoTarget: Prisma.$MpoTargetPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs>[]
      overtime: Prisma.$OvertimePayload<ExtArgs>[]
      payroll: Prisma.$PayrollPayload<ExtArgs>[]
      salaryInfo: Prisma.$SalaryInfoPayload<ExtArgs>[]
      scope: Prisma.$ScopePayload<ExtArgs> | null
      transactionInfo: Prisma.$TransactionInfoPayload<ExtArgs>[]
      inventories: Prisma.$InventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      name: string
      email: string
      password: string
      photo: string | null
      roles: Prisma.JsonValue
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productWiseTarget<T extends User$productWiseTargetArgs<ExtArgs> = {}>(args?: Subset<T, User$productWiseTargetArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendance<T extends User$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeProfile<T extends User$employeeProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeProfileArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    leves<T extends User$levesArgs<ExtArgs> = {}>(args?: Subset<T, User$levesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mpoTarget<T extends User$mpoTargetArgs<ExtArgs> = {}>(args?: Subset<T, User$mpoTargetArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends User$orderArgs<ExtArgs> = {}>(args?: Subset<T, User$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtime<T extends User$overtimeArgs<ExtArgs> = {}>(args?: Subset<T, User$overtimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payroll<T extends User$payrollArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryInfo<T extends User$salaryInfoArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scope<T extends User$scopeArgs<ExtArgs> = {}>(args?: Subset<T, User$scopeArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactionInfo<T extends User$transactionInfoArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventories<T extends User$inventoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly employeeId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly roles: FieldRef<"User", 'Json'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.productWiseTarget
   */
  export type User$productWiseTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    where?: ProductWiseTargetWhereInput
  }

  /**
   * User.attendance
   */
  export type User$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.employeeProfile
   */
  export type User$employeeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    where?: EmployeeProfileWhereInput
  }

  /**
   * User.leves
   */
  export type User$levesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    where?: LevesWhereInput
    orderBy?: LevesOrderByWithRelationInput | LevesOrderByWithRelationInput[]
    cursor?: LevesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevesScalarFieldEnum | LevesScalarFieldEnum[]
  }

  /**
   * User.mpoTarget
   */
  export type User$mpoTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    where?: MpoTargetWhereInput
  }

  /**
   * User.order
   */
  export type User$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.overtime
   */
  export type User$overtimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    cursor?: OvertimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * User.payroll
   */
  export type User$payrollArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * User.salaryInfo
   */
  export type User$salaryInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    where?: SalaryInfoWhereInput
    orderBy?: SalaryInfoOrderByWithRelationInput | SalaryInfoOrderByWithRelationInput[]
    cursor?: SalaryInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryInfoScalarFieldEnum | SalaryInfoScalarFieldEnum[]
  }

  /**
   * User.scope
   */
  export type User$scopeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    where?: ScopeWhereInput
  }

  /**
   * User.transactionInfo
   */
  export type User$transactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    where?: TransactionInfoWhereInput
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    cursor?: TransactionInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * User.inventories
   */
  export type User$inventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeProfile
   */

  export type AggregateEmployeeProfile = {
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  export type EmployeeProfileAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeeProfileSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeeProfileMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    fatherName: string | null
    motherName: string | null
    officeContactNo: string | null
    currentAddress: string | null
    permanentAddress: string | null
    nid: string | null
    dob: Date | null
    contactNo: string | null
    emergencyContactNo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeProfileMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    fatherName: string | null
    motherName: string | null
    officeContactNo: string | null
    currentAddress: string | null
    permanentAddress: string | null
    nid: string | null
    dob: Date | null
    contactNo: string | null
    emergencyContactNo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeProfileCountAggregateOutputType = {
    id: number
    employeeId: number
    fatherName: number
    motherName: number
    officeContactNo: number
    currentAddress: number
    permanentAddress: number
    nid: number
    dob: number
    contactNo: number
    emergencyContactNo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeProfileAvgAggregateInputType = {
    id?: true
  }

  export type EmployeeProfileSumAggregateInputType = {
    id?: true
  }

  export type EmployeeProfileMinAggregateInputType = {
    id?: true
    employeeId?: true
    fatherName?: true
    motherName?: true
    officeContactNo?: true
    currentAddress?: true
    permanentAddress?: true
    nid?: true
    dob?: true
    contactNo?: true
    emergencyContactNo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeProfileMaxAggregateInputType = {
    id?: true
    employeeId?: true
    fatherName?: true
    motherName?: true
    officeContactNo?: true
    currentAddress?: true
    permanentAddress?: true
    nid?: true
    dob?: true
    contactNo?: true
    emergencyContactNo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeProfileCountAggregateInputType = {
    id?: true
    employeeId?: true
    fatherName?: true
    motherName?: true
    officeContactNo?: true
    currentAddress?: true
    permanentAddress?: true
    nid?: true
    dob?: true
    contactNo?: true
    emergencyContactNo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfile to aggregate.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeProfiles
    **/
    _count?: true | EmployeeProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type GetEmployeeProfileAggregateType<T extends EmployeeProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeProfile[P]>
      : GetScalarType<T[P], AggregateEmployeeProfile[P]>
  }




  export type EmployeeProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeProfileWhereInput
    orderBy?: EmployeeProfileOrderByWithAggregationInput | EmployeeProfileOrderByWithAggregationInput[]
    by: EmployeeProfileScalarFieldEnum[] | EmployeeProfileScalarFieldEnum
    having?: EmployeeProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeProfileCountAggregateInputType | true
    _avg?: EmployeeProfileAvgAggregateInputType
    _sum?: EmployeeProfileSumAggregateInputType
    _min?: EmployeeProfileMinAggregateInputType
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type EmployeeProfileGroupByOutputType = {
    id: number
    employeeId: string
    fatherName: string
    motherName: string
    officeContactNo: string | null
    currentAddress: string | null
    permanentAddress: string | null
    nid: string | null
    dob: Date
    contactNo: string
    emergencyContactNo: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  type GetEmployeeProfileGroupByPayload<T extends EmployeeProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    fatherName?: boolean
    motherName?: boolean
    officeContactNo?: boolean
    currentAddress?: boolean
    permanentAddress?: boolean
    nid?: boolean
    dob?: boolean
    contactNo?: boolean
    emergencyContactNo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>



  export type EmployeeProfileSelectScalar = {
    id?: boolean
    employeeId?: boolean
    fatherName?: boolean
    motherName?: boolean
    officeContactNo?: boolean
    currentAddress?: boolean
    permanentAddress?: boolean
    nid?: boolean
    dob?: boolean
    contactNo?: boolean
    emergencyContactNo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "fatherName" | "motherName" | "officeContactNo" | "currentAddress" | "permanentAddress" | "nid" | "dob" | "contactNo" | "emergencyContactNo" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeProfile"]>
  export type EmployeeProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      fatherName: string
      motherName: string
      officeContactNo: string | null
      currentAddress: string | null
      permanentAddress: string | null
      nid: string | null
      dob: Date
      contactNo: string
      emergencyContactNo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeProfile"]>
    composites: {}
  }

  type EmployeeProfileGetPayload<S extends boolean | null | undefined | EmployeeProfileDefaultArgs> = $Result.GetResult<Prisma.$EmployeeProfilePayload, S>

  type EmployeeProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeProfileCountAggregateInputType | true
    }

  export interface EmployeeProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeProfile'], meta: { name: 'EmployeeProfile' } }
    /**
     * Find zero or one EmployeeProfile that matches the filter.
     * @param {EmployeeProfileFindUniqueArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeProfileFindUniqueArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeProfileFindUniqueOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeProfileFindFirstArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany()
     * 
     * // Get first 10 EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeProfileWithIdOnly = await prisma.employeeProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeProfileFindManyArgs>(args?: SelectSubset<T, EmployeeProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeProfile.
     * @param {EmployeeProfileCreateArgs} args - Arguments to create a EmployeeProfile.
     * @example
     * // Create one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.create({
     *   data: {
     *     // ... data to create a EmployeeProfile
     *   }
     * })
     * 
     */
    create<T extends EmployeeProfileCreateArgs>(args: SelectSubset<T, EmployeeProfileCreateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeProfiles.
     * @param {EmployeeProfileCreateManyArgs} args - Arguments to create many EmployeeProfiles.
     * @example
     * // Create many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeProfileCreateManyArgs>(args?: SelectSubset<T, EmployeeProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeProfile.
     * @param {EmployeeProfileDeleteArgs} args - Arguments to delete one EmployeeProfile.
     * @example
     * // Delete one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.delete({
     *   where: {
     *     // ... filter to delete one EmployeeProfile
     *   }
     * })
     * 
     */
    delete<T extends EmployeeProfileDeleteArgs>(args: SelectSubset<T, EmployeeProfileDeleteArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeProfile.
     * @param {EmployeeProfileUpdateArgs} args - Arguments to update one EmployeeProfile.
     * @example
     * // Update one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeProfileUpdateArgs>(args: SelectSubset<T, EmployeeProfileUpdateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeProfiles.
     * @param {EmployeeProfileDeleteManyArgs} args - Arguments to filter EmployeeProfiles to delete.
     * @example
     * // Delete a few EmployeeProfiles
     * const { count } = await prisma.employeeProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeProfileDeleteManyArgs>(args?: SelectSubset<T, EmployeeProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeProfileUpdateManyArgs>(args: SelectSubset<T, EmployeeProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeProfile.
     * @param {EmployeeProfileUpsertArgs} args - Arguments to update or create a EmployeeProfile.
     * @example
     * // Update or create a EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.upsert({
     *   create: {
     *     // ... data to create a EmployeeProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeProfile we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeProfileUpsertArgs>(args: SelectSubset<T, EmployeeProfileUpsertArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileCountArgs} args - Arguments to filter EmployeeProfiles to count.
     * @example
     * // Count the number of EmployeeProfiles
     * const count = await prisma.employeeProfile.count({
     *   where: {
     *     // ... the filter for the EmployeeProfiles we want to count
     *   }
     * })
    **/
    count<T extends EmployeeProfileCountArgs>(
      args?: Subset<T, EmployeeProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeProfileAggregateArgs>(args: Subset<T, EmployeeProfileAggregateArgs>): Prisma.PrismaPromise<GetEmployeeProfileAggregateType<T>>

    /**
     * Group by EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeProfileGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeProfile model
   */
  readonly fields: EmployeeProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeProfile model
   */
  interface EmployeeProfileFieldRefs {
    readonly id: FieldRef<"EmployeeProfile", 'Int'>
    readonly employeeId: FieldRef<"EmployeeProfile", 'String'>
    readonly fatherName: FieldRef<"EmployeeProfile", 'String'>
    readonly motherName: FieldRef<"EmployeeProfile", 'String'>
    readonly officeContactNo: FieldRef<"EmployeeProfile", 'String'>
    readonly currentAddress: FieldRef<"EmployeeProfile", 'String'>
    readonly permanentAddress: FieldRef<"EmployeeProfile", 'String'>
    readonly nid: FieldRef<"EmployeeProfile", 'String'>
    readonly dob: FieldRef<"EmployeeProfile", 'DateTime'>
    readonly contactNo: FieldRef<"EmployeeProfile", 'String'>
    readonly emergencyContactNo: FieldRef<"EmployeeProfile", 'String'>
    readonly createdAt: FieldRef<"EmployeeProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeProfile findUnique
   */
  export type EmployeeProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findUniqueOrThrow
   */
  export type EmployeeProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findFirst
   */
  export type EmployeeProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findFirstOrThrow
   */
  export type EmployeeProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findMany
   */
  export type EmployeeProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfiles to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile create
   */
  export type EmployeeProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeProfile.
     */
    data: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
  }

  /**
   * EmployeeProfile createMany
   */
  export type EmployeeProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeProfiles.
     */
    data: EmployeeProfileCreateManyInput | EmployeeProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeProfile update
   */
  export type EmployeeProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeProfile.
     */
    data: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
    /**
     * Choose, which EmployeeProfile to update.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile updateMany
   */
  export type EmployeeProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeProfiles.
     */
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeProfiles to update
     */
    where?: EmployeeProfileWhereInput
    /**
     * Limit how many EmployeeProfiles to update.
     */
    limit?: number
  }

  /**
   * EmployeeProfile upsert
   */
  export type EmployeeProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeProfile to update in case it exists.
     */
    where: EmployeeProfileWhereUniqueInput
    /**
     * In case the EmployeeProfile found by the `where` argument doesn't exist, create a new EmployeeProfile with this data.
     */
    create: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
    /**
     * In case the EmployeeProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
  }

  /**
   * EmployeeProfile delete
   */
  export type EmployeeProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter which EmployeeProfile to delete.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile deleteMany
   */
  export type EmployeeProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfiles to delete
     */
    where?: EmployeeProfileWhereInput
    /**
     * Limit how many EmployeeProfiles to delete.
     */
    limit?: number
  }

  /**
   * EmployeeProfile without action
   */
  export type EmployeeProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
  }


  /**
   * Model JobPost
   */

  export type AggregateJobPost = {
    _count: JobPostCountAggregateOutputType | null
    _avg: JobPostAvgAggregateOutputType | null
    _sum: JobPostSumAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  export type JobPostAvgAggregateOutputType = {
    id: number | null
    depoId: number | null
  }

  export type JobPostSumAggregateOutputType = {
    id: number | null
    depoId: number | null
  }

  export type JobPostMinAggregateOutputType = {
    id: number | null
    depoId: number | null
    postName: string | null
    qualification: string | null
    responsibility: string | null
    isDelete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobPostMaxAggregateOutputType = {
    id: number | null
    depoId: number | null
    postName: string | null
    qualification: string | null
    responsibility: string | null
    isDelete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobPostCountAggregateOutputType = {
    id: number
    depoId: number
    postName: number
    qualification: number
    responsibility: number
    isDelete: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobPostAvgAggregateInputType = {
    id?: true
    depoId?: true
  }

  export type JobPostSumAggregateInputType = {
    id?: true
    depoId?: true
  }

  export type JobPostMinAggregateInputType = {
    id?: true
    depoId?: true
    postName?: true
    qualification?: true
    responsibility?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobPostMaxAggregateInputType = {
    id?: true
    depoId?: true
    postName?: true
    qualification?: true
    responsibility?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobPostCountAggregateInputType = {
    id?: true
    depoId?: true
    postName?: true
    qualification?: true
    responsibility?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPost to aggregate.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPosts
    **/
    _count?: true | JobPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostMaxAggregateInputType
  }

  export type GetJobPostAggregateType<T extends JobPostAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPost[P]>
      : GetScalarType<T[P], AggregateJobPost[P]>
  }




  export type JobPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithAggregationInput | JobPostOrderByWithAggregationInput[]
    by: JobPostScalarFieldEnum[] | JobPostScalarFieldEnum
    having?: JobPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostCountAggregateInputType | true
    _avg?: JobPostAvgAggregateInputType
    _sum?: JobPostSumAggregateInputType
    _min?: JobPostMinAggregateInputType
    _max?: JobPostMaxAggregateInputType
  }

  export type JobPostGroupByOutputType = {
    id: number
    depoId: number
    postName: string
    qualification: string
    responsibility: string
    isDelete: boolean
    createdAt: Date
    updatedAt: Date
    _count: JobPostCountAggregateOutputType | null
    _avg: JobPostAvgAggregateOutputType | null
    _sum: JobPostSumAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  type GetJobPostGroupByPayload<T extends JobPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostGroupByOutputType[P]>
        }
      >
    >


  export type JobPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    depoId?: boolean
    postName?: boolean
    qualification?: boolean
    responsibility?: boolean
    isDelete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    depo?: boolean | DepoDefaultArgs<ExtArgs>
    scope?: boolean | JobPost$scopeArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPost"]>



  export type JobPostSelectScalar = {
    id?: boolean
    depoId?: boolean
    postName?: boolean
    qualification?: boolean
    responsibility?: boolean
    isDelete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "depoId" | "postName" | "qualification" | "responsibility" | "isDelete" | "createdAt" | "updatedAt", ExtArgs["result"]["jobPost"]>
  export type JobPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    depo?: boolean | DepoDefaultArgs<ExtArgs>
    scope?: boolean | JobPost$scopeArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPost"
    objects: {
      depo: Prisma.$DepoPayload<ExtArgs>
      scope: Prisma.$ScopePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      depoId: number
      postName: string
      qualification: string
      responsibility: string
      isDelete: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobPost"]>
    composites: {}
  }

  type JobPostGetPayload<S extends boolean | null | undefined | JobPostDefaultArgs> = $Result.GetResult<Prisma.$JobPostPayload, S>

  type JobPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostCountAggregateInputType | true
    }

  export interface JobPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPost'], meta: { name: 'JobPost' } }
    /**
     * Find zero or one JobPost that matches the filter.
     * @param {JobPostFindUniqueArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostFindUniqueArgs>(args: SelectSubset<T, JobPostFindUniqueArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostFindUniqueOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostFindFirstArgs>(args?: SelectSubset<T, JobPostFindFirstArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPosts
     * const jobPosts = await prisma.jobPost.findMany()
     * 
     * // Get first 10 JobPosts
     * const jobPosts = await prisma.jobPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostWithIdOnly = await prisma.jobPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostFindManyArgs>(args?: SelectSubset<T, JobPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPost.
     * @param {JobPostCreateArgs} args - Arguments to create a JobPost.
     * @example
     * // Create one JobPost
     * const JobPost = await prisma.jobPost.create({
     *   data: {
     *     // ... data to create a JobPost
     *   }
     * })
     * 
     */
    create<T extends JobPostCreateArgs>(args: SelectSubset<T, JobPostCreateArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPosts.
     * @param {JobPostCreateManyArgs} args - Arguments to create many JobPosts.
     * @example
     * // Create many JobPosts
     * const jobPost = await prisma.jobPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostCreateManyArgs>(args?: SelectSubset<T, JobPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobPost.
     * @param {JobPostDeleteArgs} args - Arguments to delete one JobPost.
     * @example
     * // Delete one JobPost
     * const JobPost = await prisma.jobPost.delete({
     *   where: {
     *     // ... filter to delete one JobPost
     *   }
     * })
     * 
     */
    delete<T extends JobPostDeleteArgs>(args: SelectSubset<T, JobPostDeleteArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPost.
     * @param {JobPostUpdateArgs} args - Arguments to update one JobPost.
     * @example
     * // Update one JobPost
     * const jobPost = await prisma.jobPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostUpdateArgs>(args: SelectSubset<T, JobPostUpdateArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPosts.
     * @param {JobPostDeleteManyArgs} args - Arguments to filter JobPosts to delete.
     * @example
     * // Delete a few JobPosts
     * const { count } = await prisma.jobPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostDeleteManyArgs>(args?: SelectSubset<T, JobPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPosts
     * const jobPost = await prisma.jobPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostUpdateManyArgs>(args: SelectSubset<T, JobPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobPost.
     * @param {JobPostUpsertArgs} args - Arguments to update or create a JobPost.
     * @example
     * // Update or create a JobPost
     * const jobPost = await prisma.jobPost.upsert({
     *   create: {
     *     // ... data to create a JobPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPost we want to update
     *   }
     * })
     */
    upsert<T extends JobPostUpsertArgs>(args: SelectSubset<T, JobPostUpsertArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostCountArgs} args - Arguments to filter JobPosts to count.
     * @example
     * // Count the number of JobPosts
     * const count = await prisma.jobPost.count({
     *   where: {
     *     // ... the filter for the JobPosts we want to count
     *   }
     * })
    **/
    count<T extends JobPostCountArgs>(
      args?: Subset<T, JobPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostAggregateArgs>(args: Subset<T, JobPostAggregateArgs>): Prisma.PrismaPromise<GetJobPostAggregateType<T>>

    /**
     * Group by JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostGroupByArgs['orderBy'] }
        : { orderBy?: JobPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPost model
   */
  readonly fields: JobPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    depo<T extends DepoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepoDefaultArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scope<T extends JobPost$scopeArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$scopeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPost model
   */
  interface JobPostFieldRefs {
    readonly id: FieldRef<"JobPost", 'Int'>
    readonly depoId: FieldRef<"JobPost", 'Int'>
    readonly postName: FieldRef<"JobPost", 'String'>
    readonly qualification: FieldRef<"JobPost", 'String'>
    readonly responsibility: FieldRef<"JobPost", 'String'>
    readonly isDelete: FieldRef<"JobPost", 'Boolean'>
    readonly createdAt: FieldRef<"JobPost", 'DateTime'>
    readonly updatedAt: FieldRef<"JobPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobPost findUnique
   */
  export type JobPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost findUniqueOrThrow
   */
  export type JobPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost findFirst
   */
  export type JobPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost findFirstOrThrow
   */
  export type JobPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost findMany
   */
  export type JobPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPosts to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost create
   */
  export type JobPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPost.
     */
    data: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
  }

  /**
   * JobPost createMany
   */
  export type JobPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPosts.
     */
    data: JobPostCreateManyInput | JobPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPost update
   */
  export type JobPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPost.
     */
    data: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
    /**
     * Choose, which JobPost to update.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost updateMany
   */
  export type JobPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPosts.
     */
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyInput>
    /**
     * Filter which JobPosts to update
     */
    where?: JobPostWhereInput
    /**
     * Limit how many JobPosts to update.
     */
    limit?: number
  }

  /**
   * JobPost upsert
   */
  export type JobPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPost to update in case it exists.
     */
    where: JobPostWhereUniqueInput
    /**
     * In case the JobPost found by the `where` argument doesn't exist, create a new JobPost with this data.
     */
    create: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
    /**
     * In case the JobPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
  }

  /**
   * JobPost delete
   */
  export type JobPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter which JobPost to delete.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost deleteMany
   */
  export type JobPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPosts to delete
     */
    where?: JobPostWhereInput
    /**
     * Limit how many JobPosts to delete.
     */
    limit?: number
  }

  /**
   * JobPost.scope
   */
  export type JobPost$scopeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    where?: ScopeWhereInput
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    cursor?: ScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScopeScalarFieldEnum | ScopeScalarFieldEnum[]
  }

  /**
   * JobPost without action
   */
  export type JobPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
  }


  /**
   * Model Chemist
   */

  export type AggregateChemist = {
    _count: ChemistCountAggregateOutputType | null
    _avg: ChemistAvgAggregateOutputType | null
    _sum: ChemistSumAggregateOutputType | null
    _min: ChemistMinAggregateOutputType | null
    _max: ChemistMaxAggregateOutputType | null
  }

  export type ChemistAvgAggregateOutputType = {
    id: number | null
    depoId: number | null
    discountRate: number | null
    openingDueAmount: number | null
  }

  export type ChemistSumAggregateOutputType = {
    id: number | null
    depoId: number | null
    discountRate: number | null
    openingDueAmount: number | null
  }

  export type ChemistMinAggregateOutputType = {
    id: number | null
    chemistId: string | null
    depoId: number | null
    pharmacyName: string | null
    contactPerson: string | null
    contactNo: string | null
    address: string | null
    photo: string | null
    discountRate: number | null
    openingDueAmount: number | null
    openingDate: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChemistMaxAggregateOutputType = {
    id: number | null
    chemistId: string | null
    depoId: number | null
    pharmacyName: string | null
    contactPerson: string | null
    contactNo: string | null
    address: string | null
    photo: string | null
    discountRate: number | null
    openingDueAmount: number | null
    openingDate: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChemistCountAggregateOutputType = {
    id: number
    chemistId: number
    depoId: number
    pharmacyName: number
    contactPerson: number
    contactNo: number
    address: number
    photo: number
    discountRate: number
    openingDueAmount: number
    openingDate: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChemistAvgAggregateInputType = {
    id?: true
    depoId?: true
    discountRate?: true
    openingDueAmount?: true
  }

  export type ChemistSumAggregateInputType = {
    id?: true
    depoId?: true
    discountRate?: true
    openingDueAmount?: true
  }

  export type ChemistMinAggregateInputType = {
    id?: true
    chemistId?: true
    depoId?: true
    pharmacyName?: true
    contactPerson?: true
    contactNo?: true
    address?: true
    photo?: true
    discountRate?: true
    openingDueAmount?: true
    openingDate?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChemistMaxAggregateInputType = {
    id?: true
    chemistId?: true
    depoId?: true
    pharmacyName?: true
    contactPerson?: true
    contactNo?: true
    address?: true
    photo?: true
    discountRate?: true
    openingDueAmount?: true
    openingDate?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChemistCountAggregateInputType = {
    id?: true
    chemistId?: true
    depoId?: true
    pharmacyName?: true
    contactPerson?: true
    contactNo?: true
    address?: true
    photo?: true
    discountRate?: true
    openingDueAmount?: true
    openingDate?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChemistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chemist to aggregate.
     */
    where?: ChemistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chemists to fetch.
     */
    orderBy?: ChemistOrderByWithRelationInput | ChemistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChemistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chemists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chemists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chemists
    **/
    _count?: true | ChemistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChemistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChemistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChemistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChemistMaxAggregateInputType
  }

  export type GetChemistAggregateType<T extends ChemistAggregateArgs> = {
        [P in keyof T & keyof AggregateChemist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChemist[P]>
      : GetScalarType<T[P], AggregateChemist[P]>
  }




  export type ChemistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChemistWhereInput
    orderBy?: ChemistOrderByWithAggregationInput | ChemistOrderByWithAggregationInput[]
    by: ChemistScalarFieldEnum[] | ChemistScalarFieldEnum
    having?: ChemistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChemistCountAggregateInputType | true
    _avg?: ChemistAvgAggregateInputType
    _sum?: ChemistSumAggregateInputType
    _min?: ChemistMinAggregateInputType
    _max?: ChemistMaxAggregateInputType
  }

  export type ChemistGroupByOutputType = {
    id: number
    chemistId: string
    depoId: number
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo: string | null
    discountRate: number | null
    openingDueAmount: number | null
    openingDate: Date
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChemistCountAggregateOutputType | null
    _avg: ChemistAvgAggregateOutputType | null
    _sum: ChemistSumAggregateOutputType | null
    _min: ChemistMinAggregateOutputType | null
    _max: ChemistMaxAggregateOutputType | null
  }

  type GetChemistGroupByPayload<T extends ChemistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChemistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChemistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChemistGroupByOutputType[P]>
            : GetScalarType<T[P], ChemistGroupByOutputType[P]>
        }
      >
    >


  export type ChemistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chemistId?: boolean
    depoId?: boolean
    pharmacyName?: boolean
    contactPerson?: boolean
    contactNo?: boolean
    address?: boolean
    photo?: boolean
    discountRate?: boolean
    openingDueAmount?: boolean
    openingDate?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    depo?: boolean | DepoDefaultArgs<ExtArgs>
    scopes?: boolean | Chemist$scopesArgs<ExtArgs>
    FixedJournal?: boolean | Chemist$FixedJournalArgs<ExtArgs>
    order?: boolean | Chemist$orderArgs<ExtArgs>
    transactionInfo?: boolean | Chemist$transactionInfoArgs<ExtArgs>
    _count?: boolean | ChemistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chemist"]>



  export type ChemistSelectScalar = {
    id?: boolean
    chemistId?: boolean
    depoId?: boolean
    pharmacyName?: boolean
    contactPerson?: boolean
    contactNo?: boolean
    address?: boolean
    photo?: boolean
    discountRate?: boolean
    openingDueAmount?: boolean
    openingDate?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChemistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chemistId" | "depoId" | "pharmacyName" | "contactPerson" | "contactNo" | "address" | "photo" | "discountRate" | "openingDueAmount" | "openingDate" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["chemist"]>
  export type ChemistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    depo?: boolean | DepoDefaultArgs<ExtArgs>
    scopes?: boolean | Chemist$scopesArgs<ExtArgs>
    FixedJournal?: boolean | Chemist$FixedJournalArgs<ExtArgs>
    order?: boolean | Chemist$orderArgs<ExtArgs>
    transactionInfo?: boolean | Chemist$transactionInfoArgs<ExtArgs>
    _count?: boolean | ChemistCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChemistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chemist"
    objects: {
      depo: Prisma.$DepoPayload<ExtArgs>
      scopes: Prisma.$ScopePayload<ExtArgs>[]
      FixedJournal: Prisma.$FixedJournalPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs>[]
      transactionInfo: Prisma.$TransactionInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chemistId: string
      depoId: number
      pharmacyName: string
      contactPerson: string
      contactNo: string
      address: string
      photo: string | null
      discountRate: number | null
      openingDueAmount: number | null
      openingDate: Date
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chemist"]>
    composites: {}
  }

  type ChemistGetPayload<S extends boolean | null | undefined | ChemistDefaultArgs> = $Result.GetResult<Prisma.$ChemistPayload, S>

  type ChemistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChemistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChemistCountAggregateInputType | true
    }

  export interface ChemistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chemist'], meta: { name: 'Chemist' } }
    /**
     * Find zero or one Chemist that matches the filter.
     * @param {ChemistFindUniqueArgs} args - Arguments to find a Chemist
     * @example
     * // Get one Chemist
     * const chemist = await prisma.chemist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChemistFindUniqueArgs>(args: SelectSubset<T, ChemistFindUniqueArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chemist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChemistFindUniqueOrThrowArgs} args - Arguments to find a Chemist
     * @example
     * // Get one Chemist
     * const chemist = await prisma.chemist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChemistFindUniqueOrThrowArgs>(args: SelectSubset<T, ChemistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chemist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemistFindFirstArgs} args - Arguments to find a Chemist
     * @example
     * // Get one Chemist
     * const chemist = await prisma.chemist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChemistFindFirstArgs>(args?: SelectSubset<T, ChemistFindFirstArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chemist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemistFindFirstOrThrowArgs} args - Arguments to find a Chemist
     * @example
     * // Get one Chemist
     * const chemist = await prisma.chemist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChemistFindFirstOrThrowArgs>(args?: SelectSubset<T, ChemistFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chemists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chemists
     * const chemists = await prisma.chemist.findMany()
     * 
     * // Get first 10 Chemists
     * const chemists = await prisma.chemist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chemistWithIdOnly = await prisma.chemist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChemistFindManyArgs>(args?: SelectSubset<T, ChemistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chemist.
     * @param {ChemistCreateArgs} args - Arguments to create a Chemist.
     * @example
     * // Create one Chemist
     * const Chemist = await prisma.chemist.create({
     *   data: {
     *     // ... data to create a Chemist
     *   }
     * })
     * 
     */
    create<T extends ChemistCreateArgs>(args: SelectSubset<T, ChemistCreateArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chemists.
     * @param {ChemistCreateManyArgs} args - Arguments to create many Chemists.
     * @example
     * // Create many Chemists
     * const chemist = await prisma.chemist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChemistCreateManyArgs>(args?: SelectSubset<T, ChemistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chemist.
     * @param {ChemistDeleteArgs} args - Arguments to delete one Chemist.
     * @example
     * // Delete one Chemist
     * const Chemist = await prisma.chemist.delete({
     *   where: {
     *     // ... filter to delete one Chemist
     *   }
     * })
     * 
     */
    delete<T extends ChemistDeleteArgs>(args: SelectSubset<T, ChemistDeleteArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chemist.
     * @param {ChemistUpdateArgs} args - Arguments to update one Chemist.
     * @example
     * // Update one Chemist
     * const chemist = await prisma.chemist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChemistUpdateArgs>(args: SelectSubset<T, ChemistUpdateArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chemists.
     * @param {ChemistDeleteManyArgs} args - Arguments to filter Chemists to delete.
     * @example
     * // Delete a few Chemists
     * const { count } = await prisma.chemist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChemistDeleteManyArgs>(args?: SelectSubset<T, ChemistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chemists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chemists
     * const chemist = await prisma.chemist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChemistUpdateManyArgs>(args: SelectSubset<T, ChemistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chemist.
     * @param {ChemistUpsertArgs} args - Arguments to update or create a Chemist.
     * @example
     * // Update or create a Chemist
     * const chemist = await prisma.chemist.upsert({
     *   create: {
     *     // ... data to create a Chemist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chemist we want to update
     *   }
     * })
     */
    upsert<T extends ChemistUpsertArgs>(args: SelectSubset<T, ChemistUpsertArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chemists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemistCountArgs} args - Arguments to filter Chemists to count.
     * @example
     * // Count the number of Chemists
     * const count = await prisma.chemist.count({
     *   where: {
     *     // ... the filter for the Chemists we want to count
     *   }
     * })
    **/
    count<T extends ChemistCountArgs>(
      args?: Subset<T, ChemistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChemistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chemist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChemistAggregateArgs>(args: Subset<T, ChemistAggregateArgs>): Prisma.PrismaPromise<GetChemistAggregateType<T>>

    /**
     * Group by Chemist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChemistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChemistGroupByArgs['orderBy'] }
        : { orderBy?: ChemistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChemistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChemistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chemist model
   */
  readonly fields: ChemistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chemist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChemistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    depo<T extends DepoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepoDefaultArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scopes<T extends Chemist$scopesArgs<ExtArgs> = {}>(args?: Subset<T, Chemist$scopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FixedJournal<T extends Chemist$FixedJournalArgs<ExtArgs> = {}>(args?: Subset<T, Chemist$FixedJournalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order<T extends Chemist$orderArgs<ExtArgs> = {}>(args?: Subset<T, Chemist$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionInfo<T extends Chemist$transactionInfoArgs<ExtArgs> = {}>(args?: Subset<T, Chemist$transactionInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chemist model
   */
  interface ChemistFieldRefs {
    readonly id: FieldRef<"Chemist", 'Int'>
    readonly chemistId: FieldRef<"Chemist", 'String'>
    readonly depoId: FieldRef<"Chemist", 'Int'>
    readonly pharmacyName: FieldRef<"Chemist", 'String'>
    readonly contactPerson: FieldRef<"Chemist", 'String'>
    readonly contactNo: FieldRef<"Chemist", 'String'>
    readonly address: FieldRef<"Chemist", 'String'>
    readonly photo: FieldRef<"Chemist", 'String'>
    readonly discountRate: FieldRef<"Chemist", 'Int'>
    readonly openingDueAmount: FieldRef<"Chemist", 'Float'>
    readonly openingDate: FieldRef<"Chemist", 'DateTime'>
    readonly isDeleted: FieldRef<"Chemist", 'Boolean'>
    readonly createdAt: FieldRef<"Chemist", 'DateTime'>
    readonly updatedAt: FieldRef<"Chemist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chemist findUnique
   */
  export type ChemistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * Filter, which Chemist to fetch.
     */
    where: ChemistWhereUniqueInput
  }

  /**
   * Chemist findUniqueOrThrow
   */
  export type ChemistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * Filter, which Chemist to fetch.
     */
    where: ChemistWhereUniqueInput
  }

  /**
   * Chemist findFirst
   */
  export type ChemistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * Filter, which Chemist to fetch.
     */
    where?: ChemistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chemists to fetch.
     */
    orderBy?: ChemistOrderByWithRelationInput | ChemistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chemists.
     */
    cursor?: ChemistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chemists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chemists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chemists.
     */
    distinct?: ChemistScalarFieldEnum | ChemistScalarFieldEnum[]
  }

  /**
   * Chemist findFirstOrThrow
   */
  export type ChemistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * Filter, which Chemist to fetch.
     */
    where?: ChemistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chemists to fetch.
     */
    orderBy?: ChemistOrderByWithRelationInput | ChemistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chemists.
     */
    cursor?: ChemistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chemists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chemists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chemists.
     */
    distinct?: ChemistScalarFieldEnum | ChemistScalarFieldEnum[]
  }

  /**
   * Chemist findMany
   */
  export type ChemistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * Filter, which Chemists to fetch.
     */
    where?: ChemistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chemists to fetch.
     */
    orderBy?: ChemistOrderByWithRelationInput | ChemistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chemists.
     */
    cursor?: ChemistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chemists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chemists.
     */
    skip?: number
    distinct?: ChemistScalarFieldEnum | ChemistScalarFieldEnum[]
  }

  /**
   * Chemist create
   */
  export type ChemistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * The data needed to create a Chemist.
     */
    data: XOR<ChemistCreateInput, ChemistUncheckedCreateInput>
  }

  /**
   * Chemist createMany
   */
  export type ChemistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chemists.
     */
    data: ChemistCreateManyInput | ChemistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chemist update
   */
  export type ChemistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * The data needed to update a Chemist.
     */
    data: XOR<ChemistUpdateInput, ChemistUncheckedUpdateInput>
    /**
     * Choose, which Chemist to update.
     */
    where: ChemistWhereUniqueInput
  }

  /**
   * Chemist updateMany
   */
  export type ChemistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chemists.
     */
    data: XOR<ChemistUpdateManyMutationInput, ChemistUncheckedUpdateManyInput>
    /**
     * Filter which Chemists to update
     */
    where?: ChemistWhereInput
    /**
     * Limit how many Chemists to update.
     */
    limit?: number
  }

  /**
   * Chemist upsert
   */
  export type ChemistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * The filter to search for the Chemist to update in case it exists.
     */
    where: ChemistWhereUniqueInput
    /**
     * In case the Chemist found by the `where` argument doesn't exist, create a new Chemist with this data.
     */
    create: XOR<ChemistCreateInput, ChemistUncheckedCreateInput>
    /**
     * In case the Chemist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChemistUpdateInput, ChemistUncheckedUpdateInput>
  }

  /**
   * Chemist delete
   */
  export type ChemistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    /**
     * Filter which Chemist to delete.
     */
    where: ChemistWhereUniqueInput
  }

  /**
   * Chemist deleteMany
   */
  export type ChemistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chemists to delete
     */
    where?: ChemistWhereInput
    /**
     * Limit how many Chemists to delete.
     */
    limit?: number
  }

  /**
   * Chemist.scopes
   */
  export type Chemist$scopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    where?: ScopeWhereInput
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    cursor?: ScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScopeScalarFieldEnum | ScopeScalarFieldEnum[]
  }

  /**
   * Chemist.FixedJournal
   */
  export type Chemist$FixedJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    where?: FixedJournalWhereInput
    orderBy?: FixedJournalOrderByWithRelationInput | FixedJournalOrderByWithRelationInput[]
    cursor?: FixedJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixedJournalScalarFieldEnum | FixedJournalScalarFieldEnum[]
  }

  /**
   * Chemist.order
   */
  export type Chemist$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Chemist.transactionInfo
   */
  export type Chemist$transactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    where?: TransactionInfoWhereInput
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    cursor?: TransactionInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * Chemist without action
   */
  export type ChemistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
  }


  /**
   * Model Depo
   */

  export type AggregateDepo = {
    _count: DepoCountAggregateOutputType | null
    _avg: DepoAvgAggregateOutputType | null
    _sum: DepoSumAggregateOutputType | null
    _min: DepoMinAggregateOutputType | null
    _max: DepoMaxAggregateOutputType | null
  }

  export type DepoAvgAggregateOutputType = {
    id: number | null
    scopeId: number | null
  }

  export type DepoSumAggregateOutputType = {
    id: number | null
    scopeId: number | null
  }

  export type DepoMinAggregateOutputType = {
    id: number | null
    depoName: string | null
    location: string | null
    scopeId: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepoMaxAggregateOutputType = {
    id: number | null
    depoName: string | null
    location: string | null
    scopeId: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepoCountAggregateOutputType = {
    id: number
    depoName: number
    location: number
    scopeId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepoAvgAggregateInputType = {
    id?: true
    scopeId?: true
  }

  export type DepoSumAggregateInputType = {
    id?: true
    scopeId?: true
  }

  export type DepoMinAggregateInputType = {
    id?: true
    depoName?: true
    location?: true
    scopeId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepoMaxAggregateInputType = {
    id?: true
    depoName?: true
    location?: true
    scopeId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepoCountAggregateInputType = {
    id?: true
    depoName?: true
    location?: true
    scopeId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depo to aggregate.
     */
    where?: DepoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depos to fetch.
     */
    orderBy?: DepoOrderByWithRelationInput | DepoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Depos
    **/
    _count?: true | DepoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepoMaxAggregateInputType
  }

  export type GetDepoAggregateType<T extends DepoAggregateArgs> = {
        [P in keyof T & keyof AggregateDepo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepo[P]>
      : GetScalarType<T[P], AggregateDepo[P]>
  }




  export type DepoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepoWhereInput
    orderBy?: DepoOrderByWithAggregationInput | DepoOrderByWithAggregationInput[]
    by: DepoScalarFieldEnum[] | DepoScalarFieldEnum
    having?: DepoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepoCountAggregateInputType | true
    _avg?: DepoAvgAggregateInputType
    _sum?: DepoSumAggregateInputType
    _min?: DepoMinAggregateInputType
    _max?: DepoMaxAggregateInputType
  }

  export type DepoGroupByOutputType = {
    id: number
    depoName: string
    location: string
    scopeId: number | null
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: DepoCountAggregateOutputType | null
    _avg: DepoAvgAggregateOutputType | null
    _sum: DepoSumAggregateOutputType | null
    _min: DepoMinAggregateOutputType | null
    _max: DepoMaxAggregateOutputType | null
  }

  type GetDepoGroupByPayload<T extends DepoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepoGroupByOutputType[P]>
            : GetScalarType<T[P], DepoGroupByOutputType[P]>
        }
      >
    >


  export type DepoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    depoName?: boolean
    location?: boolean
    scopeId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chemist?: boolean | Depo$chemistArgs<ExtArgs>
    FixedJournal?: boolean | Depo$FixedJournalArgs<ExtArgs>
    inventory?: boolean | Depo$inventoryArgs<ExtArgs>
    jobPost?: boolean | Depo$jobPostArgs<ExtArgs>
    journal?: boolean | Depo$journalArgs<ExtArgs>
    scopes?: boolean | Depo$scopesArgs<ExtArgs>
    _count?: boolean | DepoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["depo"]>



  export type DepoSelectScalar = {
    id?: boolean
    depoName?: boolean
    location?: boolean
    scopeId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "depoName" | "location" | "scopeId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["depo"]>
  export type DepoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chemist?: boolean | Depo$chemistArgs<ExtArgs>
    FixedJournal?: boolean | Depo$FixedJournalArgs<ExtArgs>
    inventory?: boolean | Depo$inventoryArgs<ExtArgs>
    jobPost?: boolean | Depo$jobPostArgs<ExtArgs>
    journal?: boolean | Depo$journalArgs<ExtArgs>
    scopes?: boolean | Depo$scopesArgs<ExtArgs>
    _count?: boolean | DepoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Depo"
    objects: {
      chemist: Prisma.$ChemistPayload<ExtArgs>[]
      FixedJournal: Prisma.$FixedJournalPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      jobPost: Prisma.$JobPostPayload<ExtArgs>[]
      journal: Prisma.$JournalPayload<ExtArgs>[]
      scopes: Prisma.$ScopePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      depoName: string
      location: string
      scopeId: number | null
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["depo"]>
    composites: {}
  }

  type DepoGetPayload<S extends boolean | null | undefined | DepoDefaultArgs> = $Result.GetResult<Prisma.$DepoPayload, S>

  type DepoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepoCountAggregateInputType | true
    }

  export interface DepoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Depo'], meta: { name: 'Depo' } }
    /**
     * Find zero or one Depo that matches the filter.
     * @param {DepoFindUniqueArgs} args - Arguments to find a Depo
     * @example
     * // Get one Depo
     * const depo = await prisma.depo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepoFindUniqueArgs>(args: SelectSubset<T, DepoFindUniqueArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Depo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepoFindUniqueOrThrowArgs} args - Arguments to find a Depo
     * @example
     * // Get one Depo
     * const depo = await prisma.depo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepoFindUniqueOrThrowArgs>(args: SelectSubset<T, DepoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Depo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepoFindFirstArgs} args - Arguments to find a Depo
     * @example
     * // Get one Depo
     * const depo = await prisma.depo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepoFindFirstArgs>(args?: SelectSubset<T, DepoFindFirstArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Depo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepoFindFirstOrThrowArgs} args - Arguments to find a Depo
     * @example
     * // Get one Depo
     * const depo = await prisma.depo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepoFindFirstOrThrowArgs>(args?: SelectSubset<T, DepoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Depos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Depos
     * const depos = await prisma.depo.findMany()
     * 
     * // Get first 10 Depos
     * const depos = await prisma.depo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depoWithIdOnly = await prisma.depo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepoFindManyArgs>(args?: SelectSubset<T, DepoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Depo.
     * @param {DepoCreateArgs} args - Arguments to create a Depo.
     * @example
     * // Create one Depo
     * const Depo = await prisma.depo.create({
     *   data: {
     *     // ... data to create a Depo
     *   }
     * })
     * 
     */
    create<T extends DepoCreateArgs>(args: SelectSubset<T, DepoCreateArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Depos.
     * @param {DepoCreateManyArgs} args - Arguments to create many Depos.
     * @example
     * // Create many Depos
     * const depo = await prisma.depo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepoCreateManyArgs>(args?: SelectSubset<T, DepoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Depo.
     * @param {DepoDeleteArgs} args - Arguments to delete one Depo.
     * @example
     * // Delete one Depo
     * const Depo = await prisma.depo.delete({
     *   where: {
     *     // ... filter to delete one Depo
     *   }
     * })
     * 
     */
    delete<T extends DepoDeleteArgs>(args: SelectSubset<T, DepoDeleteArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Depo.
     * @param {DepoUpdateArgs} args - Arguments to update one Depo.
     * @example
     * // Update one Depo
     * const depo = await prisma.depo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepoUpdateArgs>(args: SelectSubset<T, DepoUpdateArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Depos.
     * @param {DepoDeleteManyArgs} args - Arguments to filter Depos to delete.
     * @example
     * // Delete a few Depos
     * const { count } = await prisma.depo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepoDeleteManyArgs>(args?: SelectSubset<T, DepoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Depos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Depos
     * const depo = await prisma.depo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepoUpdateManyArgs>(args: SelectSubset<T, DepoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Depo.
     * @param {DepoUpsertArgs} args - Arguments to update or create a Depo.
     * @example
     * // Update or create a Depo
     * const depo = await prisma.depo.upsert({
     *   create: {
     *     // ... data to create a Depo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Depo we want to update
     *   }
     * })
     */
    upsert<T extends DepoUpsertArgs>(args: SelectSubset<T, DepoUpsertArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Depos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepoCountArgs} args - Arguments to filter Depos to count.
     * @example
     * // Count the number of Depos
     * const count = await prisma.depo.count({
     *   where: {
     *     // ... the filter for the Depos we want to count
     *   }
     * })
    **/
    count<T extends DepoCountArgs>(
      args?: Subset<T, DepoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Depo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepoAggregateArgs>(args: Subset<T, DepoAggregateArgs>): Prisma.PrismaPromise<GetDepoAggregateType<T>>

    /**
     * Group by Depo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepoGroupByArgs['orderBy'] }
        : { orderBy?: DepoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Depo model
   */
  readonly fields: DepoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Depo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chemist<T extends Depo$chemistArgs<ExtArgs> = {}>(args?: Subset<T, Depo$chemistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FixedJournal<T extends Depo$FixedJournalArgs<ExtArgs> = {}>(args?: Subset<T, Depo$FixedJournalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends Depo$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Depo$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobPost<T extends Depo$jobPostArgs<ExtArgs> = {}>(args?: Subset<T, Depo$jobPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journal<T extends Depo$journalArgs<ExtArgs> = {}>(args?: Subset<T, Depo$journalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scopes<T extends Depo$scopesArgs<ExtArgs> = {}>(args?: Subset<T, Depo$scopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Depo model
   */
  interface DepoFieldRefs {
    readonly id: FieldRef<"Depo", 'Int'>
    readonly depoName: FieldRef<"Depo", 'String'>
    readonly location: FieldRef<"Depo", 'String'>
    readonly scopeId: FieldRef<"Depo", 'Int'>
    readonly status: FieldRef<"Depo", 'Status'>
    readonly createdAt: FieldRef<"Depo", 'DateTime'>
    readonly updatedAt: FieldRef<"Depo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Depo findUnique
   */
  export type DepoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * Filter, which Depo to fetch.
     */
    where: DepoWhereUniqueInput
  }

  /**
   * Depo findUniqueOrThrow
   */
  export type DepoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * Filter, which Depo to fetch.
     */
    where: DepoWhereUniqueInput
  }

  /**
   * Depo findFirst
   */
  export type DepoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * Filter, which Depo to fetch.
     */
    where?: DepoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depos to fetch.
     */
    orderBy?: DepoOrderByWithRelationInput | DepoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depos.
     */
    cursor?: DepoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depos.
     */
    distinct?: DepoScalarFieldEnum | DepoScalarFieldEnum[]
  }

  /**
   * Depo findFirstOrThrow
   */
  export type DepoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * Filter, which Depo to fetch.
     */
    where?: DepoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depos to fetch.
     */
    orderBy?: DepoOrderByWithRelationInput | DepoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depos.
     */
    cursor?: DepoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depos.
     */
    distinct?: DepoScalarFieldEnum | DepoScalarFieldEnum[]
  }

  /**
   * Depo findMany
   */
  export type DepoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * Filter, which Depos to fetch.
     */
    where?: DepoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depos to fetch.
     */
    orderBy?: DepoOrderByWithRelationInput | DepoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Depos.
     */
    cursor?: DepoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depos.
     */
    skip?: number
    distinct?: DepoScalarFieldEnum | DepoScalarFieldEnum[]
  }

  /**
   * Depo create
   */
  export type DepoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * The data needed to create a Depo.
     */
    data: XOR<DepoCreateInput, DepoUncheckedCreateInput>
  }

  /**
   * Depo createMany
   */
  export type DepoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Depos.
     */
    data: DepoCreateManyInput | DepoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Depo update
   */
  export type DepoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * The data needed to update a Depo.
     */
    data: XOR<DepoUpdateInput, DepoUncheckedUpdateInput>
    /**
     * Choose, which Depo to update.
     */
    where: DepoWhereUniqueInput
  }

  /**
   * Depo updateMany
   */
  export type DepoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Depos.
     */
    data: XOR<DepoUpdateManyMutationInput, DepoUncheckedUpdateManyInput>
    /**
     * Filter which Depos to update
     */
    where?: DepoWhereInput
    /**
     * Limit how many Depos to update.
     */
    limit?: number
  }

  /**
   * Depo upsert
   */
  export type DepoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * The filter to search for the Depo to update in case it exists.
     */
    where: DepoWhereUniqueInput
    /**
     * In case the Depo found by the `where` argument doesn't exist, create a new Depo with this data.
     */
    create: XOR<DepoCreateInput, DepoUncheckedCreateInput>
    /**
     * In case the Depo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepoUpdateInput, DepoUncheckedUpdateInput>
  }

  /**
   * Depo delete
   */
  export type DepoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    /**
     * Filter which Depo to delete.
     */
    where: DepoWhereUniqueInput
  }

  /**
   * Depo deleteMany
   */
  export type DepoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depos to delete
     */
    where?: DepoWhereInput
    /**
     * Limit how many Depos to delete.
     */
    limit?: number
  }

  /**
   * Depo.chemist
   */
  export type Depo$chemistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    where?: ChemistWhereInput
    orderBy?: ChemistOrderByWithRelationInput | ChemistOrderByWithRelationInput[]
    cursor?: ChemistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChemistScalarFieldEnum | ChemistScalarFieldEnum[]
  }

  /**
   * Depo.FixedJournal
   */
  export type Depo$FixedJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    where?: FixedJournalWhereInput
    orderBy?: FixedJournalOrderByWithRelationInput | FixedJournalOrderByWithRelationInput[]
    cursor?: FixedJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixedJournalScalarFieldEnum | FixedJournalScalarFieldEnum[]
  }

  /**
   * Depo.inventory
   */
  export type Depo$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Depo.jobPost
   */
  export type Depo$jobPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    cursor?: JobPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * Depo.journal
   */
  export type Depo$journalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    cursor?: JournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Depo.scopes
   */
  export type Depo$scopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    where?: ScopeWhereInput
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    cursor?: ScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScopeScalarFieldEnum | ScopeScalarFieldEnum[]
  }

  /**
   * Depo without action
   */
  export type DepoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
  }


  /**
   * Model Party
   */

  export type AggregateParty = {
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  export type PartyAvgAggregateOutputType = {
    id: number | null
    openingAmount: number | null
  }

  export type PartySumAggregateOutputType = {
    id: number | null
    openingAmount: number | null
  }

  export type PartyMinAggregateOutputType = {
    id: number | null
    partyName: string | null
    contactNo: string | null
    address: string | null
    partytype: $Enums.PartyType | null
    openingAmount: number | null
    openingDate: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartyMaxAggregateOutputType = {
    id: number | null
    partyName: string | null
    contactNo: string | null
    address: string | null
    partytype: $Enums.PartyType | null
    openingAmount: number | null
    openingDate: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartyCountAggregateOutputType = {
    id: number
    partyName: number
    contactNo: number
    address: number
    partytype: number
    openingAmount: number
    openingDate: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartyAvgAggregateInputType = {
    id?: true
    openingAmount?: true
  }

  export type PartySumAggregateInputType = {
    id?: true
    openingAmount?: true
  }

  export type PartyMinAggregateInputType = {
    id?: true
    partyName?: true
    contactNo?: true
    address?: true
    partytype?: true
    openingAmount?: true
    openingDate?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartyMaxAggregateInputType = {
    id?: true
    partyName?: true
    contactNo?: true
    address?: true
    partytype?: true
    openingAmount?: true
    openingDate?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartyCountAggregateInputType = {
    id?: true
    partyName?: true
    contactNo?: true
    address?: true
    partytype?: true
    openingAmount?: true
    openingDate?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Party to aggregate.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parties
    **/
    _count?: true | PartyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartyMaxAggregateInputType
  }

  export type GetPartyAggregateType<T extends PartyAggregateArgs> = {
        [P in keyof T & keyof AggregateParty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParty[P]>
      : GetScalarType<T[P], AggregateParty[P]>
  }




  export type PartyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartyWhereInput
    orderBy?: PartyOrderByWithAggregationInput | PartyOrderByWithAggregationInput[]
    by: PartyScalarFieldEnum[] | PartyScalarFieldEnum
    having?: PartyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartyCountAggregateInputType | true
    _avg?: PartyAvgAggregateInputType
    _sum?: PartySumAggregateInputType
    _min?: PartyMinAggregateInputType
    _max?: PartyMaxAggregateInputType
  }

  export type PartyGroupByOutputType = {
    id: number
    partyName: string
    contactNo: string
    address: string
    partytype: $Enums.PartyType
    openingAmount: number | null
    openingDate: Date
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  type GetPartyGroupByPayload<T extends PartyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartyGroupByOutputType[P]>
            : GetScalarType<T[P], PartyGroupByOutputType[P]>
        }
      >
    >


  export type PartySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partyName?: boolean
    contactNo?: boolean
    address?: boolean
    partytype?: boolean
    openingAmount?: boolean
    openingDate?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionInfo?: boolean | Party$transactionInfoArgs<ExtArgs>
    _count?: boolean | PartyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["party"]>



  export type PartySelectScalar = {
    id?: boolean
    partyName?: boolean
    contactNo?: boolean
    address?: boolean
    partytype?: boolean
    openingAmount?: boolean
    openingDate?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partyName" | "contactNo" | "address" | "partytype" | "openingAmount" | "openingDate" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["party"]>
  export type PartyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionInfo?: boolean | Party$transactionInfoArgs<ExtArgs>
    _count?: boolean | PartyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PartyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Party"
    objects: {
      transactionInfo: Prisma.$TransactionInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      partyName: string
      contactNo: string
      address: string
      partytype: $Enums.PartyType
      openingAmount: number | null
      openingDate: Date
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["party"]>
    composites: {}
  }

  type PartyGetPayload<S extends boolean | null | undefined | PartyDefaultArgs> = $Result.GetResult<Prisma.$PartyPayload, S>

  type PartyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartyCountAggregateInputType | true
    }

  export interface PartyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Party'], meta: { name: 'Party' } }
    /**
     * Find zero or one Party that matches the filter.
     * @param {PartyFindUniqueArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartyFindUniqueArgs>(args: SelectSubset<T, PartyFindUniqueArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Party that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartyFindUniqueOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartyFindUniqueOrThrowArgs>(args: SelectSubset<T, PartyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Party that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindFirstArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartyFindFirstArgs>(args?: SelectSubset<T, PartyFindFirstArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Party that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindFirstOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartyFindFirstOrThrowArgs>(args?: SelectSubset<T, PartyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parties
     * const parties = await prisma.party.findMany()
     * 
     * // Get first 10 Parties
     * const parties = await prisma.party.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partyWithIdOnly = await prisma.party.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartyFindManyArgs>(args?: SelectSubset<T, PartyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Party.
     * @param {PartyCreateArgs} args - Arguments to create a Party.
     * @example
     * // Create one Party
     * const Party = await prisma.party.create({
     *   data: {
     *     // ... data to create a Party
     *   }
     * })
     * 
     */
    create<T extends PartyCreateArgs>(args: SelectSubset<T, PartyCreateArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parties.
     * @param {PartyCreateManyArgs} args - Arguments to create many Parties.
     * @example
     * // Create many Parties
     * const party = await prisma.party.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartyCreateManyArgs>(args?: SelectSubset<T, PartyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Party.
     * @param {PartyDeleteArgs} args - Arguments to delete one Party.
     * @example
     * // Delete one Party
     * const Party = await prisma.party.delete({
     *   where: {
     *     // ... filter to delete one Party
     *   }
     * })
     * 
     */
    delete<T extends PartyDeleteArgs>(args: SelectSubset<T, PartyDeleteArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Party.
     * @param {PartyUpdateArgs} args - Arguments to update one Party.
     * @example
     * // Update one Party
     * const party = await prisma.party.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartyUpdateArgs>(args: SelectSubset<T, PartyUpdateArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parties.
     * @param {PartyDeleteManyArgs} args - Arguments to filter Parties to delete.
     * @example
     * // Delete a few Parties
     * const { count } = await prisma.party.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartyDeleteManyArgs>(args?: SelectSubset<T, PartyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parties
     * const party = await prisma.party.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartyUpdateManyArgs>(args: SelectSubset<T, PartyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Party.
     * @param {PartyUpsertArgs} args - Arguments to update or create a Party.
     * @example
     * // Update or create a Party
     * const party = await prisma.party.upsert({
     *   create: {
     *     // ... data to create a Party
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Party we want to update
     *   }
     * })
     */
    upsert<T extends PartyUpsertArgs>(args: SelectSubset<T, PartyUpsertArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyCountArgs} args - Arguments to filter Parties to count.
     * @example
     * // Count the number of Parties
     * const count = await prisma.party.count({
     *   where: {
     *     // ... the filter for the Parties we want to count
     *   }
     * })
    **/
    count<T extends PartyCountArgs>(
      args?: Subset<T, PartyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartyAggregateArgs>(args: Subset<T, PartyAggregateArgs>): Prisma.PrismaPromise<GetPartyAggregateType<T>>

    /**
     * Group by Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartyGroupByArgs['orderBy'] }
        : { orderBy?: PartyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Party model
   */
  readonly fields: PartyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Party.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactionInfo<T extends Party$transactionInfoArgs<ExtArgs> = {}>(args?: Subset<T, Party$transactionInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Party model
   */
  interface PartyFieldRefs {
    readonly id: FieldRef<"Party", 'Int'>
    readonly partyName: FieldRef<"Party", 'String'>
    readonly contactNo: FieldRef<"Party", 'String'>
    readonly address: FieldRef<"Party", 'String'>
    readonly partytype: FieldRef<"Party", 'PartyType'>
    readonly openingAmount: FieldRef<"Party", 'Float'>
    readonly openingDate: FieldRef<"Party", 'DateTime'>
    readonly isDeleted: FieldRef<"Party", 'Boolean'>
    readonly createdAt: FieldRef<"Party", 'DateTime'>
    readonly updatedAt: FieldRef<"Party", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Party findUnique
   */
  export type PartyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party findUniqueOrThrow
   */
  export type PartyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party findFirst
   */
  export type PartyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parties.
     */
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * Party findFirstOrThrow
   */
  export type PartyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parties.
     */
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * Party findMany
   */
  export type PartyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Parties to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * Party create
   */
  export type PartyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The data needed to create a Party.
     */
    data: XOR<PartyCreateInput, PartyUncheckedCreateInput>
  }

  /**
   * Party createMany
   */
  export type PartyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parties.
     */
    data: PartyCreateManyInput | PartyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Party update
   */
  export type PartyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The data needed to update a Party.
     */
    data: XOR<PartyUpdateInput, PartyUncheckedUpdateInput>
    /**
     * Choose, which Party to update.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party updateMany
   */
  export type PartyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parties.
     */
    data: XOR<PartyUpdateManyMutationInput, PartyUncheckedUpdateManyInput>
    /**
     * Filter which Parties to update
     */
    where?: PartyWhereInput
    /**
     * Limit how many Parties to update.
     */
    limit?: number
  }

  /**
   * Party upsert
   */
  export type PartyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The filter to search for the Party to update in case it exists.
     */
    where: PartyWhereUniqueInput
    /**
     * In case the Party found by the `where` argument doesn't exist, create a new Party with this data.
     */
    create: XOR<PartyCreateInput, PartyUncheckedCreateInput>
    /**
     * In case the Party was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartyUpdateInput, PartyUncheckedUpdateInput>
  }

  /**
   * Party delete
   */
  export type PartyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter which Party to delete.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party deleteMany
   */
  export type PartyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parties to delete
     */
    where?: PartyWhereInput
    /**
     * Limit how many Parties to delete.
     */
    limit?: number
  }

  /**
   * Party.transactionInfo
   */
  export type Party$transactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    where?: TransactionInfoWhereInput
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    cursor?: TransactionInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * Party without action
   */
  export type PartyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
  }


  /**
   * Model Stakeholder
   */

  export type AggregateStakeholder = {
    _count: StakeholderCountAggregateOutputType | null
    _avg: StakeholderAvgAggregateOutputType | null
    _sum: StakeholderSumAggregateOutputType | null
    _min: StakeholderMinAggregateOutputType | null
    _max: StakeholderMaxAggregateOutputType | null
  }

  export type StakeholderAvgAggregateOutputType = {
    id: number | null
    scopeId: number | null
    designationId: number | null
    degreeId: number | null
    honorary: number | null
    rxCommitment: number | null
  }

  export type StakeholderSumAggregateOutputType = {
    id: number | null
    scopeId: number | null
    designationId: number | null
    degreeId: number | null
    honorary: number | null
    rxCommitment: number | null
  }

  export type StakeholderMinAggregateOutputType = {
    id: number | null
    scopeId: number | null
    stakeId: string | null
    name: string | null
    designationId: number | null
    degreeId: number | null
    category: string | null
    officeAddress: string | null
    contactNo: string | null
    honorary: number | null
    paymentDate: Date | null
    rxCommitment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderMaxAggregateOutputType = {
    id: number | null
    scopeId: number | null
    stakeId: string | null
    name: string | null
    designationId: number | null
    degreeId: number | null
    category: string | null
    officeAddress: string | null
    contactNo: string | null
    honorary: number | null
    paymentDate: Date | null
    rxCommitment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderCountAggregateOutputType = {
    id: number
    scopeId: number
    stakeId: number
    name: number
    designationId: number
    degreeId: number
    category: number
    officeAddress: number
    contactNo: number
    honorary: number
    paymentDate: number
    rxCommitment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StakeholderAvgAggregateInputType = {
    id?: true
    scopeId?: true
    designationId?: true
    degreeId?: true
    honorary?: true
    rxCommitment?: true
  }

  export type StakeholderSumAggregateInputType = {
    id?: true
    scopeId?: true
    designationId?: true
    degreeId?: true
    honorary?: true
    rxCommitment?: true
  }

  export type StakeholderMinAggregateInputType = {
    id?: true
    scopeId?: true
    stakeId?: true
    name?: true
    designationId?: true
    degreeId?: true
    category?: true
    officeAddress?: true
    contactNo?: true
    honorary?: true
    paymentDate?: true
    rxCommitment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderMaxAggregateInputType = {
    id?: true
    scopeId?: true
    stakeId?: true
    name?: true
    designationId?: true
    degreeId?: true
    category?: true
    officeAddress?: true
    contactNo?: true
    honorary?: true
    paymentDate?: true
    rxCommitment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderCountAggregateInputType = {
    id?: true
    scopeId?: true
    stakeId?: true
    name?: true
    designationId?: true
    degreeId?: true
    category?: true
    officeAddress?: true
    contactNo?: true
    honorary?: true
    paymentDate?: true
    rxCommitment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StakeholderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stakeholder to aggregate.
     */
    where?: StakeholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stakeholders to fetch.
     */
    orderBy?: StakeholderOrderByWithRelationInput | StakeholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StakeholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stakeholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stakeholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stakeholders
    **/
    _count?: true | StakeholderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakeholderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakeholderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakeholderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakeholderMaxAggregateInputType
  }

  export type GetStakeholderAggregateType<T extends StakeholderAggregateArgs> = {
        [P in keyof T & keyof AggregateStakeholder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakeholder[P]>
      : GetScalarType<T[P], AggregateStakeholder[P]>
  }




  export type StakeholderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderWhereInput
    orderBy?: StakeholderOrderByWithAggregationInput | StakeholderOrderByWithAggregationInput[]
    by: StakeholderScalarFieldEnum[] | StakeholderScalarFieldEnum
    having?: StakeholderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakeholderCountAggregateInputType | true
    _avg?: StakeholderAvgAggregateInputType
    _sum?: StakeholderSumAggregateInputType
    _min?: StakeholderMinAggregateInputType
    _max?: StakeholderMaxAggregateInputType
  }

  export type StakeholderGroupByOutputType = {
    id: number
    scopeId: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date
    rxCommitment: number
    createdAt: Date
    updatedAt: Date
    _count: StakeholderCountAggregateOutputType | null
    _avg: StakeholderAvgAggregateOutputType | null
    _sum: StakeholderSumAggregateOutputType | null
    _min: StakeholderMinAggregateOutputType | null
    _max: StakeholderMaxAggregateOutputType | null
  }

  type GetStakeholderGroupByPayload<T extends StakeholderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakeholderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakeholderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakeholderGroupByOutputType[P]>
            : GetScalarType<T[P], StakeholderGroupByOutputType[P]>
        }
      >
    >


  export type StakeholderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scopeId?: boolean
    stakeId?: boolean
    name?: boolean
    designationId?: boolean
    degreeId?: boolean
    category?: boolean
    officeAddress?: boolean
    contactNo?: boolean
    honorary?: boolean
    paymentDate?: boolean
    rxCommitment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | Stakeholder$productArgs<ExtArgs>
    stakeholderDegree?: boolean | StakeholderDegreeDefaultArgs<ExtArgs>
    stakeholderDeisgnation?: boolean | StakeholderDeisgnationDefaultArgs<ExtArgs>
    scopes?: boolean | Stakeholder$scopesArgs<ExtArgs>
    stakeholderChember?: boolean | Stakeholder$stakeholderChemberArgs<ExtArgs>
    stakeholderOcation?: boolean | Stakeholder$stakeholderOcationArgs<ExtArgs>
    transactionInfo?: boolean | Stakeholder$transactionInfoArgs<ExtArgs>
    _count?: boolean | StakeholderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakeholder"]>



  export type StakeholderSelectScalar = {
    id?: boolean
    scopeId?: boolean
    stakeId?: boolean
    name?: boolean
    designationId?: boolean
    degreeId?: boolean
    category?: boolean
    officeAddress?: boolean
    contactNo?: boolean
    honorary?: boolean
    paymentDate?: boolean
    rxCommitment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StakeholderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scopeId" | "stakeId" | "name" | "designationId" | "degreeId" | "category" | "officeAddress" | "contactNo" | "honorary" | "paymentDate" | "rxCommitment" | "createdAt" | "updatedAt", ExtArgs["result"]["stakeholder"]>
  export type StakeholderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Stakeholder$productArgs<ExtArgs>
    stakeholderDegree?: boolean | StakeholderDegreeDefaultArgs<ExtArgs>
    stakeholderDeisgnation?: boolean | StakeholderDeisgnationDefaultArgs<ExtArgs>
    scopes?: boolean | Stakeholder$scopesArgs<ExtArgs>
    stakeholderChember?: boolean | Stakeholder$stakeholderChemberArgs<ExtArgs>
    stakeholderOcation?: boolean | Stakeholder$stakeholderOcationArgs<ExtArgs>
    transactionInfo?: boolean | Stakeholder$transactionInfoArgs<ExtArgs>
    _count?: boolean | StakeholderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StakeholderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stakeholder"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
      stakeholderDegree: Prisma.$StakeholderDegreePayload<ExtArgs>
      stakeholderDeisgnation: Prisma.$StakeholderDeisgnationPayload<ExtArgs>
      scopes: Prisma.$ScopePayload<ExtArgs>[]
      stakeholderChember: Prisma.$stakeholderChemberPayload<ExtArgs>[]
      stakeholderOcation: Prisma.$StakeholderOcationPayload<ExtArgs>[]
      transactionInfo: Prisma.$TransactionInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      scopeId: number | null
      stakeId: string
      name: string
      designationId: number
      degreeId: number
      category: string
      officeAddress: string
      contactNo: string
      honorary: number
      paymentDate: Date
      rxCommitment: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stakeholder"]>
    composites: {}
  }

  type StakeholderGetPayload<S extends boolean | null | undefined | StakeholderDefaultArgs> = $Result.GetResult<Prisma.$StakeholderPayload, S>

  type StakeholderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StakeholderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakeholderCountAggregateInputType | true
    }

  export interface StakeholderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stakeholder'], meta: { name: 'Stakeholder' } }
    /**
     * Find zero or one Stakeholder that matches the filter.
     * @param {StakeholderFindUniqueArgs} args - Arguments to find a Stakeholder
     * @example
     * // Get one Stakeholder
     * const stakeholder = await prisma.stakeholder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StakeholderFindUniqueArgs>(args: SelectSubset<T, StakeholderFindUniqueArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stakeholder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StakeholderFindUniqueOrThrowArgs} args - Arguments to find a Stakeholder
     * @example
     * // Get one Stakeholder
     * const stakeholder = await prisma.stakeholder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StakeholderFindUniqueOrThrowArgs>(args: SelectSubset<T, StakeholderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stakeholder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderFindFirstArgs} args - Arguments to find a Stakeholder
     * @example
     * // Get one Stakeholder
     * const stakeholder = await prisma.stakeholder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StakeholderFindFirstArgs>(args?: SelectSubset<T, StakeholderFindFirstArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stakeholder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderFindFirstOrThrowArgs} args - Arguments to find a Stakeholder
     * @example
     * // Get one Stakeholder
     * const stakeholder = await prisma.stakeholder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StakeholderFindFirstOrThrowArgs>(args?: SelectSubset<T, StakeholderFindFirstOrThrowArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stakeholders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stakeholders
     * const stakeholders = await prisma.stakeholder.findMany()
     * 
     * // Get first 10 Stakeholders
     * const stakeholders = await prisma.stakeholder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakeholderWithIdOnly = await prisma.stakeholder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StakeholderFindManyArgs>(args?: SelectSubset<T, StakeholderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stakeholder.
     * @param {StakeholderCreateArgs} args - Arguments to create a Stakeholder.
     * @example
     * // Create one Stakeholder
     * const Stakeholder = await prisma.stakeholder.create({
     *   data: {
     *     // ... data to create a Stakeholder
     *   }
     * })
     * 
     */
    create<T extends StakeholderCreateArgs>(args: SelectSubset<T, StakeholderCreateArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stakeholders.
     * @param {StakeholderCreateManyArgs} args - Arguments to create many Stakeholders.
     * @example
     * // Create many Stakeholders
     * const stakeholder = await prisma.stakeholder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StakeholderCreateManyArgs>(args?: SelectSubset<T, StakeholderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stakeholder.
     * @param {StakeholderDeleteArgs} args - Arguments to delete one Stakeholder.
     * @example
     * // Delete one Stakeholder
     * const Stakeholder = await prisma.stakeholder.delete({
     *   where: {
     *     // ... filter to delete one Stakeholder
     *   }
     * })
     * 
     */
    delete<T extends StakeholderDeleteArgs>(args: SelectSubset<T, StakeholderDeleteArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stakeholder.
     * @param {StakeholderUpdateArgs} args - Arguments to update one Stakeholder.
     * @example
     * // Update one Stakeholder
     * const stakeholder = await prisma.stakeholder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StakeholderUpdateArgs>(args: SelectSubset<T, StakeholderUpdateArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stakeholders.
     * @param {StakeholderDeleteManyArgs} args - Arguments to filter Stakeholders to delete.
     * @example
     * // Delete a few Stakeholders
     * const { count } = await prisma.stakeholder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StakeholderDeleteManyArgs>(args?: SelectSubset<T, StakeholderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stakeholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stakeholders
     * const stakeholder = await prisma.stakeholder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StakeholderUpdateManyArgs>(args: SelectSubset<T, StakeholderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stakeholder.
     * @param {StakeholderUpsertArgs} args - Arguments to update or create a Stakeholder.
     * @example
     * // Update or create a Stakeholder
     * const stakeholder = await prisma.stakeholder.upsert({
     *   create: {
     *     // ... data to create a Stakeholder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stakeholder we want to update
     *   }
     * })
     */
    upsert<T extends StakeholderUpsertArgs>(args: SelectSubset<T, StakeholderUpsertArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stakeholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderCountArgs} args - Arguments to filter Stakeholders to count.
     * @example
     * // Count the number of Stakeholders
     * const count = await prisma.stakeholder.count({
     *   where: {
     *     // ... the filter for the Stakeholders we want to count
     *   }
     * })
    **/
    count<T extends StakeholderCountArgs>(
      args?: Subset<T, StakeholderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakeholderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stakeholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakeholderAggregateArgs>(args: Subset<T, StakeholderAggregateArgs>): Prisma.PrismaPromise<GetStakeholderAggregateType<T>>

    /**
     * Group by Stakeholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StakeholderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StakeholderGroupByArgs['orderBy'] }
        : { orderBy?: StakeholderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StakeholderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakeholderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stakeholder model
   */
  readonly fields: StakeholderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stakeholder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StakeholderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends Stakeholder$productArgs<ExtArgs> = {}>(args?: Subset<T, Stakeholder$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stakeholderDegree<T extends StakeholderDegreeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StakeholderDegreeDefaultArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stakeholderDeisgnation<T extends StakeholderDeisgnationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StakeholderDeisgnationDefaultArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scopes<T extends Stakeholder$scopesArgs<ExtArgs> = {}>(args?: Subset<T, Stakeholder$scopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stakeholderChember<T extends Stakeholder$stakeholderChemberArgs<ExtArgs> = {}>(args?: Subset<T, Stakeholder$stakeholderChemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stakeholderOcation<T extends Stakeholder$stakeholderOcationArgs<ExtArgs> = {}>(args?: Subset<T, Stakeholder$stakeholderOcationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionInfo<T extends Stakeholder$transactionInfoArgs<ExtArgs> = {}>(args?: Subset<T, Stakeholder$transactionInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stakeholder model
   */
  interface StakeholderFieldRefs {
    readonly id: FieldRef<"Stakeholder", 'Int'>
    readonly scopeId: FieldRef<"Stakeholder", 'Int'>
    readonly stakeId: FieldRef<"Stakeholder", 'String'>
    readonly name: FieldRef<"Stakeholder", 'String'>
    readonly designationId: FieldRef<"Stakeholder", 'Int'>
    readonly degreeId: FieldRef<"Stakeholder", 'Int'>
    readonly category: FieldRef<"Stakeholder", 'String'>
    readonly officeAddress: FieldRef<"Stakeholder", 'String'>
    readonly contactNo: FieldRef<"Stakeholder", 'String'>
    readonly honorary: FieldRef<"Stakeholder", 'Int'>
    readonly paymentDate: FieldRef<"Stakeholder", 'DateTime'>
    readonly rxCommitment: FieldRef<"Stakeholder", 'Int'>
    readonly createdAt: FieldRef<"Stakeholder", 'DateTime'>
    readonly updatedAt: FieldRef<"Stakeholder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stakeholder findUnique
   */
  export type StakeholderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * Filter, which Stakeholder to fetch.
     */
    where: StakeholderWhereUniqueInput
  }

  /**
   * Stakeholder findUniqueOrThrow
   */
  export type StakeholderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * Filter, which Stakeholder to fetch.
     */
    where: StakeholderWhereUniqueInput
  }

  /**
   * Stakeholder findFirst
   */
  export type StakeholderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * Filter, which Stakeholder to fetch.
     */
    where?: StakeholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stakeholders to fetch.
     */
    orderBy?: StakeholderOrderByWithRelationInput | StakeholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stakeholders.
     */
    cursor?: StakeholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stakeholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stakeholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stakeholders.
     */
    distinct?: StakeholderScalarFieldEnum | StakeholderScalarFieldEnum[]
  }

  /**
   * Stakeholder findFirstOrThrow
   */
  export type StakeholderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * Filter, which Stakeholder to fetch.
     */
    where?: StakeholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stakeholders to fetch.
     */
    orderBy?: StakeholderOrderByWithRelationInput | StakeholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stakeholders.
     */
    cursor?: StakeholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stakeholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stakeholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stakeholders.
     */
    distinct?: StakeholderScalarFieldEnum | StakeholderScalarFieldEnum[]
  }

  /**
   * Stakeholder findMany
   */
  export type StakeholderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * Filter, which Stakeholders to fetch.
     */
    where?: StakeholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stakeholders to fetch.
     */
    orderBy?: StakeholderOrderByWithRelationInput | StakeholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stakeholders.
     */
    cursor?: StakeholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stakeholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stakeholders.
     */
    skip?: number
    distinct?: StakeholderScalarFieldEnum | StakeholderScalarFieldEnum[]
  }

  /**
   * Stakeholder create
   */
  export type StakeholderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * The data needed to create a Stakeholder.
     */
    data: XOR<StakeholderCreateInput, StakeholderUncheckedCreateInput>
  }

  /**
   * Stakeholder createMany
   */
  export type StakeholderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stakeholders.
     */
    data: StakeholderCreateManyInput | StakeholderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stakeholder update
   */
  export type StakeholderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * The data needed to update a Stakeholder.
     */
    data: XOR<StakeholderUpdateInput, StakeholderUncheckedUpdateInput>
    /**
     * Choose, which Stakeholder to update.
     */
    where: StakeholderWhereUniqueInput
  }

  /**
   * Stakeholder updateMany
   */
  export type StakeholderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stakeholders.
     */
    data: XOR<StakeholderUpdateManyMutationInput, StakeholderUncheckedUpdateManyInput>
    /**
     * Filter which Stakeholders to update
     */
    where?: StakeholderWhereInput
    /**
     * Limit how many Stakeholders to update.
     */
    limit?: number
  }

  /**
   * Stakeholder upsert
   */
  export type StakeholderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * The filter to search for the Stakeholder to update in case it exists.
     */
    where: StakeholderWhereUniqueInput
    /**
     * In case the Stakeholder found by the `where` argument doesn't exist, create a new Stakeholder with this data.
     */
    create: XOR<StakeholderCreateInput, StakeholderUncheckedCreateInput>
    /**
     * In case the Stakeholder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StakeholderUpdateInput, StakeholderUncheckedUpdateInput>
  }

  /**
   * Stakeholder delete
   */
  export type StakeholderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    /**
     * Filter which Stakeholder to delete.
     */
    where: StakeholderWhereUniqueInput
  }

  /**
   * Stakeholder deleteMany
   */
  export type StakeholderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stakeholders to delete
     */
    where?: StakeholderWhereInput
    /**
     * Limit how many Stakeholders to delete.
     */
    limit?: number
  }

  /**
   * Stakeholder.product
   */
  export type Stakeholder$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Stakeholder.scopes
   */
  export type Stakeholder$scopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    where?: ScopeWhereInput
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    cursor?: ScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScopeScalarFieldEnum | ScopeScalarFieldEnum[]
  }

  /**
   * Stakeholder.stakeholderChember
   */
  export type Stakeholder$stakeholderChemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    where?: stakeholderChemberWhereInput
    orderBy?: stakeholderChemberOrderByWithRelationInput | stakeholderChemberOrderByWithRelationInput[]
    cursor?: stakeholderChemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakeholderChemberScalarFieldEnum | StakeholderChemberScalarFieldEnum[]
  }

  /**
   * Stakeholder.stakeholderOcation
   */
  export type Stakeholder$stakeholderOcationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    where?: StakeholderOcationWhereInput
    orderBy?: StakeholderOcationOrderByWithRelationInput | StakeholderOcationOrderByWithRelationInput[]
    cursor?: StakeholderOcationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakeholderOcationScalarFieldEnum | StakeholderOcationScalarFieldEnum[]
  }

  /**
   * Stakeholder.transactionInfo
   */
  export type Stakeholder$transactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    where?: TransactionInfoWhereInput
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    cursor?: TransactionInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * Stakeholder without action
   */
  export type StakeholderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
  }


  /**
   * Model StakeholderDeisgnation
   */

  export type AggregateStakeholderDeisgnation = {
    _count: StakeholderDeisgnationCountAggregateOutputType | null
    _avg: StakeholderDeisgnationAvgAggregateOutputType | null
    _sum: StakeholderDeisgnationSumAggregateOutputType | null
    _min: StakeholderDeisgnationMinAggregateOutputType | null
    _max: StakeholderDeisgnationMaxAggregateOutputType | null
  }

  export type StakeholderDeisgnationAvgAggregateOutputType = {
    id: number | null
  }

  export type StakeholderDeisgnationSumAggregateOutputType = {
    id: number | null
  }

  export type StakeholderDeisgnationMinAggregateOutputType = {
    id: number | null
    designation: string | null
    description: string | null
    isDelete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderDeisgnationMaxAggregateOutputType = {
    id: number | null
    designation: string | null
    description: string | null
    isDelete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderDeisgnationCountAggregateOutputType = {
    id: number
    designation: number
    description: number
    isDelete: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StakeholderDeisgnationAvgAggregateInputType = {
    id?: true
  }

  export type StakeholderDeisgnationSumAggregateInputType = {
    id?: true
  }

  export type StakeholderDeisgnationMinAggregateInputType = {
    id?: true
    designation?: true
    description?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderDeisgnationMaxAggregateInputType = {
    id?: true
    designation?: true
    description?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderDeisgnationCountAggregateInputType = {
    id?: true
    designation?: true
    description?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StakeholderDeisgnationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakeholderDeisgnation to aggregate.
     */
    where?: StakeholderDeisgnationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDeisgnations to fetch.
     */
    orderBy?: StakeholderDeisgnationOrderByWithRelationInput | StakeholderDeisgnationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StakeholderDeisgnationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDeisgnations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDeisgnations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StakeholderDeisgnations
    **/
    _count?: true | StakeholderDeisgnationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakeholderDeisgnationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakeholderDeisgnationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakeholderDeisgnationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakeholderDeisgnationMaxAggregateInputType
  }

  export type GetStakeholderDeisgnationAggregateType<T extends StakeholderDeisgnationAggregateArgs> = {
        [P in keyof T & keyof AggregateStakeholderDeisgnation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakeholderDeisgnation[P]>
      : GetScalarType<T[P], AggregateStakeholderDeisgnation[P]>
  }




  export type StakeholderDeisgnationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderDeisgnationWhereInput
    orderBy?: StakeholderDeisgnationOrderByWithAggregationInput | StakeholderDeisgnationOrderByWithAggregationInput[]
    by: StakeholderDeisgnationScalarFieldEnum[] | StakeholderDeisgnationScalarFieldEnum
    having?: StakeholderDeisgnationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakeholderDeisgnationCountAggregateInputType | true
    _avg?: StakeholderDeisgnationAvgAggregateInputType
    _sum?: StakeholderDeisgnationSumAggregateInputType
    _min?: StakeholderDeisgnationMinAggregateInputType
    _max?: StakeholderDeisgnationMaxAggregateInputType
  }

  export type StakeholderDeisgnationGroupByOutputType = {
    id: number
    designation: string
    description: string | null
    isDelete: boolean
    createdAt: Date
    updatedAt: Date
    _count: StakeholderDeisgnationCountAggregateOutputType | null
    _avg: StakeholderDeisgnationAvgAggregateOutputType | null
    _sum: StakeholderDeisgnationSumAggregateOutputType | null
    _min: StakeholderDeisgnationMinAggregateOutputType | null
    _max: StakeholderDeisgnationMaxAggregateOutputType | null
  }

  type GetStakeholderDeisgnationGroupByPayload<T extends StakeholderDeisgnationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakeholderDeisgnationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakeholderDeisgnationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakeholderDeisgnationGroupByOutputType[P]>
            : GetScalarType<T[P], StakeholderDeisgnationGroupByOutputType[P]>
        }
      >
    >


  export type StakeholderDeisgnationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    description?: boolean
    isDelete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stakeholder?: boolean | StakeholderDeisgnation$stakeholderArgs<ExtArgs>
    _count?: boolean | StakeholderDeisgnationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakeholderDeisgnation"]>



  export type StakeholderDeisgnationSelectScalar = {
    id?: boolean
    designation?: boolean
    description?: boolean
    isDelete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StakeholderDeisgnationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "designation" | "description" | "isDelete" | "createdAt" | "updatedAt", ExtArgs["result"]["stakeholderDeisgnation"]>
  export type StakeholderDeisgnationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholder?: boolean | StakeholderDeisgnation$stakeholderArgs<ExtArgs>
    _count?: boolean | StakeholderDeisgnationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StakeholderDeisgnationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StakeholderDeisgnation"
    objects: {
      stakeholder: Prisma.$StakeholderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      designation: string
      description: string | null
      isDelete: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stakeholderDeisgnation"]>
    composites: {}
  }

  type StakeholderDeisgnationGetPayload<S extends boolean | null | undefined | StakeholderDeisgnationDefaultArgs> = $Result.GetResult<Prisma.$StakeholderDeisgnationPayload, S>

  type StakeholderDeisgnationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StakeholderDeisgnationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakeholderDeisgnationCountAggregateInputType | true
    }

  export interface StakeholderDeisgnationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StakeholderDeisgnation'], meta: { name: 'StakeholderDeisgnation' } }
    /**
     * Find zero or one StakeholderDeisgnation that matches the filter.
     * @param {StakeholderDeisgnationFindUniqueArgs} args - Arguments to find a StakeholderDeisgnation
     * @example
     * // Get one StakeholderDeisgnation
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StakeholderDeisgnationFindUniqueArgs>(args: SelectSubset<T, StakeholderDeisgnationFindUniqueArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakeholderDeisgnation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StakeholderDeisgnationFindUniqueOrThrowArgs} args - Arguments to find a StakeholderDeisgnation
     * @example
     * // Get one StakeholderDeisgnation
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StakeholderDeisgnationFindUniqueOrThrowArgs>(args: SelectSubset<T, StakeholderDeisgnationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderDeisgnation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDeisgnationFindFirstArgs} args - Arguments to find a StakeholderDeisgnation
     * @example
     * // Get one StakeholderDeisgnation
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StakeholderDeisgnationFindFirstArgs>(args?: SelectSubset<T, StakeholderDeisgnationFindFirstArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderDeisgnation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDeisgnationFindFirstOrThrowArgs} args - Arguments to find a StakeholderDeisgnation
     * @example
     * // Get one StakeholderDeisgnation
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StakeholderDeisgnationFindFirstOrThrowArgs>(args?: SelectSubset<T, StakeholderDeisgnationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakeholderDeisgnations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDeisgnationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakeholderDeisgnations
     * const stakeholderDeisgnations = await prisma.stakeholderDeisgnation.findMany()
     * 
     * // Get first 10 StakeholderDeisgnations
     * const stakeholderDeisgnations = await prisma.stakeholderDeisgnation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakeholderDeisgnationWithIdOnly = await prisma.stakeholderDeisgnation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StakeholderDeisgnationFindManyArgs>(args?: SelectSubset<T, StakeholderDeisgnationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakeholderDeisgnation.
     * @param {StakeholderDeisgnationCreateArgs} args - Arguments to create a StakeholderDeisgnation.
     * @example
     * // Create one StakeholderDeisgnation
     * const StakeholderDeisgnation = await prisma.stakeholderDeisgnation.create({
     *   data: {
     *     // ... data to create a StakeholderDeisgnation
     *   }
     * })
     * 
     */
    create<T extends StakeholderDeisgnationCreateArgs>(args: SelectSubset<T, StakeholderDeisgnationCreateArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakeholderDeisgnations.
     * @param {StakeholderDeisgnationCreateManyArgs} args - Arguments to create many StakeholderDeisgnations.
     * @example
     * // Create many StakeholderDeisgnations
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StakeholderDeisgnationCreateManyArgs>(args?: SelectSubset<T, StakeholderDeisgnationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StakeholderDeisgnation.
     * @param {StakeholderDeisgnationDeleteArgs} args - Arguments to delete one StakeholderDeisgnation.
     * @example
     * // Delete one StakeholderDeisgnation
     * const StakeholderDeisgnation = await prisma.stakeholderDeisgnation.delete({
     *   where: {
     *     // ... filter to delete one StakeholderDeisgnation
     *   }
     * })
     * 
     */
    delete<T extends StakeholderDeisgnationDeleteArgs>(args: SelectSubset<T, StakeholderDeisgnationDeleteArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakeholderDeisgnation.
     * @param {StakeholderDeisgnationUpdateArgs} args - Arguments to update one StakeholderDeisgnation.
     * @example
     * // Update one StakeholderDeisgnation
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StakeholderDeisgnationUpdateArgs>(args: SelectSubset<T, StakeholderDeisgnationUpdateArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakeholderDeisgnations.
     * @param {StakeholderDeisgnationDeleteManyArgs} args - Arguments to filter StakeholderDeisgnations to delete.
     * @example
     * // Delete a few StakeholderDeisgnations
     * const { count } = await prisma.stakeholderDeisgnation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StakeholderDeisgnationDeleteManyArgs>(args?: SelectSubset<T, StakeholderDeisgnationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakeholderDeisgnations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDeisgnationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakeholderDeisgnations
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StakeholderDeisgnationUpdateManyArgs>(args: SelectSubset<T, StakeholderDeisgnationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StakeholderDeisgnation.
     * @param {StakeholderDeisgnationUpsertArgs} args - Arguments to update or create a StakeholderDeisgnation.
     * @example
     * // Update or create a StakeholderDeisgnation
     * const stakeholderDeisgnation = await prisma.stakeholderDeisgnation.upsert({
     *   create: {
     *     // ... data to create a StakeholderDeisgnation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakeholderDeisgnation we want to update
     *   }
     * })
     */
    upsert<T extends StakeholderDeisgnationUpsertArgs>(args: SelectSubset<T, StakeholderDeisgnationUpsertArgs<ExtArgs>>): Prisma__StakeholderDeisgnationClient<$Result.GetResult<Prisma.$StakeholderDeisgnationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakeholderDeisgnations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDeisgnationCountArgs} args - Arguments to filter StakeholderDeisgnations to count.
     * @example
     * // Count the number of StakeholderDeisgnations
     * const count = await prisma.stakeholderDeisgnation.count({
     *   where: {
     *     // ... the filter for the StakeholderDeisgnations we want to count
     *   }
     * })
    **/
    count<T extends StakeholderDeisgnationCountArgs>(
      args?: Subset<T, StakeholderDeisgnationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakeholderDeisgnationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakeholderDeisgnation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDeisgnationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakeholderDeisgnationAggregateArgs>(args: Subset<T, StakeholderDeisgnationAggregateArgs>): Prisma.PrismaPromise<GetStakeholderDeisgnationAggregateType<T>>

    /**
     * Group by StakeholderDeisgnation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDeisgnationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StakeholderDeisgnationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StakeholderDeisgnationGroupByArgs['orderBy'] }
        : { orderBy?: StakeholderDeisgnationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StakeholderDeisgnationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakeholderDeisgnationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StakeholderDeisgnation model
   */
  readonly fields: StakeholderDeisgnationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StakeholderDeisgnation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StakeholderDeisgnationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stakeholder<T extends StakeholderDeisgnation$stakeholderArgs<ExtArgs> = {}>(args?: Subset<T, StakeholderDeisgnation$stakeholderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StakeholderDeisgnation model
   */
  interface StakeholderDeisgnationFieldRefs {
    readonly id: FieldRef<"StakeholderDeisgnation", 'Int'>
    readonly designation: FieldRef<"StakeholderDeisgnation", 'String'>
    readonly description: FieldRef<"StakeholderDeisgnation", 'String'>
    readonly isDelete: FieldRef<"StakeholderDeisgnation", 'Boolean'>
    readonly createdAt: FieldRef<"StakeholderDeisgnation", 'DateTime'>
    readonly updatedAt: FieldRef<"StakeholderDeisgnation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StakeholderDeisgnation findUnique
   */
  export type StakeholderDeisgnationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDeisgnation to fetch.
     */
    where: StakeholderDeisgnationWhereUniqueInput
  }

  /**
   * StakeholderDeisgnation findUniqueOrThrow
   */
  export type StakeholderDeisgnationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDeisgnation to fetch.
     */
    where: StakeholderDeisgnationWhereUniqueInput
  }

  /**
   * StakeholderDeisgnation findFirst
   */
  export type StakeholderDeisgnationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDeisgnation to fetch.
     */
    where?: StakeholderDeisgnationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDeisgnations to fetch.
     */
    orderBy?: StakeholderDeisgnationOrderByWithRelationInput | StakeholderDeisgnationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakeholderDeisgnations.
     */
    cursor?: StakeholderDeisgnationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDeisgnations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDeisgnations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakeholderDeisgnations.
     */
    distinct?: StakeholderDeisgnationScalarFieldEnum | StakeholderDeisgnationScalarFieldEnum[]
  }

  /**
   * StakeholderDeisgnation findFirstOrThrow
   */
  export type StakeholderDeisgnationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDeisgnation to fetch.
     */
    where?: StakeholderDeisgnationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDeisgnations to fetch.
     */
    orderBy?: StakeholderDeisgnationOrderByWithRelationInput | StakeholderDeisgnationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakeholderDeisgnations.
     */
    cursor?: StakeholderDeisgnationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDeisgnations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDeisgnations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakeholderDeisgnations.
     */
    distinct?: StakeholderDeisgnationScalarFieldEnum | StakeholderDeisgnationScalarFieldEnum[]
  }

  /**
   * StakeholderDeisgnation findMany
   */
  export type StakeholderDeisgnationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDeisgnations to fetch.
     */
    where?: StakeholderDeisgnationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDeisgnations to fetch.
     */
    orderBy?: StakeholderDeisgnationOrderByWithRelationInput | StakeholderDeisgnationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StakeholderDeisgnations.
     */
    cursor?: StakeholderDeisgnationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDeisgnations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDeisgnations.
     */
    skip?: number
    distinct?: StakeholderDeisgnationScalarFieldEnum | StakeholderDeisgnationScalarFieldEnum[]
  }

  /**
   * StakeholderDeisgnation create
   */
  export type StakeholderDeisgnationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * The data needed to create a StakeholderDeisgnation.
     */
    data: XOR<StakeholderDeisgnationCreateInput, StakeholderDeisgnationUncheckedCreateInput>
  }

  /**
   * StakeholderDeisgnation createMany
   */
  export type StakeholderDeisgnationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StakeholderDeisgnations.
     */
    data: StakeholderDeisgnationCreateManyInput | StakeholderDeisgnationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StakeholderDeisgnation update
   */
  export type StakeholderDeisgnationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * The data needed to update a StakeholderDeisgnation.
     */
    data: XOR<StakeholderDeisgnationUpdateInput, StakeholderDeisgnationUncheckedUpdateInput>
    /**
     * Choose, which StakeholderDeisgnation to update.
     */
    where: StakeholderDeisgnationWhereUniqueInput
  }

  /**
   * StakeholderDeisgnation updateMany
   */
  export type StakeholderDeisgnationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StakeholderDeisgnations.
     */
    data: XOR<StakeholderDeisgnationUpdateManyMutationInput, StakeholderDeisgnationUncheckedUpdateManyInput>
    /**
     * Filter which StakeholderDeisgnations to update
     */
    where?: StakeholderDeisgnationWhereInput
    /**
     * Limit how many StakeholderDeisgnations to update.
     */
    limit?: number
  }

  /**
   * StakeholderDeisgnation upsert
   */
  export type StakeholderDeisgnationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * The filter to search for the StakeholderDeisgnation to update in case it exists.
     */
    where: StakeholderDeisgnationWhereUniqueInput
    /**
     * In case the StakeholderDeisgnation found by the `where` argument doesn't exist, create a new StakeholderDeisgnation with this data.
     */
    create: XOR<StakeholderDeisgnationCreateInput, StakeholderDeisgnationUncheckedCreateInput>
    /**
     * In case the StakeholderDeisgnation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StakeholderDeisgnationUpdateInput, StakeholderDeisgnationUncheckedUpdateInput>
  }

  /**
   * StakeholderDeisgnation delete
   */
  export type StakeholderDeisgnationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
    /**
     * Filter which StakeholderDeisgnation to delete.
     */
    where: StakeholderDeisgnationWhereUniqueInput
  }

  /**
   * StakeholderDeisgnation deleteMany
   */
  export type StakeholderDeisgnationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakeholderDeisgnations to delete
     */
    where?: StakeholderDeisgnationWhereInput
    /**
     * Limit how many StakeholderDeisgnations to delete.
     */
    limit?: number
  }

  /**
   * StakeholderDeisgnation.stakeholder
   */
  export type StakeholderDeisgnation$stakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    where?: StakeholderWhereInput
    orderBy?: StakeholderOrderByWithRelationInput | StakeholderOrderByWithRelationInput[]
    cursor?: StakeholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakeholderScalarFieldEnum | StakeholderScalarFieldEnum[]
  }

  /**
   * StakeholderDeisgnation without action
   */
  export type StakeholderDeisgnationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDeisgnation
     */
    select?: StakeholderDeisgnationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDeisgnation
     */
    omit?: StakeholderDeisgnationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDeisgnationInclude<ExtArgs> | null
  }


  /**
   * Model StakeholderDegree
   */

  export type AggregateStakeholderDegree = {
    _count: StakeholderDegreeCountAggregateOutputType | null
    _avg: StakeholderDegreeAvgAggregateOutputType | null
    _sum: StakeholderDegreeSumAggregateOutputType | null
    _min: StakeholderDegreeMinAggregateOutputType | null
    _max: StakeholderDegreeMaxAggregateOutputType | null
  }

  export type StakeholderDegreeAvgAggregateOutputType = {
    id: number | null
  }

  export type StakeholderDegreeSumAggregateOutputType = {
    id: number | null
  }

  export type StakeholderDegreeMinAggregateOutputType = {
    id: number | null
    degreeName: string | null
    description: string | null
    isDelete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderDegreeMaxAggregateOutputType = {
    id: number | null
    degreeName: string | null
    description: string | null
    isDelete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderDegreeCountAggregateOutputType = {
    id: number
    degreeName: number
    description: number
    isDelete: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StakeholderDegreeAvgAggregateInputType = {
    id?: true
  }

  export type StakeholderDegreeSumAggregateInputType = {
    id?: true
  }

  export type StakeholderDegreeMinAggregateInputType = {
    id?: true
    degreeName?: true
    description?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderDegreeMaxAggregateInputType = {
    id?: true
    degreeName?: true
    description?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderDegreeCountAggregateInputType = {
    id?: true
    degreeName?: true
    description?: true
    isDelete?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StakeholderDegreeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakeholderDegree to aggregate.
     */
    where?: StakeholderDegreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDegrees to fetch.
     */
    orderBy?: StakeholderDegreeOrderByWithRelationInput | StakeholderDegreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StakeholderDegreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDegrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDegrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StakeholderDegrees
    **/
    _count?: true | StakeholderDegreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakeholderDegreeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakeholderDegreeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakeholderDegreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakeholderDegreeMaxAggregateInputType
  }

  export type GetStakeholderDegreeAggregateType<T extends StakeholderDegreeAggregateArgs> = {
        [P in keyof T & keyof AggregateStakeholderDegree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakeholderDegree[P]>
      : GetScalarType<T[P], AggregateStakeholderDegree[P]>
  }




  export type StakeholderDegreeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderDegreeWhereInput
    orderBy?: StakeholderDegreeOrderByWithAggregationInput | StakeholderDegreeOrderByWithAggregationInput[]
    by: StakeholderDegreeScalarFieldEnum[] | StakeholderDegreeScalarFieldEnum
    having?: StakeholderDegreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakeholderDegreeCountAggregateInputType | true
    _avg?: StakeholderDegreeAvgAggregateInputType
    _sum?: StakeholderDegreeSumAggregateInputType
    _min?: StakeholderDegreeMinAggregateInputType
    _max?: StakeholderDegreeMaxAggregateInputType
  }

  export type StakeholderDegreeGroupByOutputType = {
    id: number
    degreeName: string
    description: string | null
    isDelete: boolean
    createdAt: Date
    updatedAt: Date
    _count: StakeholderDegreeCountAggregateOutputType | null
    _avg: StakeholderDegreeAvgAggregateOutputType | null
    _sum: StakeholderDegreeSumAggregateOutputType | null
    _min: StakeholderDegreeMinAggregateOutputType | null
    _max: StakeholderDegreeMaxAggregateOutputType | null
  }

  type GetStakeholderDegreeGroupByPayload<T extends StakeholderDegreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakeholderDegreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakeholderDegreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakeholderDegreeGroupByOutputType[P]>
            : GetScalarType<T[P], StakeholderDegreeGroupByOutputType[P]>
        }
      >
    >


  export type StakeholderDegreeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    degreeName?: boolean
    description?: boolean
    isDelete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stakeholder?: boolean | StakeholderDegree$stakeholderArgs<ExtArgs>
    _count?: boolean | StakeholderDegreeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakeholderDegree"]>



  export type StakeholderDegreeSelectScalar = {
    id?: boolean
    degreeName?: boolean
    description?: boolean
    isDelete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StakeholderDegreeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "degreeName" | "description" | "isDelete" | "createdAt" | "updatedAt", ExtArgs["result"]["stakeholderDegree"]>
  export type StakeholderDegreeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholder?: boolean | StakeholderDegree$stakeholderArgs<ExtArgs>
    _count?: boolean | StakeholderDegreeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StakeholderDegreePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StakeholderDegree"
    objects: {
      stakeholder: Prisma.$StakeholderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      degreeName: string
      description: string | null
      isDelete: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stakeholderDegree"]>
    composites: {}
  }

  type StakeholderDegreeGetPayload<S extends boolean | null | undefined | StakeholderDegreeDefaultArgs> = $Result.GetResult<Prisma.$StakeholderDegreePayload, S>

  type StakeholderDegreeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StakeholderDegreeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakeholderDegreeCountAggregateInputType | true
    }

  export interface StakeholderDegreeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StakeholderDegree'], meta: { name: 'StakeholderDegree' } }
    /**
     * Find zero or one StakeholderDegree that matches the filter.
     * @param {StakeholderDegreeFindUniqueArgs} args - Arguments to find a StakeholderDegree
     * @example
     * // Get one StakeholderDegree
     * const stakeholderDegree = await prisma.stakeholderDegree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StakeholderDegreeFindUniqueArgs>(args: SelectSubset<T, StakeholderDegreeFindUniqueArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakeholderDegree that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StakeholderDegreeFindUniqueOrThrowArgs} args - Arguments to find a StakeholderDegree
     * @example
     * // Get one StakeholderDegree
     * const stakeholderDegree = await prisma.stakeholderDegree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StakeholderDegreeFindUniqueOrThrowArgs>(args: SelectSubset<T, StakeholderDegreeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderDegree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDegreeFindFirstArgs} args - Arguments to find a StakeholderDegree
     * @example
     * // Get one StakeholderDegree
     * const stakeholderDegree = await prisma.stakeholderDegree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StakeholderDegreeFindFirstArgs>(args?: SelectSubset<T, StakeholderDegreeFindFirstArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderDegree that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDegreeFindFirstOrThrowArgs} args - Arguments to find a StakeholderDegree
     * @example
     * // Get one StakeholderDegree
     * const stakeholderDegree = await prisma.stakeholderDegree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StakeholderDegreeFindFirstOrThrowArgs>(args?: SelectSubset<T, StakeholderDegreeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakeholderDegrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDegreeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakeholderDegrees
     * const stakeholderDegrees = await prisma.stakeholderDegree.findMany()
     * 
     * // Get first 10 StakeholderDegrees
     * const stakeholderDegrees = await prisma.stakeholderDegree.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakeholderDegreeWithIdOnly = await prisma.stakeholderDegree.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StakeholderDegreeFindManyArgs>(args?: SelectSubset<T, StakeholderDegreeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakeholderDegree.
     * @param {StakeholderDegreeCreateArgs} args - Arguments to create a StakeholderDegree.
     * @example
     * // Create one StakeholderDegree
     * const StakeholderDegree = await prisma.stakeholderDegree.create({
     *   data: {
     *     // ... data to create a StakeholderDegree
     *   }
     * })
     * 
     */
    create<T extends StakeholderDegreeCreateArgs>(args: SelectSubset<T, StakeholderDegreeCreateArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakeholderDegrees.
     * @param {StakeholderDegreeCreateManyArgs} args - Arguments to create many StakeholderDegrees.
     * @example
     * // Create many StakeholderDegrees
     * const stakeholderDegree = await prisma.stakeholderDegree.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StakeholderDegreeCreateManyArgs>(args?: SelectSubset<T, StakeholderDegreeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StakeholderDegree.
     * @param {StakeholderDegreeDeleteArgs} args - Arguments to delete one StakeholderDegree.
     * @example
     * // Delete one StakeholderDegree
     * const StakeholderDegree = await prisma.stakeholderDegree.delete({
     *   where: {
     *     // ... filter to delete one StakeholderDegree
     *   }
     * })
     * 
     */
    delete<T extends StakeholderDegreeDeleteArgs>(args: SelectSubset<T, StakeholderDegreeDeleteArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakeholderDegree.
     * @param {StakeholderDegreeUpdateArgs} args - Arguments to update one StakeholderDegree.
     * @example
     * // Update one StakeholderDegree
     * const stakeholderDegree = await prisma.stakeholderDegree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StakeholderDegreeUpdateArgs>(args: SelectSubset<T, StakeholderDegreeUpdateArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakeholderDegrees.
     * @param {StakeholderDegreeDeleteManyArgs} args - Arguments to filter StakeholderDegrees to delete.
     * @example
     * // Delete a few StakeholderDegrees
     * const { count } = await prisma.stakeholderDegree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StakeholderDegreeDeleteManyArgs>(args?: SelectSubset<T, StakeholderDegreeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakeholderDegrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDegreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakeholderDegrees
     * const stakeholderDegree = await prisma.stakeholderDegree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StakeholderDegreeUpdateManyArgs>(args: SelectSubset<T, StakeholderDegreeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StakeholderDegree.
     * @param {StakeholderDegreeUpsertArgs} args - Arguments to update or create a StakeholderDegree.
     * @example
     * // Update or create a StakeholderDegree
     * const stakeholderDegree = await prisma.stakeholderDegree.upsert({
     *   create: {
     *     // ... data to create a StakeholderDegree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakeholderDegree we want to update
     *   }
     * })
     */
    upsert<T extends StakeholderDegreeUpsertArgs>(args: SelectSubset<T, StakeholderDegreeUpsertArgs<ExtArgs>>): Prisma__StakeholderDegreeClient<$Result.GetResult<Prisma.$StakeholderDegreePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakeholderDegrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDegreeCountArgs} args - Arguments to filter StakeholderDegrees to count.
     * @example
     * // Count the number of StakeholderDegrees
     * const count = await prisma.stakeholderDegree.count({
     *   where: {
     *     // ... the filter for the StakeholderDegrees we want to count
     *   }
     * })
    **/
    count<T extends StakeholderDegreeCountArgs>(
      args?: Subset<T, StakeholderDegreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakeholderDegreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakeholderDegree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDegreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakeholderDegreeAggregateArgs>(args: Subset<T, StakeholderDegreeAggregateArgs>): Prisma.PrismaPromise<GetStakeholderDegreeAggregateType<T>>

    /**
     * Group by StakeholderDegree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderDegreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StakeholderDegreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StakeholderDegreeGroupByArgs['orderBy'] }
        : { orderBy?: StakeholderDegreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StakeholderDegreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakeholderDegreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StakeholderDegree model
   */
  readonly fields: StakeholderDegreeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StakeholderDegree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StakeholderDegreeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stakeholder<T extends StakeholderDegree$stakeholderArgs<ExtArgs> = {}>(args?: Subset<T, StakeholderDegree$stakeholderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StakeholderDegree model
   */
  interface StakeholderDegreeFieldRefs {
    readonly id: FieldRef<"StakeholderDegree", 'Int'>
    readonly degreeName: FieldRef<"StakeholderDegree", 'String'>
    readonly description: FieldRef<"StakeholderDegree", 'String'>
    readonly isDelete: FieldRef<"StakeholderDegree", 'Boolean'>
    readonly createdAt: FieldRef<"StakeholderDegree", 'DateTime'>
    readonly updatedAt: FieldRef<"StakeholderDegree", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StakeholderDegree findUnique
   */
  export type StakeholderDegreeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDegree to fetch.
     */
    where: StakeholderDegreeWhereUniqueInput
  }

  /**
   * StakeholderDegree findUniqueOrThrow
   */
  export type StakeholderDegreeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDegree to fetch.
     */
    where: StakeholderDegreeWhereUniqueInput
  }

  /**
   * StakeholderDegree findFirst
   */
  export type StakeholderDegreeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDegree to fetch.
     */
    where?: StakeholderDegreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDegrees to fetch.
     */
    orderBy?: StakeholderDegreeOrderByWithRelationInput | StakeholderDegreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakeholderDegrees.
     */
    cursor?: StakeholderDegreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDegrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDegrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakeholderDegrees.
     */
    distinct?: StakeholderDegreeScalarFieldEnum | StakeholderDegreeScalarFieldEnum[]
  }

  /**
   * StakeholderDegree findFirstOrThrow
   */
  export type StakeholderDegreeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDegree to fetch.
     */
    where?: StakeholderDegreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDegrees to fetch.
     */
    orderBy?: StakeholderDegreeOrderByWithRelationInput | StakeholderDegreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakeholderDegrees.
     */
    cursor?: StakeholderDegreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDegrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDegrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakeholderDegrees.
     */
    distinct?: StakeholderDegreeScalarFieldEnum | StakeholderDegreeScalarFieldEnum[]
  }

  /**
   * StakeholderDegree findMany
   */
  export type StakeholderDegreeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderDegrees to fetch.
     */
    where?: StakeholderDegreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderDegrees to fetch.
     */
    orderBy?: StakeholderDegreeOrderByWithRelationInput | StakeholderDegreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StakeholderDegrees.
     */
    cursor?: StakeholderDegreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderDegrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderDegrees.
     */
    skip?: number
    distinct?: StakeholderDegreeScalarFieldEnum | StakeholderDegreeScalarFieldEnum[]
  }

  /**
   * StakeholderDegree create
   */
  export type StakeholderDegreeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * The data needed to create a StakeholderDegree.
     */
    data: XOR<StakeholderDegreeCreateInput, StakeholderDegreeUncheckedCreateInput>
  }

  /**
   * StakeholderDegree createMany
   */
  export type StakeholderDegreeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StakeholderDegrees.
     */
    data: StakeholderDegreeCreateManyInput | StakeholderDegreeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StakeholderDegree update
   */
  export type StakeholderDegreeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * The data needed to update a StakeholderDegree.
     */
    data: XOR<StakeholderDegreeUpdateInput, StakeholderDegreeUncheckedUpdateInput>
    /**
     * Choose, which StakeholderDegree to update.
     */
    where: StakeholderDegreeWhereUniqueInput
  }

  /**
   * StakeholderDegree updateMany
   */
  export type StakeholderDegreeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StakeholderDegrees.
     */
    data: XOR<StakeholderDegreeUpdateManyMutationInput, StakeholderDegreeUncheckedUpdateManyInput>
    /**
     * Filter which StakeholderDegrees to update
     */
    where?: StakeholderDegreeWhereInput
    /**
     * Limit how many StakeholderDegrees to update.
     */
    limit?: number
  }

  /**
   * StakeholderDegree upsert
   */
  export type StakeholderDegreeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * The filter to search for the StakeholderDegree to update in case it exists.
     */
    where: StakeholderDegreeWhereUniqueInput
    /**
     * In case the StakeholderDegree found by the `where` argument doesn't exist, create a new StakeholderDegree with this data.
     */
    create: XOR<StakeholderDegreeCreateInput, StakeholderDegreeUncheckedCreateInput>
    /**
     * In case the StakeholderDegree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StakeholderDegreeUpdateInput, StakeholderDegreeUncheckedUpdateInput>
  }

  /**
   * StakeholderDegree delete
   */
  export type StakeholderDegreeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
    /**
     * Filter which StakeholderDegree to delete.
     */
    where: StakeholderDegreeWhereUniqueInput
  }

  /**
   * StakeholderDegree deleteMany
   */
  export type StakeholderDegreeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakeholderDegrees to delete
     */
    where?: StakeholderDegreeWhereInput
    /**
     * Limit how many StakeholderDegrees to delete.
     */
    limit?: number
  }

  /**
   * StakeholderDegree.stakeholder
   */
  export type StakeholderDegree$stakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    where?: StakeholderWhereInput
    orderBy?: StakeholderOrderByWithRelationInput | StakeholderOrderByWithRelationInput[]
    cursor?: StakeholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakeholderScalarFieldEnum | StakeholderScalarFieldEnum[]
  }

  /**
   * StakeholderDegree without action
   */
  export type StakeholderDegreeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderDegree
     */
    select?: StakeholderDegreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderDegree
     */
    omit?: StakeholderDegreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderDegreeInclude<ExtArgs> | null
  }


  /**
   * Model stakeholderChember
   */

  export type AggregateStakeholderChember = {
    _count: StakeholderChemberCountAggregateOutputType | null
    _avg: StakeholderChemberAvgAggregateOutputType | null
    _sum: StakeholderChemberSumAggregateOutputType | null
    _min: StakeholderChemberMinAggregateOutputType | null
    _max: StakeholderChemberMaxAggregateOutputType | null
  }

  export type StakeholderChemberAvgAggregateOutputType = {
    id: number | null
  }

  export type StakeholderChemberSumAggregateOutputType = {
    id: number | null
  }

  export type StakeholderChemberMinAggregateOutputType = {
    id: number | null
    stakeId: string | null
    address: string | null
    chemberDay: string | null
    chemberTime: string | null
    chemberName: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderChemberMaxAggregateOutputType = {
    id: number | null
    stakeId: string | null
    address: string | null
    chemberDay: string | null
    chemberTime: string | null
    chemberName: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StakeholderChemberCountAggregateOutputType = {
    id: number
    stakeId: number
    address: number
    chemberDay: number
    chemberTime: number
    chemberName: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StakeholderChemberAvgAggregateInputType = {
    id?: true
  }

  export type StakeholderChemberSumAggregateInputType = {
    id?: true
  }

  export type StakeholderChemberMinAggregateInputType = {
    id?: true
    stakeId?: true
    address?: true
    chemberDay?: true
    chemberTime?: true
    chemberName?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderChemberMaxAggregateInputType = {
    id?: true
    stakeId?: true
    address?: true
    chemberDay?: true
    chemberTime?: true
    chemberName?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StakeholderChemberCountAggregateInputType = {
    id?: true
    stakeId?: true
    address?: true
    chemberDay?: true
    chemberTime?: true
    chemberName?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StakeholderChemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stakeholderChember to aggregate.
     */
    where?: stakeholderChemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderChembers to fetch.
     */
    orderBy?: stakeholderChemberOrderByWithRelationInput | stakeholderChemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stakeholderChemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderChembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderChembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stakeholderChembers
    **/
    _count?: true | StakeholderChemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakeholderChemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakeholderChemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakeholderChemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakeholderChemberMaxAggregateInputType
  }

  export type GetStakeholderChemberAggregateType<T extends StakeholderChemberAggregateArgs> = {
        [P in keyof T & keyof AggregateStakeholderChember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakeholderChember[P]>
      : GetScalarType<T[P], AggregateStakeholderChember[P]>
  }




  export type stakeholderChemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stakeholderChemberWhereInput
    orderBy?: stakeholderChemberOrderByWithAggregationInput | stakeholderChemberOrderByWithAggregationInput[]
    by: StakeholderChemberScalarFieldEnum[] | StakeholderChemberScalarFieldEnum
    having?: stakeholderChemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakeholderChemberCountAggregateInputType | true
    _avg?: StakeholderChemberAvgAggregateInputType
    _sum?: StakeholderChemberSumAggregateInputType
    _min?: StakeholderChemberMinAggregateInputType
    _max?: StakeholderChemberMaxAggregateInputType
  }

  export type StakeholderChemberGroupByOutputType = {
    id: number
    stakeId: string | null
    address: string
    chemberDay: string
    chemberTime: string
    chemberName: string
    location: string
    createdAt: Date
    updatedAt: Date
    _count: StakeholderChemberCountAggregateOutputType | null
    _avg: StakeholderChemberAvgAggregateOutputType | null
    _sum: StakeholderChemberSumAggregateOutputType | null
    _min: StakeholderChemberMinAggregateOutputType | null
    _max: StakeholderChemberMaxAggregateOutputType | null
  }

  type GetStakeholderChemberGroupByPayload<T extends stakeholderChemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakeholderChemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakeholderChemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakeholderChemberGroupByOutputType[P]>
            : GetScalarType<T[P], StakeholderChemberGroupByOutputType[P]>
        }
      >
    >


  export type stakeholderChemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stakeId?: boolean
    address?: boolean
    chemberDay?: boolean
    chemberTime?: boolean
    chemberName?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stakeholder?: boolean | stakeholderChember$stakeholderArgs<ExtArgs>
  }, ExtArgs["result"]["stakeholderChember"]>



  export type stakeholderChemberSelectScalar = {
    id?: boolean
    stakeId?: boolean
    address?: boolean
    chemberDay?: boolean
    chemberTime?: boolean
    chemberName?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type stakeholderChemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stakeId" | "address" | "chemberDay" | "chemberTime" | "chemberName" | "location" | "createdAt" | "updatedAt", ExtArgs["result"]["stakeholderChember"]>
  export type stakeholderChemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholder?: boolean | stakeholderChember$stakeholderArgs<ExtArgs>
  }

  export type $stakeholderChemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stakeholderChember"
    objects: {
      stakeholder: Prisma.$StakeholderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stakeId: string | null
      address: string
      chemberDay: string
      chemberTime: string
      chemberName: string
      location: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stakeholderChember"]>
    composites: {}
  }

  type stakeholderChemberGetPayload<S extends boolean | null | undefined | stakeholderChemberDefaultArgs> = $Result.GetResult<Prisma.$stakeholderChemberPayload, S>

  type stakeholderChemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stakeholderChemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakeholderChemberCountAggregateInputType | true
    }

  export interface stakeholderChemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stakeholderChember'], meta: { name: 'stakeholderChember' } }
    /**
     * Find zero or one StakeholderChember that matches the filter.
     * @param {stakeholderChemberFindUniqueArgs} args - Arguments to find a StakeholderChember
     * @example
     * // Get one StakeholderChember
     * const stakeholderChember = await prisma.stakeholderChember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stakeholderChemberFindUniqueArgs>(args: SelectSubset<T, stakeholderChemberFindUniqueArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakeholderChember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stakeholderChemberFindUniqueOrThrowArgs} args - Arguments to find a StakeholderChember
     * @example
     * // Get one StakeholderChember
     * const stakeholderChember = await prisma.stakeholderChember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stakeholderChemberFindUniqueOrThrowArgs>(args: SelectSubset<T, stakeholderChemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderChember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderChemberFindFirstArgs} args - Arguments to find a StakeholderChember
     * @example
     * // Get one StakeholderChember
     * const stakeholderChember = await prisma.stakeholderChember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stakeholderChemberFindFirstArgs>(args?: SelectSubset<T, stakeholderChemberFindFirstArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderChember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderChemberFindFirstOrThrowArgs} args - Arguments to find a StakeholderChember
     * @example
     * // Get one StakeholderChember
     * const stakeholderChember = await prisma.stakeholderChember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stakeholderChemberFindFirstOrThrowArgs>(args?: SelectSubset<T, stakeholderChemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakeholderChembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderChemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakeholderChembers
     * const stakeholderChembers = await prisma.stakeholderChember.findMany()
     * 
     * // Get first 10 StakeholderChembers
     * const stakeholderChembers = await prisma.stakeholderChember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakeholderChemberWithIdOnly = await prisma.stakeholderChember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends stakeholderChemberFindManyArgs>(args?: SelectSubset<T, stakeholderChemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakeholderChember.
     * @param {stakeholderChemberCreateArgs} args - Arguments to create a StakeholderChember.
     * @example
     * // Create one StakeholderChember
     * const StakeholderChember = await prisma.stakeholderChember.create({
     *   data: {
     *     // ... data to create a StakeholderChember
     *   }
     * })
     * 
     */
    create<T extends stakeholderChemberCreateArgs>(args: SelectSubset<T, stakeholderChemberCreateArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakeholderChembers.
     * @param {stakeholderChemberCreateManyArgs} args - Arguments to create many StakeholderChembers.
     * @example
     * // Create many StakeholderChembers
     * const stakeholderChember = await prisma.stakeholderChember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stakeholderChemberCreateManyArgs>(args?: SelectSubset<T, stakeholderChemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StakeholderChember.
     * @param {stakeholderChemberDeleteArgs} args - Arguments to delete one StakeholderChember.
     * @example
     * // Delete one StakeholderChember
     * const StakeholderChember = await prisma.stakeholderChember.delete({
     *   where: {
     *     // ... filter to delete one StakeholderChember
     *   }
     * })
     * 
     */
    delete<T extends stakeholderChemberDeleteArgs>(args: SelectSubset<T, stakeholderChemberDeleteArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakeholderChember.
     * @param {stakeholderChemberUpdateArgs} args - Arguments to update one StakeholderChember.
     * @example
     * // Update one StakeholderChember
     * const stakeholderChember = await prisma.stakeholderChember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stakeholderChemberUpdateArgs>(args: SelectSubset<T, stakeholderChemberUpdateArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakeholderChembers.
     * @param {stakeholderChemberDeleteManyArgs} args - Arguments to filter StakeholderChembers to delete.
     * @example
     * // Delete a few StakeholderChembers
     * const { count } = await prisma.stakeholderChember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stakeholderChemberDeleteManyArgs>(args?: SelectSubset<T, stakeholderChemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakeholderChembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderChemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakeholderChembers
     * const stakeholderChember = await prisma.stakeholderChember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stakeholderChemberUpdateManyArgs>(args: SelectSubset<T, stakeholderChemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StakeholderChember.
     * @param {stakeholderChemberUpsertArgs} args - Arguments to update or create a StakeholderChember.
     * @example
     * // Update or create a StakeholderChember
     * const stakeholderChember = await prisma.stakeholderChember.upsert({
     *   create: {
     *     // ... data to create a StakeholderChember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakeholderChember we want to update
     *   }
     * })
     */
    upsert<T extends stakeholderChemberUpsertArgs>(args: SelectSubset<T, stakeholderChemberUpsertArgs<ExtArgs>>): Prisma__stakeholderChemberClient<$Result.GetResult<Prisma.$stakeholderChemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakeholderChembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderChemberCountArgs} args - Arguments to filter StakeholderChembers to count.
     * @example
     * // Count the number of StakeholderChembers
     * const count = await prisma.stakeholderChember.count({
     *   where: {
     *     // ... the filter for the StakeholderChembers we want to count
     *   }
     * })
    **/
    count<T extends stakeholderChemberCountArgs>(
      args?: Subset<T, stakeholderChemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakeholderChemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakeholderChember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderChemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakeholderChemberAggregateArgs>(args: Subset<T, StakeholderChemberAggregateArgs>): Prisma.PrismaPromise<GetStakeholderChemberAggregateType<T>>

    /**
     * Group by StakeholderChember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderChemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stakeholderChemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stakeholderChemberGroupByArgs['orderBy'] }
        : { orderBy?: stakeholderChemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stakeholderChemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakeholderChemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stakeholderChember model
   */
  readonly fields: stakeholderChemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stakeholderChember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stakeholderChemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stakeholder<T extends stakeholderChember$stakeholderArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderChember$stakeholderArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stakeholderChember model
   */
  interface stakeholderChemberFieldRefs {
    readonly id: FieldRef<"stakeholderChember", 'Int'>
    readonly stakeId: FieldRef<"stakeholderChember", 'String'>
    readonly address: FieldRef<"stakeholderChember", 'String'>
    readonly chemberDay: FieldRef<"stakeholderChember", 'String'>
    readonly chemberTime: FieldRef<"stakeholderChember", 'String'>
    readonly chemberName: FieldRef<"stakeholderChember", 'String'>
    readonly location: FieldRef<"stakeholderChember", 'String'>
    readonly createdAt: FieldRef<"stakeholderChember", 'DateTime'>
    readonly updatedAt: FieldRef<"stakeholderChember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * stakeholderChember findUnique
   */
  export type stakeholderChemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderChember to fetch.
     */
    where: stakeholderChemberWhereUniqueInput
  }

  /**
   * stakeholderChember findUniqueOrThrow
   */
  export type stakeholderChemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderChember to fetch.
     */
    where: stakeholderChemberWhereUniqueInput
  }

  /**
   * stakeholderChember findFirst
   */
  export type stakeholderChemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderChember to fetch.
     */
    where?: stakeholderChemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderChembers to fetch.
     */
    orderBy?: stakeholderChemberOrderByWithRelationInput | stakeholderChemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stakeholderChembers.
     */
    cursor?: stakeholderChemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderChembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderChembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stakeholderChembers.
     */
    distinct?: StakeholderChemberScalarFieldEnum | StakeholderChemberScalarFieldEnum[]
  }

  /**
   * stakeholderChember findFirstOrThrow
   */
  export type stakeholderChemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderChember to fetch.
     */
    where?: stakeholderChemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderChembers to fetch.
     */
    orderBy?: stakeholderChemberOrderByWithRelationInput | stakeholderChemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stakeholderChembers.
     */
    cursor?: stakeholderChemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderChembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderChembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stakeholderChembers.
     */
    distinct?: StakeholderChemberScalarFieldEnum | StakeholderChemberScalarFieldEnum[]
  }

  /**
   * stakeholderChember findMany
   */
  export type stakeholderChemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderChembers to fetch.
     */
    where?: stakeholderChemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderChembers to fetch.
     */
    orderBy?: stakeholderChemberOrderByWithRelationInput | stakeholderChemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stakeholderChembers.
     */
    cursor?: stakeholderChemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderChembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderChembers.
     */
    skip?: number
    distinct?: StakeholderChemberScalarFieldEnum | StakeholderChemberScalarFieldEnum[]
  }

  /**
   * stakeholderChember create
   */
  export type stakeholderChemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * The data needed to create a stakeholderChember.
     */
    data: XOR<stakeholderChemberCreateInput, stakeholderChemberUncheckedCreateInput>
  }

  /**
   * stakeholderChember createMany
   */
  export type stakeholderChemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stakeholderChembers.
     */
    data: stakeholderChemberCreateManyInput | stakeholderChemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stakeholderChember update
   */
  export type stakeholderChemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * The data needed to update a stakeholderChember.
     */
    data: XOR<stakeholderChemberUpdateInput, stakeholderChemberUncheckedUpdateInput>
    /**
     * Choose, which stakeholderChember to update.
     */
    where: stakeholderChemberWhereUniqueInput
  }

  /**
   * stakeholderChember updateMany
   */
  export type stakeholderChemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stakeholderChembers.
     */
    data: XOR<stakeholderChemberUpdateManyMutationInput, stakeholderChemberUncheckedUpdateManyInput>
    /**
     * Filter which stakeholderChembers to update
     */
    where?: stakeholderChemberWhereInput
    /**
     * Limit how many stakeholderChembers to update.
     */
    limit?: number
  }

  /**
   * stakeholderChember upsert
   */
  export type stakeholderChemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * The filter to search for the stakeholderChember to update in case it exists.
     */
    where: stakeholderChemberWhereUniqueInput
    /**
     * In case the stakeholderChember found by the `where` argument doesn't exist, create a new stakeholderChember with this data.
     */
    create: XOR<stakeholderChemberCreateInput, stakeholderChemberUncheckedCreateInput>
    /**
     * In case the stakeholderChember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stakeholderChemberUpdateInput, stakeholderChemberUncheckedUpdateInput>
  }

  /**
   * stakeholderChember delete
   */
  export type stakeholderChemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
    /**
     * Filter which stakeholderChember to delete.
     */
    where: stakeholderChemberWhereUniqueInput
  }

  /**
   * stakeholderChember deleteMany
   */
  export type stakeholderChemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stakeholderChembers to delete
     */
    where?: stakeholderChemberWhereInput
    /**
     * Limit how many stakeholderChembers to delete.
     */
    limit?: number
  }

  /**
   * stakeholderChember.stakeholder
   */
  export type stakeholderChember$stakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    where?: StakeholderWhereInput
  }

  /**
   * stakeholderChember without action
   */
  export type stakeholderChemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderChember
     */
    select?: stakeholderChemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderChember
     */
    omit?: stakeholderChemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderChemberInclude<ExtArgs> | null
  }


  /**
   * Model StakeholderOcation
   */

  export type AggregateStakeholderOcation = {
    _count: StakeholderOcationCountAggregateOutputType | null
    _avg: StakeholderOcationAvgAggregateOutputType | null
    _sum: StakeholderOcationSumAggregateOutputType | null
    _min: StakeholderOcationMinAggregateOutputType | null
    _max: StakeholderOcationMaxAggregateOutputType | null
  }

  export type StakeholderOcationAvgAggregateOutputType = {
    id: number | null
  }

  export type StakeholderOcationSumAggregateOutputType = {
    id: number | null
  }

  export type StakeholderOcationMinAggregateOutputType = {
    id: number | null
    stakeId: string | null
    ocationName: string | null
    relation: string | null
    personName: string | null
    dob: Date | null
    otherInfo: string | null
  }

  export type StakeholderOcationMaxAggregateOutputType = {
    id: number | null
    stakeId: string | null
    ocationName: string | null
    relation: string | null
    personName: string | null
    dob: Date | null
    otherInfo: string | null
  }

  export type StakeholderOcationCountAggregateOutputType = {
    id: number
    stakeId: number
    ocationName: number
    relation: number
    personName: number
    dob: number
    otherInfo: number
    _all: number
  }


  export type StakeholderOcationAvgAggregateInputType = {
    id?: true
  }

  export type StakeholderOcationSumAggregateInputType = {
    id?: true
  }

  export type StakeholderOcationMinAggregateInputType = {
    id?: true
    stakeId?: true
    ocationName?: true
    relation?: true
    personName?: true
    dob?: true
    otherInfo?: true
  }

  export type StakeholderOcationMaxAggregateInputType = {
    id?: true
    stakeId?: true
    ocationName?: true
    relation?: true
    personName?: true
    dob?: true
    otherInfo?: true
  }

  export type StakeholderOcationCountAggregateInputType = {
    id?: true
    stakeId?: true
    ocationName?: true
    relation?: true
    personName?: true
    dob?: true
    otherInfo?: true
    _all?: true
  }

  export type StakeholderOcationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakeholderOcation to aggregate.
     */
    where?: StakeholderOcationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderOcations to fetch.
     */
    orderBy?: StakeholderOcationOrderByWithRelationInput | StakeholderOcationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StakeholderOcationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderOcations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderOcations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StakeholderOcations
    **/
    _count?: true | StakeholderOcationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StakeholderOcationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StakeholderOcationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakeholderOcationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakeholderOcationMaxAggregateInputType
  }

  export type GetStakeholderOcationAggregateType<T extends StakeholderOcationAggregateArgs> = {
        [P in keyof T & keyof AggregateStakeholderOcation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakeholderOcation[P]>
      : GetScalarType<T[P], AggregateStakeholderOcation[P]>
  }




  export type StakeholderOcationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StakeholderOcationWhereInput
    orderBy?: StakeholderOcationOrderByWithAggregationInput | StakeholderOcationOrderByWithAggregationInput[]
    by: StakeholderOcationScalarFieldEnum[] | StakeholderOcationScalarFieldEnum
    having?: StakeholderOcationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakeholderOcationCountAggregateInputType | true
    _avg?: StakeholderOcationAvgAggregateInputType
    _sum?: StakeholderOcationSumAggregateInputType
    _min?: StakeholderOcationMinAggregateInputType
    _max?: StakeholderOcationMaxAggregateInputType
  }

  export type StakeholderOcationGroupByOutputType = {
    id: number
    stakeId: string
    ocationName: string
    relation: string
    personName: string | null
    dob: Date | null
    otherInfo: string | null
    _count: StakeholderOcationCountAggregateOutputType | null
    _avg: StakeholderOcationAvgAggregateOutputType | null
    _sum: StakeholderOcationSumAggregateOutputType | null
    _min: StakeholderOcationMinAggregateOutputType | null
    _max: StakeholderOcationMaxAggregateOutputType | null
  }

  type GetStakeholderOcationGroupByPayload<T extends StakeholderOcationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakeholderOcationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakeholderOcationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakeholderOcationGroupByOutputType[P]>
            : GetScalarType<T[P], StakeholderOcationGroupByOutputType[P]>
        }
      >
    >


  export type StakeholderOcationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stakeId?: boolean
    ocationName?: boolean
    relation?: boolean
    personName?: boolean
    dob?: boolean
    otherInfo?: boolean
    stakeholder?: boolean | StakeholderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakeholderOcation"]>



  export type StakeholderOcationSelectScalar = {
    id?: boolean
    stakeId?: boolean
    ocationName?: boolean
    relation?: boolean
    personName?: boolean
    dob?: boolean
    otherInfo?: boolean
  }

  export type StakeholderOcationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stakeId" | "ocationName" | "relation" | "personName" | "dob" | "otherInfo", ExtArgs["result"]["stakeholderOcation"]>
  export type StakeholderOcationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholder?: boolean | StakeholderDefaultArgs<ExtArgs>
  }

  export type $StakeholderOcationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StakeholderOcation"
    objects: {
      stakeholder: Prisma.$StakeholderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stakeId: string
      ocationName: string
      relation: string
      personName: string | null
      dob: Date | null
      otherInfo: string | null
    }, ExtArgs["result"]["stakeholderOcation"]>
    composites: {}
  }

  type StakeholderOcationGetPayload<S extends boolean | null | undefined | StakeholderOcationDefaultArgs> = $Result.GetResult<Prisma.$StakeholderOcationPayload, S>

  type StakeholderOcationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StakeholderOcationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakeholderOcationCountAggregateInputType | true
    }

  export interface StakeholderOcationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StakeholderOcation'], meta: { name: 'StakeholderOcation' } }
    /**
     * Find zero or one StakeholderOcation that matches the filter.
     * @param {StakeholderOcationFindUniqueArgs} args - Arguments to find a StakeholderOcation
     * @example
     * // Get one StakeholderOcation
     * const stakeholderOcation = await prisma.stakeholderOcation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StakeholderOcationFindUniqueArgs>(args: SelectSubset<T, StakeholderOcationFindUniqueArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakeholderOcation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StakeholderOcationFindUniqueOrThrowArgs} args - Arguments to find a StakeholderOcation
     * @example
     * // Get one StakeholderOcation
     * const stakeholderOcation = await prisma.stakeholderOcation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StakeholderOcationFindUniqueOrThrowArgs>(args: SelectSubset<T, StakeholderOcationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderOcation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderOcationFindFirstArgs} args - Arguments to find a StakeholderOcation
     * @example
     * // Get one StakeholderOcation
     * const stakeholderOcation = await prisma.stakeholderOcation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StakeholderOcationFindFirstArgs>(args?: SelectSubset<T, StakeholderOcationFindFirstArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderOcation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderOcationFindFirstOrThrowArgs} args - Arguments to find a StakeholderOcation
     * @example
     * // Get one StakeholderOcation
     * const stakeholderOcation = await prisma.stakeholderOcation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StakeholderOcationFindFirstOrThrowArgs>(args?: SelectSubset<T, StakeholderOcationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakeholderOcations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderOcationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakeholderOcations
     * const stakeholderOcations = await prisma.stakeholderOcation.findMany()
     * 
     * // Get first 10 StakeholderOcations
     * const stakeholderOcations = await prisma.stakeholderOcation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stakeholderOcationWithIdOnly = await prisma.stakeholderOcation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StakeholderOcationFindManyArgs>(args?: SelectSubset<T, StakeholderOcationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakeholderOcation.
     * @param {StakeholderOcationCreateArgs} args - Arguments to create a StakeholderOcation.
     * @example
     * // Create one StakeholderOcation
     * const StakeholderOcation = await prisma.stakeholderOcation.create({
     *   data: {
     *     // ... data to create a StakeholderOcation
     *   }
     * })
     * 
     */
    create<T extends StakeholderOcationCreateArgs>(args: SelectSubset<T, StakeholderOcationCreateArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakeholderOcations.
     * @param {StakeholderOcationCreateManyArgs} args - Arguments to create many StakeholderOcations.
     * @example
     * // Create many StakeholderOcations
     * const stakeholderOcation = await prisma.stakeholderOcation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StakeholderOcationCreateManyArgs>(args?: SelectSubset<T, StakeholderOcationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StakeholderOcation.
     * @param {StakeholderOcationDeleteArgs} args - Arguments to delete one StakeholderOcation.
     * @example
     * // Delete one StakeholderOcation
     * const StakeholderOcation = await prisma.stakeholderOcation.delete({
     *   where: {
     *     // ... filter to delete one StakeholderOcation
     *   }
     * })
     * 
     */
    delete<T extends StakeholderOcationDeleteArgs>(args: SelectSubset<T, StakeholderOcationDeleteArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakeholderOcation.
     * @param {StakeholderOcationUpdateArgs} args - Arguments to update one StakeholderOcation.
     * @example
     * // Update one StakeholderOcation
     * const stakeholderOcation = await prisma.stakeholderOcation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StakeholderOcationUpdateArgs>(args: SelectSubset<T, StakeholderOcationUpdateArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakeholderOcations.
     * @param {StakeholderOcationDeleteManyArgs} args - Arguments to filter StakeholderOcations to delete.
     * @example
     * // Delete a few StakeholderOcations
     * const { count } = await prisma.stakeholderOcation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StakeholderOcationDeleteManyArgs>(args?: SelectSubset<T, StakeholderOcationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakeholderOcations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderOcationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakeholderOcations
     * const stakeholderOcation = await prisma.stakeholderOcation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StakeholderOcationUpdateManyArgs>(args: SelectSubset<T, StakeholderOcationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StakeholderOcation.
     * @param {StakeholderOcationUpsertArgs} args - Arguments to update or create a StakeholderOcation.
     * @example
     * // Update or create a StakeholderOcation
     * const stakeholderOcation = await prisma.stakeholderOcation.upsert({
     *   create: {
     *     // ... data to create a StakeholderOcation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakeholderOcation we want to update
     *   }
     * })
     */
    upsert<T extends StakeholderOcationUpsertArgs>(args: SelectSubset<T, StakeholderOcationUpsertArgs<ExtArgs>>): Prisma__StakeholderOcationClient<$Result.GetResult<Prisma.$StakeholderOcationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakeholderOcations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderOcationCountArgs} args - Arguments to filter StakeholderOcations to count.
     * @example
     * // Count the number of StakeholderOcations
     * const count = await prisma.stakeholderOcation.count({
     *   where: {
     *     // ... the filter for the StakeholderOcations we want to count
     *   }
     * })
    **/
    count<T extends StakeholderOcationCountArgs>(
      args?: Subset<T, StakeholderOcationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakeholderOcationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakeholderOcation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderOcationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakeholderOcationAggregateArgs>(args: Subset<T, StakeholderOcationAggregateArgs>): Prisma.PrismaPromise<GetStakeholderOcationAggregateType<T>>

    /**
     * Group by StakeholderOcation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderOcationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StakeholderOcationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StakeholderOcationGroupByArgs['orderBy'] }
        : { orderBy?: StakeholderOcationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StakeholderOcationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakeholderOcationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StakeholderOcation model
   */
  readonly fields: StakeholderOcationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StakeholderOcation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StakeholderOcationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stakeholder<T extends StakeholderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StakeholderDefaultArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StakeholderOcation model
   */
  interface StakeholderOcationFieldRefs {
    readonly id: FieldRef<"StakeholderOcation", 'Int'>
    readonly stakeId: FieldRef<"StakeholderOcation", 'String'>
    readonly ocationName: FieldRef<"StakeholderOcation", 'String'>
    readonly relation: FieldRef<"StakeholderOcation", 'String'>
    readonly personName: FieldRef<"StakeholderOcation", 'String'>
    readonly dob: FieldRef<"StakeholderOcation", 'DateTime'>
    readonly otherInfo: FieldRef<"StakeholderOcation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StakeholderOcation findUnique
   */
  export type StakeholderOcationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderOcation to fetch.
     */
    where: StakeholderOcationWhereUniqueInput
  }

  /**
   * StakeholderOcation findUniqueOrThrow
   */
  export type StakeholderOcationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderOcation to fetch.
     */
    where: StakeholderOcationWhereUniqueInput
  }

  /**
   * StakeholderOcation findFirst
   */
  export type StakeholderOcationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderOcation to fetch.
     */
    where?: StakeholderOcationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderOcations to fetch.
     */
    orderBy?: StakeholderOcationOrderByWithRelationInput | StakeholderOcationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakeholderOcations.
     */
    cursor?: StakeholderOcationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderOcations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderOcations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakeholderOcations.
     */
    distinct?: StakeholderOcationScalarFieldEnum | StakeholderOcationScalarFieldEnum[]
  }

  /**
   * StakeholderOcation findFirstOrThrow
   */
  export type StakeholderOcationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderOcation to fetch.
     */
    where?: StakeholderOcationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderOcations to fetch.
     */
    orderBy?: StakeholderOcationOrderByWithRelationInput | StakeholderOcationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StakeholderOcations.
     */
    cursor?: StakeholderOcationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderOcations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderOcations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StakeholderOcations.
     */
    distinct?: StakeholderOcationScalarFieldEnum | StakeholderOcationScalarFieldEnum[]
  }

  /**
   * StakeholderOcation findMany
   */
  export type StakeholderOcationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * Filter, which StakeholderOcations to fetch.
     */
    where?: StakeholderOcationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StakeholderOcations to fetch.
     */
    orderBy?: StakeholderOcationOrderByWithRelationInput | StakeholderOcationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StakeholderOcations.
     */
    cursor?: StakeholderOcationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StakeholderOcations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StakeholderOcations.
     */
    skip?: number
    distinct?: StakeholderOcationScalarFieldEnum | StakeholderOcationScalarFieldEnum[]
  }

  /**
   * StakeholderOcation create
   */
  export type StakeholderOcationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * The data needed to create a StakeholderOcation.
     */
    data: XOR<StakeholderOcationCreateInput, StakeholderOcationUncheckedCreateInput>
  }

  /**
   * StakeholderOcation createMany
   */
  export type StakeholderOcationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StakeholderOcations.
     */
    data: StakeholderOcationCreateManyInput | StakeholderOcationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StakeholderOcation update
   */
  export type StakeholderOcationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * The data needed to update a StakeholderOcation.
     */
    data: XOR<StakeholderOcationUpdateInput, StakeholderOcationUncheckedUpdateInput>
    /**
     * Choose, which StakeholderOcation to update.
     */
    where: StakeholderOcationWhereUniqueInput
  }

  /**
   * StakeholderOcation updateMany
   */
  export type StakeholderOcationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StakeholderOcations.
     */
    data: XOR<StakeholderOcationUpdateManyMutationInput, StakeholderOcationUncheckedUpdateManyInput>
    /**
     * Filter which StakeholderOcations to update
     */
    where?: StakeholderOcationWhereInput
    /**
     * Limit how many StakeholderOcations to update.
     */
    limit?: number
  }

  /**
   * StakeholderOcation upsert
   */
  export type StakeholderOcationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * The filter to search for the StakeholderOcation to update in case it exists.
     */
    where: StakeholderOcationWhereUniqueInput
    /**
     * In case the StakeholderOcation found by the `where` argument doesn't exist, create a new StakeholderOcation with this data.
     */
    create: XOR<StakeholderOcationCreateInput, StakeholderOcationUncheckedCreateInput>
    /**
     * In case the StakeholderOcation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StakeholderOcationUpdateInput, StakeholderOcationUncheckedUpdateInput>
  }

  /**
   * StakeholderOcation delete
   */
  export type StakeholderOcationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
    /**
     * Filter which StakeholderOcation to delete.
     */
    where: StakeholderOcationWhereUniqueInput
  }

  /**
   * StakeholderOcation deleteMany
   */
  export type StakeholderOcationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StakeholderOcations to delete
     */
    where?: StakeholderOcationWhereInput
    /**
     * Limit how many StakeholderOcations to delete.
     */
    limit?: number
  }

  /**
   * StakeholderOcation without action
   */
  export type StakeholderOcationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderOcation
     */
    select?: StakeholderOcationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StakeholderOcation
     */
    omit?: StakeholderOcationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderOcationInclude<ExtArgs> | null
  }


  /**
   * Model Customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    name: string | null
    contactNo: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contactNo: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    name: number
    contactNo: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    name?: true
    contactNo?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    name?: true
    contactNo?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    name?: true
    contactNo?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithAggregationInput | CustomersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: number
    name: string | null
    contactNo: string
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactNo?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionInfo?: boolean | Customers$transactionInfoArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>



  export type CustomersSelectScalar = {
    id?: boolean
    name?: boolean
    contactNo?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contactNo" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["customers"]>
  export type CustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionInfo?: boolean | Customers$transactionInfoArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customers"
    objects: {
      transactionInfo: Prisma.$TransactionInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      contactNo: string
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type CustomersGetPayload<S extends boolean | null | undefined | CustomersDefaultArgs> = $Result.GetResult<Prisma.$CustomersPayload, S>

  type CustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customers'], meta: { name: 'Customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomersFindUniqueArgs>(args: SelectSubset<T, CustomersFindUniqueArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomersFindFirstArgs>(args?: SelectSubset<T, CustomersFindFirstArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomersFindManyArgs>(args?: SelectSubset<T, CustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends CustomersCreateArgs>(args: SelectSubset<T, CustomersCreateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomersCreateManyArgs>(args?: SelectSubset<T, CustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends CustomersDeleteArgs>(args: SelectSubset<T, CustomersDeleteArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomersUpdateArgs>(args: SelectSubset<T, CustomersUpdateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomersDeleteManyArgs>(args?: SelectSubset<T, CustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomersUpdateManyArgs>(args: SelectSubset<T, CustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends CustomersUpsertArgs>(args: SelectSubset<T, CustomersUpsertArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customers model
   */
  readonly fields: CustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactionInfo<T extends Customers$transactionInfoArgs<ExtArgs> = {}>(args?: Subset<T, Customers$transactionInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customers model
   */
  interface CustomersFieldRefs {
    readonly id: FieldRef<"Customers", 'Int'>
    readonly name: FieldRef<"Customers", 'String'>
    readonly contactNo: FieldRef<"Customers", 'String'>
    readonly address: FieldRef<"Customers", 'String'>
    readonly createdAt: FieldRef<"Customers", 'DateTime'>
    readonly updatedAt: FieldRef<"Customers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers create
   */
  export type CustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }

  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customers update
   */
  export type CustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }

  /**
   * Customers delete
   */
  export type CustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customers.transactionInfo
   */
  export type Customers$transactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    where?: TransactionInfoWhereInput
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    cursor?: TransactionInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * Customers without action
   */
  export type CustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
  }


  /**
   * Model Scope
   */

  export type AggregateScope = {
    _count: ScopeCountAggregateOutputType | null
    _avg: ScopeAvgAggregateOutputType | null
    _sum: ScopeSumAggregateOutputType | null
    _min: ScopeMinAggregateOutputType | null
    _max: ScopeMaxAggregateOutputType | null
  }

  export type ScopeAvgAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type ScopeSumAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type ScopeMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScopeMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScopeCountAggregateOutputType = {
    id: number
    employeeId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScopeAvgAggregateInputType = {
    id?: true
    postId?: true
  }

  export type ScopeSumAggregateInputType = {
    id?: true
    postId?: true
  }

  export type ScopeMinAggregateInputType = {
    id?: true
    employeeId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScopeMaxAggregateInputType = {
    id?: true
    employeeId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScopeCountAggregateInputType = {
    id?: true
    employeeId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScopeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scope to aggregate.
     */
    where?: ScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scopes to fetch.
     */
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scopes
    **/
    _count?: true | ScopeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScopeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScopeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScopeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScopeMaxAggregateInputType
  }

  export type GetScopeAggregateType<T extends ScopeAggregateArgs> = {
        [P in keyof T & keyof AggregateScope]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScope[P]>
      : GetScalarType<T[P], AggregateScope[P]>
  }




  export type ScopeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScopeWhereInput
    orderBy?: ScopeOrderByWithAggregationInput | ScopeOrderByWithAggregationInput[]
    by: ScopeScalarFieldEnum[] | ScopeScalarFieldEnum
    having?: ScopeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScopeCountAggregateInputType | true
    _avg?: ScopeAvgAggregateInputType
    _sum?: ScopeSumAggregateInputType
    _min?: ScopeMinAggregateInputType
    _max?: ScopeMaxAggregateInputType
  }

  export type ScopeGroupByOutputType = {
    id: number
    employeeId: string
    postId: number
    createdAt: Date
    updatedAt: Date
    _count: ScopeCountAggregateOutputType | null
    _avg: ScopeAvgAggregateOutputType | null
    _sum: ScopeSumAggregateOutputType | null
    _min: ScopeMinAggregateOutputType | null
    _max: ScopeMaxAggregateOutputType | null
  }

  type GetScopeGroupByPayload<T extends ScopeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScopeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScopeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScopeGroupByOutputType[P]>
            : GetScalarType<T[P], ScopeGroupByOutputType[P]>
        }
      >
    >


  export type ScopeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chemist?: boolean | Scope$chemistArgs<ExtArgs>
    depo?: boolean | Scope$depoArgs<ExtArgs>
    stakeholder?: boolean | Scope$stakeholderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    _count?: boolean | ScopeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scope"]>



  export type ScopeSelectScalar = {
    id?: boolean
    employeeId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScopeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "postId" | "createdAt" | "updatedAt", ExtArgs["result"]["scope"]>
  export type ScopeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chemist?: boolean | Scope$chemistArgs<ExtArgs>
    depo?: boolean | Scope$depoArgs<ExtArgs>
    stakeholder?: boolean | Scope$stakeholderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    _count?: boolean | ScopeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ScopePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scope"
    objects: {
      chemist: Prisma.$ChemistPayload<ExtArgs>[]
      depo: Prisma.$DepoPayload<ExtArgs>[]
      stakeholder: Prisma.$StakeholderPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      jobPost: Prisma.$JobPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      postId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scope"]>
    composites: {}
  }

  type ScopeGetPayload<S extends boolean | null | undefined | ScopeDefaultArgs> = $Result.GetResult<Prisma.$ScopePayload, S>

  type ScopeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScopeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScopeCountAggregateInputType | true
    }

  export interface ScopeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scope'], meta: { name: 'Scope' } }
    /**
     * Find zero or one Scope that matches the filter.
     * @param {ScopeFindUniqueArgs} args - Arguments to find a Scope
     * @example
     * // Get one Scope
     * const scope = await prisma.scope.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScopeFindUniqueArgs>(args: SelectSubset<T, ScopeFindUniqueArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scope that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScopeFindUniqueOrThrowArgs} args - Arguments to find a Scope
     * @example
     * // Get one Scope
     * const scope = await prisma.scope.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScopeFindUniqueOrThrowArgs>(args: SelectSubset<T, ScopeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scope that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeFindFirstArgs} args - Arguments to find a Scope
     * @example
     * // Get one Scope
     * const scope = await prisma.scope.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScopeFindFirstArgs>(args?: SelectSubset<T, ScopeFindFirstArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scope that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeFindFirstOrThrowArgs} args - Arguments to find a Scope
     * @example
     * // Get one Scope
     * const scope = await prisma.scope.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScopeFindFirstOrThrowArgs>(args?: SelectSubset<T, ScopeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scopes
     * const scopes = await prisma.scope.findMany()
     * 
     * // Get first 10 Scopes
     * const scopes = await prisma.scope.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scopeWithIdOnly = await prisma.scope.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScopeFindManyArgs>(args?: SelectSubset<T, ScopeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scope.
     * @param {ScopeCreateArgs} args - Arguments to create a Scope.
     * @example
     * // Create one Scope
     * const Scope = await prisma.scope.create({
     *   data: {
     *     // ... data to create a Scope
     *   }
     * })
     * 
     */
    create<T extends ScopeCreateArgs>(args: SelectSubset<T, ScopeCreateArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scopes.
     * @param {ScopeCreateManyArgs} args - Arguments to create many Scopes.
     * @example
     * // Create many Scopes
     * const scope = await prisma.scope.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScopeCreateManyArgs>(args?: SelectSubset<T, ScopeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Scope.
     * @param {ScopeDeleteArgs} args - Arguments to delete one Scope.
     * @example
     * // Delete one Scope
     * const Scope = await prisma.scope.delete({
     *   where: {
     *     // ... filter to delete one Scope
     *   }
     * })
     * 
     */
    delete<T extends ScopeDeleteArgs>(args: SelectSubset<T, ScopeDeleteArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scope.
     * @param {ScopeUpdateArgs} args - Arguments to update one Scope.
     * @example
     * // Update one Scope
     * const scope = await prisma.scope.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScopeUpdateArgs>(args: SelectSubset<T, ScopeUpdateArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scopes.
     * @param {ScopeDeleteManyArgs} args - Arguments to filter Scopes to delete.
     * @example
     * // Delete a few Scopes
     * const { count } = await prisma.scope.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScopeDeleteManyArgs>(args?: SelectSubset<T, ScopeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scopes
     * const scope = await prisma.scope.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScopeUpdateManyArgs>(args: SelectSubset<T, ScopeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Scope.
     * @param {ScopeUpsertArgs} args - Arguments to update or create a Scope.
     * @example
     * // Update or create a Scope
     * const scope = await prisma.scope.upsert({
     *   create: {
     *     // ... data to create a Scope
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scope we want to update
     *   }
     * })
     */
    upsert<T extends ScopeUpsertArgs>(args: SelectSubset<T, ScopeUpsertArgs<ExtArgs>>): Prisma__ScopeClient<$Result.GetResult<Prisma.$ScopePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeCountArgs} args - Arguments to filter Scopes to count.
     * @example
     * // Count the number of Scopes
     * const count = await prisma.scope.count({
     *   where: {
     *     // ... the filter for the Scopes we want to count
     *   }
     * })
    **/
    count<T extends ScopeCountArgs>(
      args?: Subset<T, ScopeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScopeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScopeAggregateArgs>(args: Subset<T, ScopeAggregateArgs>): Prisma.PrismaPromise<GetScopeAggregateType<T>>

    /**
     * Group by Scope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScopeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScopeGroupByArgs['orderBy'] }
        : { orderBy?: ScopeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScopeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScopeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scope model
   */
  readonly fields: ScopeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scope.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScopeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chemist<T extends Scope$chemistArgs<ExtArgs> = {}>(args?: Subset<T, Scope$chemistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    depo<T extends Scope$depoArgs<ExtArgs> = {}>(args?: Subset<T, Scope$depoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stakeholder<T extends Scope$stakeholderArgs<ExtArgs> = {}>(args?: Subset<T, Scope$stakeholderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scope model
   */
  interface ScopeFieldRefs {
    readonly id: FieldRef<"Scope", 'Int'>
    readonly employeeId: FieldRef<"Scope", 'String'>
    readonly postId: FieldRef<"Scope", 'Int'>
    readonly createdAt: FieldRef<"Scope", 'DateTime'>
    readonly updatedAt: FieldRef<"Scope", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Scope findUnique
   */
  export type ScopeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * Filter, which Scope to fetch.
     */
    where: ScopeWhereUniqueInput
  }

  /**
   * Scope findUniqueOrThrow
   */
  export type ScopeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * Filter, which Scope to fetch.
     */
    where: ScopeWhereUniqueInput
  }

  /**
   * Scope findFirst
   */
  export type ScopeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * Filter, which Scope to fetch.
     */
    where?: ScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scopes to fetch.
     */
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scopes.
     */
    cursor?: ScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scopes.
     */
    distinct?: ScopeScalarFieldEnum | ScopeScalarFieldEnum[]
  }

  /**
   * Scope findFirstOrThrow
   */
  export type ScopeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * Filter, which Scope to fetch.
     */
    where?: ScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scopes to fetch.
     */
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scopes.
     */
    cursor?: ScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scopes.
     */
    distinct?: ScopeScalarFieldEnum | ScopeScalarFieldEnum[]
  }

  /**
   * Scope findMany
   */
  export type ScopeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * Filter, which Scopes to fetch.
     */
    where?: ScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scopes to fetch.
     */
    orderBy?: ScopeOrderByWithRelationInput | ScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scopes.
     */
    cursor?: ScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scopes.
     */
    skip?: number
    distinct?: ScopeScalarFieldEnum | ScopeScalarFieldEnum[]
  }

  /**
   * Scope create
   */
  export type ScopeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * The data needed to create a Scope.
     */
    data: XOR<ScopeCreateInput, ScopeUncheckedCreateInput>
  }

  /**
   * Scope createMany
   */
  export type ScopeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scopes.
     */
    data: ScopeCreateManyInput | ScopeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scope update
   */
  export type ScopeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * The data needed to update a Scope.
     */
    data: XOR<ScopeUpdateInput, ScopeUncheckedUpdateInput>
    /**
     * Choose, which Scope to update.
     */
    where: ScopeWhereUniqueInput
  }

  /**
   * Scope updateMany
   */
  export type ScopeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scopes.
     */
    data: XOR<ScopeUpdateManyMutationInput, ScopeUncheckedUpdateManyInput>
    /**
     * Filter which Scopes to update
     */
    where?: ScopeWhereInput
    /**
     * Limit how many Scopes to update.
     */
    limit?: number
  }

  /**
   * Scope upsert
   */
  export type ScopeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * The filter to search for the Scope to update in case it exists.
     */
    where: ScopeWhereUniqueInput
    /**
     * In case the Scope found by the `where` argument doesn't exist, create a new Scope with this data.
     */
    create: XOR<ScopeCreateInput, ScopeUncheckedCreateInput>
    /**
     * In case the Scope was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScopeUpdateInput, ScopeUncheckedUpdateInput>
  }

  /**
   * Scope delete
   */
  export type ScopeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
    /**
     * Filter which Scope to delete.
     */
    where: ScopeWhereUniqueInput
  }

  /**
   * Scope deleteMany
   */
  export type ScopeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scopes to delete
     */
    where?: ScopeWhereInput
    /**
     * Limit how many Scopes to delete.
     */
    limit?: number
  }

  /**
   * Scope.chemist
   */
  export type Scope$chemistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    where?: ChemistWhereInput
    orderBy?: ChemistOrderByWithRelationInput | ChemistOrderByWithRelationInput[]
    cursor?: ChemistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChemistScalarFieldEnum | ChemistScalarFieldEnum[]
  }

  /**
   * Scope.depo
   */
  export type Scope$depoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    where?: DepoWhereInput
    orderBy?: DepoOrderByWithRelationInput | DepoOrderByWithRelationInput[]
    cursor?: DepoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepoScalarFieldEnum | DepoScalarFieldEnum[]
  }

  /**
   * Scope.stakeholder
   */
  export type Scope$stakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    where?: StakeholderWhereInput
    orderBy?: StakeholderOrderByWithRelationInput | StakeholderOrderByWithRelationInput[]
    cursor?: StakeholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StakeholderScalarFieldEnum | StakeholderScalarFieldEnum[]
  }

  /**
   * Scope without action
   */
  export type ScopeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scope
     */
    select?: ScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scope
     */
    omit?: ScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeInclude<ExtArgs> | null
  }


  /**
   * Model MpoTarget
   */

  export type AggregateMpoTarget = {
    _count: MpoTargetCountAggregateOutputType | null
    _avg: MpoTargetAvgAggregateOutputType | null
    _sum: MpoTargetSumAggregateOutputType | null
    _min: MpoTargetMinAggregateOutputType | null
    _max: MpoTargetMaxAggregateOutputType | null
  }

  export type MpoTargetAvgAggregateOutputType = {
    id: number | null
    tergatAmount: number | null
  }

  export type MpoTargetSumAggregateOutputType = {
    id: number | null
    tergatAmount: number | null
  }

  export type MpoTargetMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    month: string | null
    tergatAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MpoTargetMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    month: string | null
    tergatAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MpoTargetCountAggregateOutputType = {
    id: number
    employeeId: number
    month: number
    tergatAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MpoTargetAvgAggregateInputType = {
    id?: true
    tergatAmount?: true
  }

  export type MpoTargetSumAggregateInputType = {
    id?: true
    tergatAmount?: true
  }

  export type MpoTargetMinAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    tergatAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MpoTargetMaxAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    tergatAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MpoTargetCountAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    tergatAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MpoTargetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MpoTarget to aggregate.
     */
    where?: MpoTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpoTargets to fetch.
     */
    orderBy?: MpoTargetOrderByWithRelationInput | MpoTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MpoTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpoTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpoTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MpoTargets
    **/
    _count?: true | MpoTargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MpoTargetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MpoTargetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MpoTargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MpoTargetMaxAggregateInputType
  }

  export type GetMpoTargetAggregateType<T extends MpoTargetAggregateArgs> = {
        [P in keyof T & keyof AggregateMpoTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMpoTarget[P]>
      : GetScalarType<T[P], AggregateMpoTarget[P]>
  }




  export type MpoTargetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MpoTargetWhereInput
    orderBy?: MpoTargetOrderByWithAggregationInput | MpoTargetOrderByWithAggregationInput[]
    by: MpoTargetScalarFieldEnum[] | MpoTargetScalarFieldEnum
    having?: MpoTargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MpoTargetCountAggregateInputType | true
    _avg?: MpoTargetAvgAggregateInputType
    _sum?: MpoTargetSumAggregateInputType
    _min?: MpoTargetMinAggregateInputType
    _max?: MpoTargetMaxAggregateInputType
  }

  export type MpoTargetGroupByOutputType = {
    id: number
    employeeId: string
    month: string
    tergatAmount: number
    createdAt: Date
    updatedAt: Date
    _count: MpoTargetCountAggregateOutputType | null
    _avg: MpoTargetAvgAggregateOutputType | null
    _sum: MpoTargetSumAggregateOutputType | null
    _min: MpoTargetMinAggregateOutputType | null
    _max: MpoTargetMaxAggregateOutputType | null
  }

  type GetMpoTargetGroupByPayload<T extends MpoTargetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MpoTargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MpoTargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MpoTargetGroupByOutputType[P]>
            : GetScalarType<T[P], MpoTargetGroupByOutputType[P]>
        }
      >
    >


  export type MpoTargetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    month?: boolean
    tergatAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mpoTarget"]>



  export type MpoTargetSelectScalar = {
    id?: boolean
    employeeId?: boolean
    month?: boolean
    tergatAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MpoTargetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "month" | "tergatAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["mpoTarget"]>
  export type MpoTargetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MpoTargetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MpoTarget"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      month: string
      tergatAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mpoTarget"]>
    composites: {}
  }

  type MpoTargetGetPayload<S extends boolean | null | undefined | MpoTargetDefaultArgs> = $Result.GetResult<Prisma.$MpoTargetPayload, S>

  type MpoTargetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MpoTargetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MpoTargetCountAggregateInputType | true
    }

  export interface MpoTargetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MpoTarget'], meta: { name: 'MpoTarget' } }
    /**
     * Find zero or one MpoTarget that matches the filter.
     * @param {MpoTargetFindUniqueArgs} args - Arguments to find a MpoTarget
     * @example
     * // Get one MpoTarget
     * const mpoTarget = await prisma.mpoTarget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MpoTargetFindUniqueArgs>(args: SelectSubset<T, MpoTargetFindUniqueArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MpoTarget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MpoTargetFindUniqueOrThrowArgs} args - Arguments to find a MpoTarget
     * @example
     * // Get one MpoTarget
     * const mpoTarget = await prisma.mpoTarget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MpoTargetFindUniqueOrThrowArgs>(args: SelectSubset<T, MpoTargetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MpoTarget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpoTargetFindFirstArgs} args - Arguments to find a MpoTarget
     * @example
     * // Get one MpoTarget
     * const mpoTarget = await prisma.mpoTarget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MpoTargetFindFirstArgs>(args?: SelectSubset<T, MpoTargetFindFirstArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MpoTarget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpoTargetFindFirstOrThrowArgs} args - Arguments to find a MpoTarget
     * @example
     * // Get one MpoTarget
     * const mpoTarget = await prisma.mpoTarget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MpoTargetFindFirstOrThrowArgs>(args?: SelectSubset<T, MpoTargetFindFirstOrThrowArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MpoTargets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpoTargetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MpoTargets
     * const mpoTargets = await prisma.mpoTarget.findMany()
     * 
     * // Get first 10 MpoTargets
     * const mpoTargets = await prisma.mpoTarget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mpoTargetWithIdOnly = await prisma.mpoTarget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MpoTargetFindManyArgs>(args?: SelectSubset<T, MpoTargetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MpoTarget.
     * @param {MpoTargetCreateArgs} args - Arguments to create a MpoTarget.
     * @example
     * // Create one MpoTarget
     * const MpoTarget = await prisma.mpoTarget.create({
     *   data: {
     *     // ... data to create a MpoTarget
     *   }
     * })
     * 
     */
    create<T extends MpoTargetCreateArgs>(args: SelectSubset<T, MpoTargetCreateArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MpoTargets.
     * @param {MpoTargetCreateManyArgs} args - Arguments to create many MpoTargets.
     * @example
     * // Create many MpoTargets
     * const mpoTarget = await prisma.mpoTarget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MpoTargetCreateManyArgs>(args?: SelectSubset<T, MpoTargetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MpoTarget.
     * @param {MpoTargetDeleteArgs} args - Arguments to delete one MpoTarget.
     * @example
     * // Delete one MpoTarget
     * const MpoTarget = await prisma.mpoTarget.delete({
     *   where: {
     *     // ... filter to delete one MpoTarget
     *   }
     * })
     * 
     */
    delete<T extends MpoTargetDeleteArgs>(args: SelectSubset<T, MpoTargetDeleteArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MpoTarget.
     * @param {MpoTargetUpdateArgs} args - Arguments to update one MpoTarget.
     * @example
     * // Update one MpoTarget
     * const mpoTarget = await prisma.mpoTarget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MpoTargetUpdateArgs>(args: SelectSubset<T, MpoTargetUpdateArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MpoTargets.
     * @param {MpoTargetDeleteManyArgs} args - Arguments to filter MpoTargets to delete.
     * @example
     * // Delete a few MpoTargets
     * const { count } = await prisma.mpoTarget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MpoTargetDeleteManyArgs>(args?: SelectSubset<T, MpoTargetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MpoTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpoTargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MpoTargets
     * const mpoTarget = await prisma.mpoTarget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MpoTargetUpdateManyArgs>(args: SelectSubset<T, MpoTargetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MpoTarget.
     * @param {MpoTargetUpsertArgs} args - Arguments to update or create a MpoTarget.
     * @example
     * // Update or create a MpoTarget
     * const mpoTarget = await prisma.mpoTarget.upsert({
     *   create: {
     *     // ... data to create a MpoTarget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MpoTarget we want to update
     *   }
     * })
     */
    upsert<T extends MpoTargetUpsertArgs>(args: SelectSubset<T, MpoTargetUpsertArgs<ExtArgs>>): Prisma__MpoTargetClient<$Result.GetResult<Prisma.$MpoTargetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MpoTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpoTargetCountArgs} args - Arguments to filter MpoTargets to count.
     * @example
     * // Count the number of MpoTargets
     * const count = await prisma.mpoTarget.count({
     *   where: {
     *     // ... the filter for the MpoTargets we want to count
     *   }
     * })
    **/
    count<T extends MpoTargetCountArgs>(
      args?: Subset<T, MpoTargetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MpoTargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MpoTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpoTargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MpoTargetAggregateArgs>(args: Subset<T, MpoTargetAggregateArgs>): Prisma.PrismaPromise<GetMpoTargetAggregateType<T>>

    /**
     * Group by MpoTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpoTargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MpoTargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MpoTargetGroupByArgs['orderBy'] }
        : { orderBy?: MpoTargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MpoTargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMpoTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MpoTarget model
   */
  readonly fields: MpoTargetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MpoTarget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MpoTargetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MpoTarget model
   */
  interface MpoTargetFieldRefs {
    readonly id: FieldRef<"MpoTarget", 'Int'>
    readonly employeeId: FieldRef<"MpoTarget", 'String'>
    readonly month: FieldRef<"MpoTarget", 'String'>
    readonly tergatAmount: FieldRef<"MpoTarget", 'Int'>
    readonly createdAt: FieldRef<"MpoTarget", 'DateTime'>
    readonly updatedAt: FieldRef<"MpoTarget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MpoTarget findUnique
   */
  export type MpoTargetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * Filter, which MpoTarget to fetch.
     */
    where: MpoTargetWhereUniqueInput
  }

  /**
   * MpoTarget findUniqueOrThrow
   */
  export type MpoTargetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * Filter, which MpoTarget to fetch.
     */
    where: MpoTargetWhereUniqueInput
  }

  /**
   * MpoTarget findFirst
   */
  export type MpoTargetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * Filter, which MpoTarget to fetch.
     */
    where?: MpoTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpoTargets to fetch.
     */
    orderBy?: MpoTargetOrderByWithRelationInput | MpoTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MpoTargets.
     */
    cursor?: MpoTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpoTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpoTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MpoTargets.
     */
    distinct?: MpoTargetScalarFieldEnum | MpoTargetScalarFieldEnum[]
  }

  /**
   * MpoTarget findFirstOrThrow
   */
  export type MpoTargetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * Filter, which MpoTarget to fetch.
     */
    where?: MpoTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpoTargets to fetch.
     */
    orderBy?: MpoTargetOrderByWithRelationInput | MpoTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MpoTargets.
     */
    cursor?: MpoTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpoTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpoTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MpoTargets.
     */
    distinct?: MpoTargetScalarFieldEnum | MpoTargetScalarFieldEnum[]
  }

  /**
   * MpoTarget findMany
   */
  export type MpoTargetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * Filter, which MpoTargets to fetch.
     */
    where?: MpoTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpoTargets to fetch.
     */
    orderBy?: MpoTargetOrderByWithRelationInput | MpoTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MpoTargets.
     */
    cursor?: MpoTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpoTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpoTargets.
     */
    skip?: number
    distinct?: MpoTargetScalarFieldEnum | MpoTargetScalarFieldEnum[]
  }

  /**
   * MpoTarget create
   */
  export type MpoTargetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * The data needed to create a MpoTarget.
     */
    data: XOR<MpoTargetCreateInput, MpoTargetUncheckedCreateInput>
  }

  /**
   * MpoTarget createMany
   */
  export type MpoTargetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MpoTargets.
     */
    data: MpoTargetCreateManyInput | MpoTargetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MpoTarget update
   */
  export type MpoTargetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * The data needed to update a MpoTarget.
     */
    data: XOR<MpoTargetUpdateInput, MpoTargetUncheckedUpdateInput>
    /**
     * Choose, which MpoTarget to update.
     */
    where: MpoTargetWhereUniqueInput
  }

  /**
   * MpoTarget updateMany
   */
  export type MpoTargetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MpoTargets.
     */
    data: XOR<MpoTargetUpdateManyMutationInput, MpoTargetUncheckedUpdateManyInput>
    /**
     * Filter which MpoTargets to update
     */
    where?: MpoTargetWhereInput
    /**
     * Limit how many MpoTargets to update.
     */
    limit?: number
  }

  /**
   * MpoTarget upsert
   */
  export type MpoTargetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * The filter to search for the MpoTarget to update in case it exists.
     */
    where: MpoTargetWhereUniqueInput
    /**
     * In case the MpoTarget found by the `where` argument doesn't exist, create a new MpoTarget with this data.
     */
    create: XOR<MpoTargetCreateInput, MpoTargetUncheckedCreateInput>
    /**
     * In case the MpoTarget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MpoTargetUpdateInput, MpoTargetUncheckedUpdateInput>
  }

  /**
   * MpoTarget delete
   */
  export type MpoTargetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
    /**
     * Filter which MpoTarget to delete.
     */
    where: MpoTargetWhereUniqueInput
  }

  /**
   * MpoTarget deleteMany
   */
  export type MpoTargetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MpoTargets to delete
     */
    where?: MpoTargetWhereInput
    /**
     * Limit how many MpoTargets to delete.
     */
    limit?: number
  }

  /**
   * MpoTarget without action
   */
  export type MpoTargetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpoTarget
     */
    select?: MpoTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MpoTarget
     */
    omit?: MpoTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MpoTargetInclude<ExtArgs> | null
  }


  /**
   * Model ProductWiseTarget
   */

  export type AggregateProductWiseTarget = {
    _count: ProductWiseTargetCountAggregateOutputType | null
    _avg: ProductWiseTargetAvgAggregateOutputType | null
    _sum: ProductWiseTargetSumAggregateOutputType | null
    _min: ProductWiseTargetMinAggregateOutputType | null
    _max: ProductWiseTargetMaxAggregateOutputType | null
  }

  export type ProductWiseTargetAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductWiseTargetSumAggregateOutputType = {
    id: number | null
  }

  export type ProductWiseTargetMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    targetStart: Date | null
    targetEnd: Date | null
    targetType: $Enums.TargetType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductWiseTargetMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    targetStart: Date | null
    targetEnd: Date | null
    targetType: $Enums.TargetType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductWiseTargetCountAggregateOutputType = {
    id: number
    employeeId: number
    targetStart: number
    targetEnd: number
    targetType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductWiseTargetAvgAggregateInputType = {
    id?: true
  }

  export type ProductWiseTargetSumAggregateInputType = {
    id?: true
  }

  export type ProductWiseTargetMinAggregateInputType = {
    id?: true
    employeeId?: true
    targetStart?: true
    targetEnd?: true
    targetType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductWiseTargetMaxAggregateInputType = {
    id?: true
    employeeId?: true
    targetStart?: true
    targetEnd?: true
    targetType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductWiseTargetCountAggregateInputType = {
    id?: true
    employeeId?: true
    targetStart?: true
    targetEnd?: true
    targetType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductWiseTargetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductWiseTarget to aggregate.
     */
    where?: ProductWiseTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWiseTargets to fetch.
     */
    orderBy?: ProductWiseTargetOrderByWithRelationInput | ProductWiseTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWiseTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWiseTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWiseTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductWiseTargets
    **/
    _count?: true | ProductWiseTargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductWiseTargetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductWiseTargetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductWiseTargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductWiseTargetMaxAggregateInputType
  }

  export type GetProductWiseTargetAggregateType<T extends ProductWiseTargetAggregateArgs> = {
        [P in keyof T & keyof AggregateProductWiseTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductWiseTarget[P]>
      : GetScalarType<T[P], AggregateProductWiseTarget[P]>
  }




  export type ProductWiseTargetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWiseTargetWhereInput
    orderBy?: ProductWiseTargetOrderByWithAggregationInput | ProductWiseTargetOrderByWithAggregationInput[]
    by: ProductWiseTargetScalarFieldEnum[] | ProductWiseTargetScalarFieldEnum
    having?: ProductWiseTargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductWiseTargetCountAggregateInputType | true
    _avg?: ProductWiseTargetAvgAggregateInputType
    _sum?: ProductWiseTargetSumAggregateInputType
    _min?: ProductWiseTargetMinAggregateInputType
    _max?: ProductWiseTargetMaxAggregateInputType
  }

  export type ProductWiseTargetGroupByOutputType = {
    id: number
    employeeId: string
    targetStart: Date
    targetEnd: Date
    targetType: $Enums.TargetType
    createdAt: Date
    updatedAt: Date
    _count: ProductWiseTargetCountAggregateOutputType | null
    _avg: ProductWiseTargetAvgAggregateOutputType | null
    _sum: ProductWiseTargetSumAggregateOutputType | null
    _min: ProductWiseTargetMinAggregateOutputType | null
    _max: ProductWiseTargetMaxAggregateOutputType | null
  }

  type GetProductWiseTargetGroupByPayload<T extends ProductWiseTargetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductWiseTargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductWiseTargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductWiseTargetGroupByOutputType[P]>
            : GetScalarType<T[P], ProductWiseTargetGroupByOutputType[P]>
        }
      >
    >


  export type ProductWiseTargetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    targetStart?: boolean
    targetEnd?: boolean
    targetType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    targetProductBatch?: boolean | ProductWiseTarget$targetProductBatchArgs<ExtArgs>
    _count?: boolean | ProductWiseTargetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productWiseTarget"]>



  export type ProductWiseTargetSelectScalar = {
    id?: boolean
    employeeId?: boolean
    targetStart?: boolean
    targetEnd?: boolean
    targetType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductWiseTargetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "targetStart" | "targetEnd" | "targetType" | "createdAt" | "updatedAt", ExtArgs["result"]["productWiseTarget"]>
  export type ProductWiseTargetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    targetProductBatch?: boolean | ProductWiseTarget$targetProductBatchArgs<ExtArgs>
    _count?: boolean | ProductWiseTargetCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductWiseTargetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductWiseTarget"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      targetProductBatch: Prisma.$TargetProductBatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      targetStart: Date
      targetEnd: Date
      targetType: $Enums.TargetType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productWiseTarget"]>
    composites: {}
  }

  type ProductWiseTargetGetPayload<S extends boolean | null | undefined | ProductWiseTargetDefaultArgs> = $Result.GetResult<Prisma.$ProductWiseTargetPayload, S>

  type ProductWiseTargetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductWiseTargetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductWiseTargetCountAggregateInputType | true
    }

  export interface ProductWiseTargetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductWiseTarget'], meta: { name: 'ProductWiseTarget' } }
    /**
     * Find zero or one ProductWiseTarget that matches the filter.
     * @param {ProductWiseTargetFindUniqueArgs} args - Arguments to find a ProductWiseTarget
     * @example
     * // Get one ProductWiseTarget
     * const productWiseTarget = await prisma.productWiseTarget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductWiseTargetFindUniqueArgs>(args: SelectSubset<T, ProductWiseTargetFindUniqueArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductWiseTarget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductWiseTargetFindUniqueOrThrowArgs} args - Arguments to find a ProductWiseTarget
     * @example
     * // Get one ProductWiseTarget
     * const productWiseTarget = await prisma.productWiseTarget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductWiseTargetFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductWiseTargetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductWiseTarget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWiseTargetFindFirstArgs} args - Arguments to find a ProductWiseTarget
     * @example
     * // Get one ProductWiseTarget
     * const productWiseTarget = await prisma.productWiseTarget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductWiseTargetFindFirstArgs>(args?: SelectSubset<T, ProductWiseTargetFindFirstArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductWiseTarget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWiseTargetFindFirstOrThrowArgs} args - Arguments to find a ProductWiseTarget
     * @example
     * // Get one ProductWiseTarget
     * const productWiseTarget = await prisma.productWiseTarget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductWiseTargetFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductWiseTargetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductWiseTargets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWiseTargetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductWiseTargets
     * const productWiseTargets = await prisma.productWiseTarget.findMany()
     * 
     * // Get first 10 ProductWiseTargets
     * const productWiseTargets = await prisma.productWiseTarget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWiseTargetWithIdOnly = await prisma.productWiseTarget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductWiseTargetFindManyArgs>(args?: SelectSubset<T, ProductWiseTargetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductWiseTarget.
     * @param {ProductWiseTargetCreateArgs} args - Arguments to create a ProductWiseTarget.
     * @example
     * // Create one ProductWiseTarget
     * const ProductWiseTarget = await prisma.productWiseTarget.create({
     *   data: {
     *     // ... data to create a ProductWiseTarget
     *   }
     * })
     * 
     */
    create<T extends ProductWiseTargetCreateArgs>(args: SelectSubset<T, ProductWiseTargetCreateArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductWiseTargets.
     * @param {ProductWiseTargetCreateManyArgs} args - Arguments to create many ProductWiseTargets.
     * @example
     * // Create many ProductWiseTargets
     * const productWiseTarget = await prisma.productWiseTarget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductWiseTargetCreateManyArgs>(args?: SelectSubset<T, ProductWiseTargetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductWiseTarget.
     * @param {ProductWiseTargetDeleteArgs} args - Arguments to delete one ProductWiseTarget.
     * @example
     * // Delete one ProductWiseTarget
     * const ProductWiseTarget = await prisma.productWiseTarget.delete({
     *   where: {
     *     // ... filter to delete one ProductWiseTarget
     *   }
     * })
     * 
     */
    delete<T extends ProductWiseTargetDeleteArgs>(args: SelectSubset<T, ProductWiseTargetDeleteArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductWiseTarget.
     * @param {ProductWiseTargetUpdateArgs} args - Arguments to update one ProductWiseTarget.
     * @example
     * // Update one ProductWiseTarget
     * const productWiseTarget = await prisma.productWiseTarget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductWiseTargetUpdateArgs>(args: SelectSubset<T, ProductWiseTargetUpdateArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductWiseTargets.
     * @param {ProductWiseTargetDeleteManyArgs} args - Arguments to filter ProductWiseTargets to delete.
     * @example
     * // Delete a few ProductWiseTargets
     * const { count } = await prisma.productWiseTarget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductWiseTargetDeleteManyArgs>(args?: SelectSubset<T, ProductWiseTargetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductWiseTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWiseTargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductWiseTargets
     * const productWiseTarget = await prisma.productWiseTarget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductWiseTargetUpdateManyArgs>(args: SelectSubset<T, ProductWiseTargetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductWiseTarget.
     * @param {ProductWiseTargetUpsertArgs} args - Arguments to update or create a ProductWiseTarget.
     * @example
     * // Update or create a ProductWiseTarget
     * const productWiseTarget = await prisma.productWiseTarget.upsert({
     *   create: {
     *     // ... data to create a ProductWiseTarget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductWiseTarget we want to update
     *   }
     * })
     */
    upsert<T extends ProductWiseTargetUpsertArgs>(args: SelectSubset<T, ProductWiseTargetUpsertArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductWiseTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWiseTargetCountArgs} args - Arguments to filter ProductWiseTargets to count.
     * @example
     * // Count the number of ProductWiseTargets
     * const count = await prisma.productWiseTarget.count({
     *   where: {
     *     // ... the filter for the ProductWiseTargets we want to count
     *   }
     * })
    **/
    count<T extends ProductWiseTargetCountArgs>(
      args?: Subset<T, ProductWiseTargetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductWiseTargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductWiseTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWiseTargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductWiseTargetAggregateArgs>(args: Subset<T, ProductWiseTargetAggregateArgs>): Prisma.PrismaPromise<GetProductWiseTargetAggregateType<T>>

    /**
     * Group by ProductWiseTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWiseTargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductWiseTargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductWiseTargetGroupByArgs['orderBy'] }
        : { orderBy?: ProductWiseTargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductWiseTargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductWiseTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductWiseTarget model
   */
  readonly fields: ProductWiseTargetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductWiseTarget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductWiseTargetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetProductBatch<T extends ProductWiseTarget$targetProductBatchArgs<ExtArgs> = {}>(args?: Subset<T, ProductWiseTarget$targetProductBatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductWiseTarget model
   */
  interface ProductWiseTargetFieldRefs {
    readonly id: FieldRef<"ProductWiseTarget", 'Int'>
    readonly employeeId: FieldRef<"ProductWiseTarget", 'String'>
    readonly targetStart: FieldRef<"ProductWiseTarget", 'DateTime'>
    readonly targetEnd: FieldRef<"ProductWiseTarget", 'DateTime'>
    readonly targetType: FieldRef<"ProductWiseTarget", 'TargetType'>
    readonly createdAt: FieldRef<"ProductWiseTarget", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductWiseTarget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductWiseTarget findUnique
   */
  export type ProductWiseTargetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * Filter, which ProductWiseTarget to fetch.
     */
    where: ProductWiseTargetWhereUniqueInput
  }

  /**
   * ProductWiseTarget findUniqueOrThrow
   */
  export type ProductWiseTargetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * Filter, which ProductWiseTarget to fetch.
     */
    where: ProductWiseTargetWhereUniqueInput
  }

  /**
   * ProductWiseTarget findFirst
   */
  export type ProductWiseTargetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * Filter, which ProductWiseTarget to fetch.
     */
    where?: ProductWiseTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWiseTargets to fetch.
     */
    orderBy?: ProductWiseTargetOrderByWithRelationInput | ProductWiseTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductWiseTargets.
     */
    cursor?: ProductWiseTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWiseTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWiseTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductWiseTargets.
     */
    distinct?: ProductWiseTargetScalarFieldEnum | ProductWiseTargetScalarFieldEnum[]
  }

  /**
   * ProductWiseTarget findFirstOrThrow
   */
  export type ProductWiseTargetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * Filter, which ProductWiseTarget to fetch.
     */
    where?: ProductWiseTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWiseTargets to fetch.
     */
    orderBy?: ProductWiseTargetOrderByWithRelationInput | ProductWiseTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductWiseTargets.
     */
    cursor?: ProductWiseTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWiseTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWiseTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductWiseTargets.
     */
    distinct?: ProductWiseTargetScalarFieldEnum | ProductWiseTargetScalarFieldEnum[]
  }

  /**
   * ProductWiseTarget findMany
   */
  export type ProductWiseTargetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * Filter, which ProductWiseTargets to fetch.
     */
    where?: ProductWiseTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWiseTargets to fetch.
     */
    orderBy?: ProductWiseTargetOrderByWithRelationInput | ProductWiseTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductWiseTargets.
     */
    cursor?: ProductWiseTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWiseTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWiseTargets.
     */
    skip?: number
    distinct?: ProductWiseTargetScalarFieldEnum | ProductWiseTargetScalarFieldEnum[]
  }

  /**
   * ProductWiseTarget create
   */
  export type ProductWiseTargetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductWiseTarget.
     */
    data: XOR<ProductWiseTargetCreateInput, ProductWiseTargetUncheckedCreateInput>
  }

  /**
   * ProductWiseTarget createMany
   */
  export type ProductWiseTargetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductWiseTargets.
     */
    data: ProductWiseTargetCreateManyInput | ProductWiseTargetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductWiseTarget update
   */
  export type ProductWiseTargetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductWiseTarget.
     */
    data: XOR<ProductWiseTargetUpdateInput, ProductWiseTargetUncheckedUpdateInput>
    /**
     * Choose, which ProductWiseTarget to update.
     */
    where: ProductWiseTargetWhereUniqueInput
  }

  /**
   * ProductWiseTarget updateMany
   */
  export type ProductWiseTargetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductWiseTargets.
     */
    data: XOR<ProductWiseTargetUpdateManyMutationInput, ProductWiseTargetUncheckedUpdateManyInput>
    /**
     * Filter which ProductWiseTargets to update
     */
    where?: ProductWiseTargetWhereInput
    /**
     * Limit how many ProductWiseTargets to update.
     */
    limit?: number
  }

  /**
   * ProductWiseTarget upsert
   */
  export type ProductWiseTargetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductWiseTarget to update in case it exists.
     */
    where: ProductWiseTargetWhereUniqueInput
    /**
     * In case the ProductWiseTarget found by the `where` argument doesn't exist, create a new ProductWiseTarget with this data.
     */
    create: XOR<ProductWiseTargetCreateInput, ProductWiseTargetUncheckedCreateInput>
    /**
     * In case the ProductWiseTarget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductWiseTargetUpdateInput, ProductWiseTargetUncheckedUpdateInput>
  }

  /**
   * ProductWiseTarget delete
   */
  export type ProductWiseTargetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
    /**
     * Filter which ProductWiseTarget to delete.
     */
    where: ProductWiseTargetWhereUniqueInput
  }

  /**
   * ProductWiseTarget deleteMany
   */
  export type ProductWiseTargetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductWiseTargets to delete
     */
    where?: ProductWiseTargetWhereInput
    /**
     * Limit how many ProductWiseTargets to delete.
     */
    limit?: number
  }

  /**
   * ProductWiseTarget.targetProductBatch
   */
  export type ProductWiseTarget$targetProductBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    where?: TargetProductBatchWhereInput
    orderBy?: TargetProductBatchOrderByWithRelationInput | TargetProductBatchOrderByWithRelationInput[]
    cursor?: TargetProductBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TargetProductBatchScalarFieldEnum | TargetProductBatchScalarFieldEnum[]
  }

  /**
   * ProductWiseTarget without action
   */
  export type ProductWiseTargetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWiseTarget
     */
    select?: ProductWiseTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWiseTarget
     */
    omit?: ProductWiseTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductWiseTargetInclude<ExtArgs> | null
  }


  /**
   * Model TargetProductBatch
   */

  export type AggregateTargetProductBatch = {
    _count: TargetProductBatchCountAggregateOutputType | null
    _avg: TargetProductBatchAvgAggregateOutputType | null
    _sum: TargetProductBatchSumAggregateOutputType | null
    _min: TargetProductBatchMinAggregateOutputType | null
    _max: TargetProductBatchMaxAggregateOutputType | null
  }

  export type TargetProductBatchAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    productTargetId: number | null
    numberOfProduct: number | null
    insentiveAmount: number | null
  }

  export type TargetProductBatchSumAggregateOutputType = {
    id: number | null
    productId: number | null
    productTargetId: number | null
    numberOfProduct: number | null
    insentiveAmount: number | null
  }

  export type TargetProductBatchMinAggregateOutputType = {
    id: number | null
    productId: number | null
    productTargetId: number | null
    numberOfProduct: number | null
    insentiveAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TargetProductBatchMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    productTargetId: number | null
    numberOfProduct: number | null
    insentiveAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TargetProductBatchCountAggregateOutputType = {
    id: number
    productId: number
    productTargetId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TargetProductBatchAvgAggregateInputType = {
    id?: true
    productId?: true
    productTargetId?: true
    numberOfProduct?: true
    insentiveAmount?: true
  }

  export type TargetProductBatchSumAggregateInputType = {
    id?: true
    productId?: true
    productTargetId?: true
    numberOfProduct?: true
    insentiveAmount?: true
  }

  export type TargetProductBatchMinAggregateInputType = {
    id?: true
    productId?: true
    productTargetId?: true
    numberOfProduct?: true
    insentiveAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TargetProductBatchMaxAggregateInputType = {
    id?: true
    productId?: true
    productTargetId?: true
    numberOfProduct?: true
    insentiveAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TargetProductBatchCountAggregateInputType = {
    id?: true
    productId?: true
    productTargetId?: true
    numberOfProduct?: true
    insentiveAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TargetProductBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetProductBatch to aggregate.
     */
    where?: TargetProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetProductBatches to fetch.
     */
    orderBy?: TargetProductBatchOrderByWithRelationInput | TargetProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TargetProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TargetProductBatches
    **/
    _count?: true | TargetProductBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TargetProductBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TargetProductBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TargetProductBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TargetProductBatchMaxAggregateInputType
  }

  export type GetTargetProductBatchAggregateType<T extends TargetProductBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateTargetProductBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTargetProductBatch[P]>
      : GetScalarType<T[P], AggregateTargetProductBatch[P]>
  }




  export type TargetProductBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetProductBatchWhereInput
    orderBy?: TargetProductBatchOrderByWithAggregationInput | TargetProductBatchOrderByWithAggregationInput[]
    by: TargetProductBatchScalarFieldEnum[] | TargetProductBatchScalarFieldEnum
    having?: TargetProductBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TargetProductBatchCountAggregateInputType | true
    _avg?: TargetProductBatchAvgAggregateInputType
    _sum?: TargetProductBatchSumAggregateInputType
    _min?: TargetProductBatchMinAggregateInputType
    _max?: TargetProductBatchMaxAggregateInputType
  }

  export type TargetProductBatchGroupByOutputType = {
    id: number
    productId: number
    productTargetId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt: Date
    updatedAt: Date
    _count: TargetProductBatchCountAggregateOutputType | null
    _avg: TargetProductBatchAvgAggregateOutputType | null
    _sum: TargetProductBatchSumAggregateOutputType | null
    _min: TargetProductBatchMinAggregateOutputType | null
    _max: TargetProductBatchMaxAggregateOutputType | null
  }

  type GetTargetProductBatchGroupByPayload<T extends TargetProductBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TargetProductBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TargetProductBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TargetProductBatchGroupByOutputType[P]>
            : GetScalarType<T[P], TargetProductBatchGroupByOutputType[P]>
        }
      >
    >


  export type TargetProductBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    productTargetId?: boolean
    numberOfProduct?: boolean
    insentiveAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    productWiseTarget?: boolean | ProductWiseTargetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["targetProductBatch"]>



  export type TargetProductBatchSelectScalar = {
    id?: boolean
    productId?: boolean
    productTargetId?: boolean
    numberOfProduct?: boolean
    insentiveAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TargetProductBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "productTargetId" | "numberOfProduct" | "insentiveAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["targetProductBatch"]>
  export type TargetProductBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    productWiseTarget?: boolean | ProductWiseTargetDefaultArgs<ExtArgs>
  }

  export type $TargetProductBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TargetProductBatch"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      productWiseTarget: Prisma.$ProductWiseTargetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      productTargetId: number
      numberOfProduct: number
      insentiveAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["targetProductBatch"]>
    composites: {}
  }

  type TargetProductBatchGetPayload<S extends boolean | null | undefined | TargetProductBatchDefaultArgs> = $Result.GetResult<Prisma.$TargetProductBatchPayload, S>

  type TargetProductBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TargetProductBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TargetProductBatchCountAggregateInputType | true
    }

  export interface TargetProductBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TargetProductBatch'], meta: { name: 'TargetProductBatch' } }
    /**
     * Find zero or one TargetProductBatch that matches the filter.
     * @param {TargetProductBatchFindUniqueArgs} args - Arguments to find a TargetProductBatch
     * @example
     * // Get one TargetProductBatch
     * const targetProductBatch = await prisma.targetProductBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TargetProductBatchFindUniqueArgs>(args: SelectSubset<T, TargetProductBatchFindUniqueArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TargetProductBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TargetProductBatchFindUniqueOrThrowArgs} args - Arguments to find a TargetProductBatch
     * @example
     * // Get one TargetProductBatch
     * const targetProductBatch = await prisma.targetProductBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TargetProductBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, TargetProductBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TargetProductBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetProductBatchFindFirstArgs} args - Arguments to find a TargetProductBatch
     * @example
     * // Get one TargetProductBatch
     * const targetProductBatch = await prisma.targetProductBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TargetProductBatchFindFirstArgs>(args?: SelectSubset<T, TargetProductBatchFindFirstArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TargetProductBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetProductBatchFindFirstOrThrowArgs} args - Arguments to find a TargetProductBatch
     * @example
     * // Get one TargetProductBatch
     * const targetProductBatch = await prisma.targetProductBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TargetProductBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, TargetProductBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TargetProductBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetProductBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TargetProductBatches
     * const targetProductBatches = await prisma.targetProductBatch.findMany()
     * 
     * // Get first 10 TargetProductBatches
     * const targetProductBatches = await prisma.targetProductBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const targetProductBatchWithIdOnly = await prisma.targetProductBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TargetProductBatchFindManyArgs>(args?: SelectSubset<T, TargetProductBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TargetProductBatch.
     * @param {TargetProductBatchCreateArgs} args - Arguments to create a TargetProductBatch.
     * @example
     * // Create one TargetProductBatch
     * const TargetProductBatch = await prisma.targetProductBatch.create({
     *   data: {
     *     // ... data to create a TargetProductBatch
     *   }
     * })
     * 
     */
    create<T extends TargetProductBatchCreateArgs>(args: SelectSubset<T, TargetProductBatchCreateArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TargetProductBatches.
     * @param {TargetProductBatchCreateManyArgs} args - Arguments to create many TargetProductBatches.
     * @example
     * // Create many TargetProductBatches
     * const targetProductBatch = await prisma.targetProductBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TargetProductBatchCreateManyArgs>(args?: SelectSubset<T, TargetProductBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TargetProductBatch.
     * @param {TargetProductBatchDeleteArgs} args - Arguments to delete one TargetProductBatch.
     * @example
     * // Delete one TargetProductBatch
     * const TargetProductBatch = await prisma.targetProductBatch.delete({
     *   where: {
     *     // ... filter to delete one TargetProductBatch
     *   }
     * })
     * 
     */
    delete<T extends TargetProductBatchDeleteArgs>(args: SelectSubset<T, TargetProductBatchDeleteArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TargetProductBatch.
     * @param {TargetProductBatchUpdateArgs} args - Arguments to update one TargetProductBatch.
     * @example
     * // Update one TargetProductBatch
     * const targetProductBatch = await prisma.targetProductBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TargetProductBatchUpdateArgs>(args: SelectSubset<T, TargetProductBatchUpdateArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TargetProductBatches.
     * @param {TargetProductBatchDeleteManyArgs} args - Arguments to filter TargetProductBatches to delete.
     * @example
     * // Delete a few TargetProductBatches
     * const { count } = await prisma.targetProductBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TargetProductBatchDeleteManyArgs>(args?: SelectSubset<T, TargetProductBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TargetProductBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetProductBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TargetProductBatches
     * const targetProductBatch = await prisma.targetProductBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TargetProductBatchUpdateManyArgs>(args: SelectSubset<T, TargetProductBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TargetProductBatch.
     * @param {TargetProductBatchUpsertArgs} args - Arguments to update or create a TargetProductBatch.
     * @example
     * // Update or create a TargetProductBatch
     * const targetProductBatch = await prisma.targetProductBatch.upsert({
     *   create: {
     *     // ... data to create a TargetProductBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TargetProductBatch we want to update
     *   }
     * })
     */
    upsert<T extends TargetProductBatchUpsertArgs>(args: SelectSubset<T, TargetProductBatchUpsertArgs<ExtArgs>>): Prisma__TargetProductBatchClient<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TargetProductBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetProductBatchCountArgs} args - Arguments to filter TargetProductBatches to count.
     * @example
     * // Count the number of TargetProductBatches
     * const count = await prisma.targetProductBatch.count({
     *   where: {
     *     // ... the filter for the TargetProductBatches we want to count
     *   }
     * })
    **/
    count<T extends TargetProductBatchCountArgs>(
      args?: Subset<T, TargetProductBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TargetProductBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TargetProductBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetProductBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TargetProductBatchAggregateArgs>(args: Subset<T, TargetProductBatchAggregateArgs>): Prisma.PrismaPromise<GetTargetProductBatchAggregateType<T>>

    /**
     * Group by TargetProductBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetProductBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TargetProductBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TargetProductBatchGroupByArgs['orderBy'] }
        : { orderBy?: TargetProductBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TargetProductBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTargetProductBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TargetProductBatch model
   */
  readonly fields: TargetProductBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TargetProductBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TargetProductBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productWiseTarget<T extends ProductWiseTargetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductWiseTargetDefaultArgs<ExtArgs>>): Prisma__ProductWiseTargetClient<$Result.GetResult<Prisma.$ProductWiseTargetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TargetProductBatch model
   */
  interface TargetProductBatchFieldRefs {
    readonly id: FieldRef<"TargetProductBatch", 'Int'>
    readonly productId: FieldRef<"TargetProductBatch", 'Int'>
    readonly productTargetId: FieldRef<"TargetProductBatch", 'Int'>
    readonly numberOfProduct: FieldRef<"TargetProductBatch", 'Int'>
    readonly insentiveAmount: FieldRef<"TargetProductBatch", 'Float'>
    readonly createdAt: FieldRef<"TargetProductBatch", 'DateTime'>
    readonly updatedAt: FieldRef<"TargetProductBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TargetProductBatch findUnique
   */
  export type TargetProductBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which TargetProductBatch to fetch.
     */
    where: TargetProductBatchWhereUniqueInput
  }

  /**
   * TargetProductBatch findUniqueOrThrow
   */
  export type TargetProductBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which TargetProductBatch to fetch.
     */
    where: TargetProductBatchWhereUniqueInput
  }

  /**
   * TargetProductBatch findFirst
   */
  export type TargetProductBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which TargetProductBatch to fetch.
     */
    where?: TargetProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetProductBatches to fetch.
     */
    orderBy?: TargetProductBatchOrderByWithRelationInput | TargetProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetProductBatches.
     */
    cursor?: TargetProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetProductBatches.
     */
    distinct?: TargetProductBatchScalarFieldEnum | TargetProductBatchScalarFieldEnum[]
  }

  /**
   * TargetProductBatch findFirstOrThrow
   */
  export type TargetProductBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which TargetProductBatch to fetch.
     */
    where?: TargetProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetProductBatches to fetch.
     */
    orderBy?: TargetProductBatchOrderByWithRelationInput | TargetProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetProductBatches.
     */
    cursor?: TargetProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetProductBatches.
     */
    distinct?: TargetProductBatchScalarFieldEnum | TargetProductBatchScalarFieldEnum[]
  }

  /**
   * TargetProductBatch findMany
   */
  export type TargetProductBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which TargetProductBatches to fetch.
     */
    where?: TargetProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetProductBatches to fetch.
     */
    orderBy?: TargetProductBatchOrderByWithRelationInput | TargetProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TargetProductBatches.
     */
    cursor?: TargetProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetProductBatches.
     */
    skip?: number
    distinct?: TargetProductBatchScalarFieldEnum | TargetProductBatchScalarFieldEnum[]
  }

  /**
   * TargetProductBatch create
   */
  export type TargetProductBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a TargetProductBatch.
     */
    data: XOR<TargetProductBatchCreateInput, TargetProductBatchUncheckedCreateInput>
  }

  /**
   * TargetProductBatch createMany
   */
  export type TargetProductBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TargetProductBatches.
     */
    data: TargetProductBatchCreateManyInput | TargetProductBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TargetProductBatch update
   */
  export type TargetProductBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a TargetProductBatch.
     */
    data: XOR<TargetProductBatchUpdateInput, TargetProductBatchUncheckedUpdateInput>
    /**
     * Choose, which TargetProductBatch to update.
     */
    where: TargetProductBatchWhereUniqueInput
  }

  /**
   * TargetProductBatch updateMany
   */
  export type TargetProductBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TargetProductBatches.
     */
    data: XOR<TargetProductBatchUpdateManyMutationInput, TargetProductBatchUncheckedUpdateManyInput>
    /**
     * Filter which TargetProductBatches to update
     */
    where?: TargetProductBatchWhereInput
    /**
     * Limit how many TargetProductBatches to update.
     */
    limit?: number
  }

  /**
   * TargetProductBatch upsert
   */
  export type TargetProductBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the TargetProductBatch to update in case it exists.
     */
    where: TargetProductBatchWhereUniqueInput
    /**
     * In case the TargetProductBatch found by the `where` argument doesn't exist, create a new TargetProductBatch with this data.
     */
    create: XOR<TargetProductBatchCreateInput, TargetProductBatchUncheckedCreateInput>
    /**
     * In case the TargetProductBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TargetProductBatchUpdateInput, TargetProductBatchUncheckedUpdateInput>
  }

  /**
   * TargetProductBatch delete
   */
  export type TargetProductBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    /**
     * Filter which TargetProductBatch to delete.
     */
    where: TargetProductBatchWhereUniqueInput
  }

  /**
   * TargetProductBatch deleteMany
   */
  export type TargetProductBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetProductBatches to delete
     */
    where?: TargetProductBatchWhereInput
    /**
     * Limit how many TargetProductBatches to delete.
     */
    limit?: number
  }

  /**
   * TargetProductBatch without action
   */
  export type TargetProductBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    categoryName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    categoryName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    categoryName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    categoryName: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subCategory?: boolean | Category$subCategoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    categoryName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryName" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategory?: boolean | Category$subCategoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      subCategory: Prisma.$SubCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoryName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subCategory<T extends Category$subCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$subCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly categoryName: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.subCategory
   */
  export type Category$subCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    cursor?: SubCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model SubCategory
   */

  export type AggregateSubCategory = {
    _count: SubCategoryCountAggregateOutputType | null
    _avg: SubCategoryAvgAggregateOutputType | null
    _sum: SubCategorySumAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  export type SubCategoryAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type SubCategorySumAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type SubCategoryMinAggregateOutputType = {
    id: number | null
    subCategoryName: string | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubCategoryMaxAggregateOutputType = {
    id: number | null
    subCategoryName: string | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubCategoryCountAggregateOutputType = {
    id: number
    subCategoryName: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubCategoryAvgAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type SubCategorySumAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type SubCategoryMinAggregateInputType = {
    id?: true
    subCategoryName?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubCategoryMaxAggregateInputType = {
    id?: true
    subCategoryName?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubCategoryCountAggregateInputType = {
    id?: true
    subCategoryName?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategory to aggregate.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategories
    **/
    _count?: true | SubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryMaxAggregateInputType
  }

  export type GetSubCategoryAggregateType<T extends SubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategory[P]>
      : GetScalarType<T[P], AggregateSubCategory[P]>
  }




  export type SubCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithAggregationInput | SubCategoryOrderByWithAggregationInput[]
    by: SubCategoryScalarFieldEnum[] | SubCategoryScalarFieldEnum
    having?: SubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryCountAggregateInputType | true
    _avg?: SubCategoryAvgAggregateInputType
    _sum?: SubCategorySumAggregateInputType
    _min?: SubCategoryMinAggregateInputType
    _max?: SubCategoryMaxAggregateInputType
  }

  export type SubCategoryGroupByOutputType = {
    id: number
    subCategoryName: string
    categoryId: number
    createdAt: Date
    updatedAt: Date
    _count: SubCategoryCountAggregateOutputType | null
    _avg: SubCategoryAvgAggregateOutputType | null
    _sum: SubCategorySumAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  type GetSubCategoryGroupByPayload<T extends SubCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subCategoryName?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | SubCategory$productArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategory"]>



  export type SubCategorySelectScalar = {
    id?: boolean
    subCategoryName?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subCategoryName" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["subCategory"]>
  export type SubCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | SubCategory$productArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      subCategoryName: string
      categoryId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subCategory"]>
    composites: {}
  }

  type SubCategoryGetPayload<S extends boolean | null | undefined | SubCategoryDefaultArgs> = $Result.GetResult<Prisma.$SubCategoryPayload, S>

  type SubCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubCategoryCountAggregateInputType | true
    }

  export interface SubCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategory'], meta: { name: 'SubCategory' } }
    /**
     * Find zero or one SubCategory that matches the filter.
     * @param {SubCategoryFindUniqueArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubCategoryFindUniqueArgs>(args: SelectSubset<T, SubCategoryFindUniqueArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubCategoryFindUniqueOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubCategoryFindFirstArgs>(args?: SelectSubset<T, SubCategoryFindFirstArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategories
     * const subCategories = await prisma.subCategory.findMany()
     * 
     * // Get first 10 SubCategories
     * const subCategories = await prisma.subCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubCategoryFindManyArgs>(args?: SelectSubset<T, SubCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubCategory.
     * @param {SubCategoryCreateArgs} args - Arguments to create a SubCategory.
     * @example
     * // Create one SubCategory
     * const SubCategory = await prisma.subCategory.create({
     *   data: {
     *     // ... data to create a SubCategory
     *   }
     * })
     * 
     */
    create<T extends SubCategoryCreateArgs>(args: SelectSubset<T, SubCategoryCreateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubCategories.
     * @param {SubCategoryCreateManyArgs} args - Arguments to create many SubCategories.
     * @example
     * // Create many SubCategories
     * const subCategory = await prisma.subCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubCategoryCreateManyArgs>(args?: SelectSubset<T, SubCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategory.
     * @param {SubCategoryDeleteArgs} args - Arguments to delete one SubCategory.
     * @example
     * // Delete one SubCategory
     * const SubCategory = await prisma.subCategory.delete({
     *   where: {
     *     // ... filter to delete one SubCategory
     *   }
     * })
     * 
     */
    delete<T extends SubCategoryDeleteArgs>(args: SelectSubset<T, SubCategoryDeleteArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubCategory.
     * @param {SubCategoryUpdateArgs} args - Arguments to update one SubCategory.
     * @example
     * // Update one SubCategory
     * const subCategory = await prisma.subCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubCategoryUpdateArgs>(args: SelectSubset<T, SubCategoryUpdateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubCategories.
     * @param {SubCategoryDeleteManyArgs} args - Arguments to filter SubCategories to delete.
     * @example
     * // Delete a few SubCategories
     * const { count } = await prisma.subCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubCategoryDeleteManyArgs>(args?: SelectSubset<T, SubCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategories
     * const subCategory = await prisma.subCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubCategoryUpdateManyArgs>(args: SelectSubset<T, SubCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategory.
     * @param {SubCategoryUpsertArgs} args - Arguments to update or create a SubCategory.
     * @example
     * // Update or create a SubCategory
     * const subCategory = await prisma.subCategory.upsert({
     *   create: {
     *     // ... data to create a SubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategory we want to update
     *   }
     * })
     */
    upsert<T extends SubCategoryUpsertArgs>(args: SelectSubset<T, SubCategoryUpsertArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryCountArgs} args - Arguments to filter SubCategories to count.
     * @example
     * // Count the number of SubCategories
     * const count = await prisma.subCategory.count({
     *   where: {
     *     // ... the filter for the SubCategories we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryCountArgs>(
      args?: Subset<T, SubCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryAggregateArgs>(args: Subset<T, SubCategoryAggregateArgs>): Prisma.PrismaPromise<GetSubCategoryAggregateType<T>>

    /**
     * Group by SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategory model
   */
  readonly fields: SubCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends SubCategory$productArgs<ExtArgs> = {}>(args?: Subset<T, SubCategory$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubCategory model
   */
  interface SubCategoryFieldRefs {
    readonly id: FieldRef<"SubCategory", 'Int'>
    readonly subCategoryName: FieldRef<"SubCategory", 'String'>
    readonly categoryId: FieldRef<"SubCategory", 'Int'>
    readonly createdAt: FieldRef<"SubCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"SubCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubCategory findUnique
   */
  export type SubCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findUniqueOrThrow
   */
  export type SubCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findFirst
   */
  export type SubCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findFirstOrThrow
   */
  export type SubCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findMany
   */
  export type SubCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategories to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory create
   */
  export type SubCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategory.
     */
    data: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
  }

  /**
   * SubCategory createMany
   */
  export type SubCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategories.
     */
    data: SubCategoryCreateManyInput | SubCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubCategory update
   */
  export type SubCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategory.
     */
    data: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
    /**
     * Choose, which SubCategory to update.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory updateMany
   */
  export type SubCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategories.
     */
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubCategories to update
     */
    where?: SubCategoryWhereInput
    /**
     * Limit how many SubCategories to update.
     */
    limit?: number
  }

  /**
   * SubCategory upsert
   */
  export type SubCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategory to update in case it exists.
     */
    where: SubCategoryWhereUniqueInput
    /**
     * In case the SubCategory found by the `where` argument doesn't exist, create a new SubCategory with this data.
     */
    create: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
    /**
     * In case the SubCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
  }

  /**
   * SubCategory delete
   */
  export type SubCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter which SubCategory to delete.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory deleteMany
   */
  export type SubCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategories to delete
     */
    where?: SubCategoryWhereInput
    /**
     * Limit how many SubCategories to delete.
     */
    limit?: number
  }

  /**
   * SubCategory.product
   */
  export type SubCategory$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * SubCategory without action
   */
  export type SubCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updateAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updateAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updateAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updateAt?: boolean
    product?: boolean | Unit$productArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>



  export type UnitSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updateAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Unit$productArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends Unit$productArgs<ExtArgs> = {}>(args?: Subset<T, Unit$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updateAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.product
   */
  export type Unit$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model AccountHead
   */

  export type AggregateAccountHead = {
    _count: AccountHeadCountAggregateOutputType | null
    _avg: AccountHeadAvgAggregateOutputType | null
    _sum: AccountHeadSumAggregateOutputType | null
    _min: AccountHeadMinAggregateOutputType | null
    _max: AccountHeadMaxAggregateOutputType | null
  }

  export type AccountHeadAvgAggregateOutputType = {
    id: number | null
  }

  export type AccountHeadSumAggregateOutputType = {
    id: number | null
  }

  export type AccountHeadMinAggregateOutputType = {
    id: number | null
    headName: string | null
    headCode: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type AccountHeadMaxAggregateOutputType = {
    id: number | null
    headName: string | null
    headCode: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type AccountHeadCountAggregateOutputType = {
    id: number
    headName: number
    headCode: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type AccountHeadAvgAggregateInputType = {
    id?: true
  }

  export type AccountHeadSumAggregateInputType = {
    id?: true
  }

  export type AccountHeadMinAggregateInputType = {
    id?: true
    headName?: true
    headCode?: true
    createdAt?: true
    updateAt?: true
  }

  export type AccountHeadMaxAggregateInputType = {
    id?: true
    headName?: true
    headCode?: true
    createdAt?: true
    updateAt?: true
  }

  export type AccountHeadCountAggregateInputType = {
    id?: true
    headName?: true
    headCode?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type AccountHeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountHead to aggregate.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountHeads
    **/
    _count?: true | AccountHeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountHeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountHeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountHeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountHeadMaxAggregateInputType
  }

  export type GetAccountHeadAggregateType<T extends AccountHeadAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountHead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountHead[P]>
      : GetScalarType<T[P], AggregateAccountHead[P]>
  }




  export type AccountHeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountHeadWhereInput
    orderBy?: AccountHeadOrderByWithAggregationInput | AccountHeadOrderByWithAggregationInput[]
    by: AccountHeadScalarFieldEnum[] | AccountHeadScalarFieldEnum
    having?: AccountHeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountHeadCountAggregateInputType | true
    _avg?: AccountHeadAvgAggregateInputType
    _sum?: AccountHeadSumAggregateInputType
    _min?: AccountHeadMinAggregateInputType
    _max?: AccountHeadMaxAggregateInputType
  }

  export type AccountHeadGroupByOutputType = {
    id: number
    headName: string
    headCode: string
    createdAt: Date
    updateAt: Date
    _count: AccountHeadCountAggregateOutputType | null
    _avg: AccountHeadAvgAggregateOutputType | null
    _sum: AccountHeadSumAggregateOutputType | null
    _min: AccountHeadMinAggregateOutputType | null
    _max: AccountHeadMaxAggregateOutputType | null
  }

  type GetAccountHeadGroupByPayload<T extends AccountHeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountHeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountHeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountHeadGroupByOutputType[P]>
            : GetScalarType<T[P], AccountHeadGroupByOutputType[P]>
        }
      >
    >


  export type AccountHeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    headName?: boolean
    headCode?: boolean
    createdAt?: boolean
    updateAt?: boolean
    ledgerHead?: boolean | AccountHead$ledgerHeadArgs<ExtArgs>
    _count?: boolean | AccountHeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountHead"]>



  export type AccountHeadSelectScalar = {
    id?: boolean
    headName?: boolean
    headCode?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type AccountHeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "headName" | "headCode" | "createdAt" | "updateAt", ExtArgs["result"]["accountHead"]>
  export type AccountHeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerHead?: boolean | AccountHead$ledgerHeadArgs<ExtArgs>
    _count?: boolean | AccountHeadCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountHeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountHead"
    objects: {
      ledgerHead: Prisma.$LedgerHeadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      headName: string
      headCode: string
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["accountHead"]>
    composites: {}
  }

  type AccountHeadGetPayload<S extends boolean | null | undefined | AccountHeadDefaultArgs> = $Result.GetResult<Prisma.$AccountHeadPayload, S>

  type AccountHeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountHeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountHeadCountAggregateInputType | true
    }

  export interface AccountHeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountHead'], meta: { name: 'AccountHead' } }
    /**
     * Find zero or one AccountHead that matches the filter.
     * @param {AccountHeadFindUniqueArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountHeadFindUniqueArgs>(args: SelectSubset<T, AccountHeadFindUniqueArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountHead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountHeadFindUniqueOrThrowArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountHeadFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountHeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountHead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadFindFirstArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountHeadFindFirstArgs>(args?: SelectSubset<T, AccountHeadFindFirstArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountHead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadFindFirstOrThrowArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountHeadFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountHeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountHeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountHeads
     * const accountHeads = await prisma.accountHead.findMany()
     * 
     * // Get first 10 AccountHeads
     * const accountHeads = await prisma.accountHead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountHeadWithIdOnly = await prisma.accountHead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountHeadFindManyArgs>(args?: SelectSubset<T, AccountHeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountHead.
     * @param {AccountHeadCreateArgs} args - Arguments to create a AccountHead.
     * @example
     * // Create one AccountHead
     * const AccountHead = await prisma.accountHead.create({
     *   data: {
     *     // ... data to create a AccountHead
     *   }
     * })
     * 
     */
    create<T extends AccountHeadCreateArgs>(args: SelectSubset<T, AccountHeadCreateArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountHeads.
     * @param {AccountHeadCreateManyArgs} args - Arguments to create many AccountHeads.
     * @example
     * // Create many AccountHeads
     * const accountHead = await prisma.accountHead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountHeadCreateManyArgs>(args?: SelectSubset<T, AccountHeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountHead.
     * @param {AccountHeadDeleteArgs} args - Arguments to delete one AccountHead.
     * @example
     * // Delete one AccountHead
     * const AccountHead = await prisma.accountHead.delete({
     *   where: {
     *     // ... filter to delete one AccountHead
     *   }
     * })
     * 
     */
    delete<T extends AccountHeadDeleteArgs>(args: SelectSubset<T, AccountHeadDeleteArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountHead.
     * @param {AccountHeadUpdateArgs} args - Arguments to update one AccountHead.
     * @example
     * // Update one AccountHead
     * const accountHead = await prisma.accountHead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountHeadUpdateArgs>(args: SelectSubset<T, AccountHeadUpdateArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountHeads.
     * @param {AccountHeadDeleteManyArgs} args - Arguments to filter AccountHeads to delete.
     * @example
     * // Delete a few AccountHeads
     * const { count } = await prisma.accountHead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountHeadDeleteManyArgs>(args?: SelectSubset<T, AccountHeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountHeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountHeads
     * const accountHead = await prisma.accountHead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountHeadUpdateManyArgs>(args: SelectSubset<T, AccountHeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountHead.
     * @param {AccountHeadUpsertArgs} args - Arguments to update or create a AccountHead.
     * @example
     * // Update or create a AccountHead
     * const accountHead = await prisma.accountHead.upsert({
     *   create: {
     *     // ... data to create a AccountHead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountHead we want to update
     *   }
     * })
     */
    upsert<T extends AccountHeadUpsertArgs>(args: SelectSubset<T, AccountHeadUpsertArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountHeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadCountArgs} args - Arguments to filter AccountHeads to count.
     * @example
     * // Count the number of AccountHeads
     * const count = await prisma.accountHead.count({
     *   where: {
     *     // ... the filter for the AccountHeads we want to count
     *   }
     * })
    **/
    count<T extends AccountHeadCountArgs>(
      args?: Subset<T, AccountHeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountHeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountHead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountHeadAggregateArgs>(args: Subset<T, AccountHeadAggregateArgs>): Prisma.PrismaPromise<GetAccountHeadAggregateType<T>>

    /**
     * Group by AccountHead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountHeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountHeadGroupByArgs['orderBy'] }
        : { orderBy?: AccountHeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountHeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountHeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountHead model
   */
  readonly fields: AccountHeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountHead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountHeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ledgerHead<T extends AccountHead$ledgerHeadArgs<ExtArgs> = {}>(args?: Subset<T, AccountHead$ledgerHeadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountHead model
   */
  interface AccountHeadFieldRefs {
    readonly id: FieldRef<"AccountHead", 'Int'>
    readonly headName: FieldRef<"AccountHead", 'String'>
    readonly headCode: FieldRef<"AccountHead", 'String'>
    readonly createdAt: FieldRef<"AccountHead", 'DateTime'>
    readonly updateAt: FieldRef<"AccountHead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountHead findUnique
   */
  export type AccountHeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead findUniqueOrThrow
   */
  export type AccountHeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead findFirst
   */
  export type AccountHeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountHeads.
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountHeads.
     */
    distinct?: AccountHeadScalarFieldEnum | AccountHeadScalarFieldEnum[]
  }

  /**
   * AccountHead findFirstOrThrow
   */
  export type AccountHeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountHeads.
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountHeads.
     */
    distinct?: AccountHeadScalarFieldEnum | AccountHeadScalarFieldEnum[]
  }

  /**
   * AccountHead findMany
   */
  export type AccountHeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHeads to fetch.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountHeads.
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    distinct?: AccountHeadScalarFieldEnum | AccountHeadScalarFieldEnum[]
  }

  /**
   * AccountHead create
   */
  export type AccountHeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountHead.
     */
    data: XOR<AccountHeadCreateInput, AccountHeadUncheckedCreateInput>
  }

  /**
   * AccountHead createMany
   */
  export type AccountHeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountHeads.
     */
    data: AccountHeadCreateManyInput | AccountHeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountHead update
   */
  export type AccountHeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountHead.
     */
    data: XOR<AccountHeadUpdateInput, AccountHeadUncheckedUpdateInput>
    /**
     * Choose, which AccountHead to update.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead updateMany
   */
  export type AccountHeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountHeads.
     */
    data: XOR<AccountHeadUpdateManyMutationInput, AccountHeadUncheckedUpdateManyInput>
    /**
     * Filter which AccountHeads to update
     */
    where?: AccountHeadWhereInput
    /**
     * Limit how many AccountHeads to update.
     */
    limit?: number
  }

  /**
   * AccountHead upsert
   */
  export type AccountHeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountHead to update in case it exists.
     */
    where: AccountHeadWhereUniqueInput
    /**
     * In case the AccountHead found by the `where` argument doesn't exist, create a new AccountHead with this data.
     */
    create: XOR<AccountHeadCreateInput, AccountHeadUncheckedCreateInput>
    /**
     * In case the AccountHead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountHeadUpdateInput, AccountHeadUncheckedUpdateInput>
  }

  /**
   * AccountHead delete
   */
  export type AccountHeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter which AccountHead to delete.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead deleteMany
   */
  export type AccountHeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountHeads to delete
     */
    where?: AccountHeadWhereInput
    /**
     * Limit how many AccountHeads to delete.
     */
    limit?: number
  }

  /**
   * AccountHead.ledgerHead
   */
  export type AccountHead$ledgerHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    where?: LedgerHeadWhereInput
    orderBy?: LedgerHeadOrderByWithRelationInput | LedgerHeadOrderByWithRelationInput[]
    cursor?: LedgerHeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerHeadScalarFieldEnum | LedgerHeadScalarFieldEnum[]
  }

  /**
   * AccountHead without action
   */
  export type AccountHeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountHead
     */
    omit?: AccountHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
  }


  /**
   * Model LedgerHead
   */

  export type AggregateLedgerHead = {
    _count: LedgerHeadCountAggregateOutputType | null
    _avg: LedgerHeadAvgAggregateOutputType | null
    _sum: LedgerHeadSumAggregateOutputType | null
    _min: LedgerHeadMinAggregateOutputType | null
    _max: LedgerHeadMaxAggregateOutputType | null
  }

  export type LedgerHeadAvgAggregateOutputType = {
    id: number | null
    headCodeId: number | null
  }

  export type LedgerHeadSumAggregateOutputType = {
    id: number | null
    headCodeId: number | null
  }

  export type LedgerHeadMinAggregateOutputType = {
    id: number | null
    ledgerName: string | null
    ledgerCode: string | null
    headCodeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LedgerHeadMaxAggregateOutputType = {
    id: number | null
    ledgerName: string | null
    ledgerCode: string | null
    headCodeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LedgerHeadCountAggregateOutputType = {
    id: number
    ledgerName: number
    ledgerCode: number
    headCodeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LedgerHeadAvgAggregateInputType = {
    id?: true
    headCodeId?: true
  }

  export type LedgerHeadSumAggregateInputType = {
    id?: true
    headCodeId?: true
  }

  export type LedgerHeadMinAggregateInputType = {
    id?: true
    ledgerName?: true
    ledgerCode?: true
    headCodeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LedgerHeadMaxAggregateInputType = {
    id?: true
    ledgerName?: true
    ledgerCode?: true
    headCodeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LedgerHeadCountAggregateInputType = {
    id?: true
    ledgerName?: true
    ledgerCode?: true
    headCodeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LedgerHeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerHead to aggregate.
     */
    where?: LedgerHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerHeads to fetch.
     */
    orderBy?: LedgerHeadOrderByWithRelationInput | LedgerHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerHeads
    **/
    _count?: true | LedgerHeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerHeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerHeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerHeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerHeadMaxAggregateInputType
  }

  export type GetLedgerHeadAggregateType<T extends LedgerHeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerHead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerHead[P]>
      : GetScalarType<T[P], AggregateLedgerHead[P]>
  }




  export type LedgerHeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerHeadWhereInput
    orderBy?: LedgerHeadOrderByWithAggregationInput | LedgerHeadOrderByWithAggregationInput[]
    by: LedgerHeadScalarFieldEnum[] | LedgerHeadScalarFieldEnum
    having?: LedgerHeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerHeadCountAggregateInputType | true
    _avg?: LedgerHeadAvgAggregateInputType
    _sum?: LedgerHeadSumAggregateInputType
    _min?: LedgerHeadMinAggregateInputType
    _max?: LedgerHeadMaxAggregateInputType
  }

  export type LedgerHeadGroupByOutputType = {
    id: number
    ledgerName: string
    ledgerCode: string
    headCodeId: number
    createdAt: Date
    updatedAt: Date
    _count: LedgerHeadCountAggregateOutputType | null
    _avg: LedgerHeadAvgAggregateOutputType | null
    _sum: LedgerHeadSumAggregateOutputType | null
    _min: LedgerHeadMinAggregateOutputType | null
    _max: LedgerHeadMaxAggregateOutputType | null
  }

  type GetLedgerHeadGroupByPayload<T extends LedgerHeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerHeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerHeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerHeadGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerHeadGroupByOutputType[P]>
        }
      >
    >


  export type LedgerHeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ledgerName?: boolean
    ledgerCode?: boolean
    headCodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fixedJournal?: boolean | LedgerHead$fixedJournalArgs<ExtArgs>
    journal?: boolean | LedgerHead$journalArgs<ExtArgs>
    accountHead?: boolean | AccountHeadDefaultArgs<ExtArgs>
    _count?: boolean | LedgerHeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerHead"]>



  export type LedgerHeadSelectScalar = {
    id?: boolean
    ledgerName?: boolean
    ledgerCode?: boolean
    headCodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LedgerHeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ledgerName" | "ledgerCode" | "headCodeId" | "createdAt" | "updatedAt", ExtArgs["result"]["ledgerHead"]>
  export type LedgerHeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fixedJournal?: boolean | LedgerHead$fixedJournalArgs<ExtArgs>
    journal?: boolean | LedgerHead$journalArgs<ExtArgs>
    accountHead?: boolean | AccountHeadDefaultArgs<ExtArgs>
    _count?: boolean | LedgerHeadCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LedgerHeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerHead"
    objects: {
      fixedJournal: Prisma.$FixedJournalPayload<ExtArgs>[]
      journal: Prisma.$JournalPayload<ExtArgs>[]
      accountHead: Prisma.$AccountHeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ledgerName: string
      ledgerCode: string
      headCodeId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ledgerHead"]>
    composites: {}
  }

  type LedgerHeadGetPayload<S extends boolean | null | undefined | LedgerHeadDefaultArgs> = $Result.GetResult<Prisma.$LedgerHeadPayload, S>

  type LedgerHeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LedgerHeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LedgerHeadCountAggregateInputType | true
    }

  export interface LedgerHeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerHead'], meta: { name: 'LedgerHead' } }
    /**
     * Find zero or one LedgerHead that matches the filter.
     * @param {LedgerHeadFindUniqueArgs} args - Arguments to find a LedgerHead
     * @example
     * // Get one LedgerHead
     * const ledgerHead = await prisma.ledgerHead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerHeadFindUniqueArgs>(args: SelectSubset<T, LedgerHeadFindUniqueArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LedgerHead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LedgerHeadFindUniqueOrThrowArgs} args - Arguments to find a LedgerHead
     * @example
     * // Get one LedgerHead
     * const ledgerHead = await prisma.ledgerHead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerHeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerHeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerHead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerHeadFindFirstArgs} args - Arguments to find a LedgerHead
     * @example
     * // Get one LedgerHead
     * const ledgerHead = await prisma.ledgerHead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerHeadFindFirstArgs>(args?: SelectSubset<T, LedgerHeadFindFirstArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerHead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerHeadFindFirstOrThrowArgs} args - Arguments to find a LedgerHead
     * @example
     * // Get one LedgerHead
     * const ledgerHead = await prisma.ledgerHead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerHeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerHeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LedgerHeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerHeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerHeads
     * const ledgerHeads = await prisma.ledgerHead.findMany()
     * 
     * // Get first 10 LedgerHeads
     * const ledgerHeads = await prisma.ledgerHead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerHeadWithIdOnly = await prisma.ledgerHead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerHeadFindManyArgs>(args?: SelectSubset<T, LedgerHeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LedgerHead.
     * @param {LedgerHeadCreateArgs} args - Arguments to create a LedgerHead.
     * @example
     * // Create one LedgerHead
     * const LedgerHead = await prisma.ledgerHead.create({
     *   data: {
     *     // ... data to create a LedgerHead
     *   }
     * })
     * 
     */
    create<T extends LedgerHeadCreateArgs>(args: SelectSubset<T, LedgerHeadCreateArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LedgerHeads.
     * @param {LedgerHeadCreateManyArgs} args - Arguments to create many LedgerHeads.
     * @example
     * // Create many LedgerHeads
     * const ledgerHead = await prisma.ledgerHead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerHeadCreateManyArgs>(args?: SelectSubset<T, LedgerHeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LedgerHead.
     * @param {LedgerHeadDeleteArgs} args - Arguments to delete one LedgerHead.
     * @example
     * // Delete one LedgerHead
     * const LedgerHead = await prisma.ledgerHead.delete({
     *   where: {
     *     // ... filter to delete one LedgerHead
     *   }
     * })
     * 
     */
    delete<T extends LedgerHeadDeleteArgs>(args: SelectSubset<T, LedgerHeadDeleteArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LedgerHead.
     * @param {LedgerHeadUpdateArgs} args - Arguments to update one LedgerHead.
     * @example
     * // Update one LedgerHead
     * const ledgerHead = await prisma.ledgerHead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerHeadUpdateArgs>(args: SelectSubset<T, LedgerHeadUpdateArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LedgerHeads.
     * @param {LedgerHeadDeleteManyArgs} args - Arguments to filter LedgerHeads to delete.
     * @example
     * // Delete a few LedgerHeads
     * const { count } = await prisma.ledgerHead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerHeadDeleteManyArgs>(args?: SelectSubset<T, LedgerHeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerHeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerHeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerHeads
     * const ledgerHead = await prisma.ledgerHead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerHeadUpdateManyArgs>(args: SelectSubset<T, LedgerHeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerHead.
     * @param {LedgerHeadUpsertArgs} args - Arguments to update or create a LedgerHead.
     * @example
     * // Update or create a LedgerHead
     * const ledgerHead = await prisma.ledgerHead.upsert({
     *   create: {
     *     // ... data to create a LedgerHead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerHead we want to update
     *   }
     * })
     */
    upsert<T extends LedgerHeadUpsertArgs>(args: SelectSubset<T, LedgerHeadUpsertArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LedgerHeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerHeadCountArgs} args - Arguments to filter LedgerHeads to count.
     * @example
     * // Count the number of LedgerHeads
     * const count = await prisma.ledgerHead.count({
     *   where: {
     *     // ... the filter for the LedgerHeads we want to count
     *   }
     * })
    **/
    count<T extends LedgerHeadCountArgs>(
      args?: Subset<T, LedgerHeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerHeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerHead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerHeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerHeadAggregateArgs>(args: Subset<T, LedgerHeadAggregateArgs>): Prisma.PrismaPromise<GetLedgerHeadAggregateType<T>>

    /**
     * Group by LedgerHead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerHeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerHeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerHeadGroupByArgs['orderBy'] }
        : { orderBy?: LedgerHeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerHeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerHeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerHead model
   */
  readonly fields: LedgerHeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerHead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerHeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fixedJournal<T extends LedgerHead$fixedJournalArgs<ExtArgs> = {}>(args?: Subset<T, LedgerHead$fixedJournalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journal<T extends LedgerHead$journalArgs<ExtArgs> = {}>(args?: Subset<T, LedgerHead$journalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accountHead<T extends AccountHeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountHeadDefaultArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerHead model
   */
  interface LedgerHeadFieldRefs {
    readonly id: FieldRef<"LedgerHead", 'Int'>
    readonly ledgerName: FieldRef<"LedgerHead", 'String'>
    readonly ledgerCode: FieldRef<"LedgerHead", 'String'>
    readonly headCodeId: FieldRef<"LedgerHead", 'Int'>
    readonly createdAt: FieldRef<"LedgerHead", 'DateTime'>
    readonly updatedAt: FieldRef<"LedgerHead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerHead findUnique
   */
  export type LedgerHeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * Filter, which LedgerHead to fetch.
     */
    where: LedgerHeadWhereUniqueInput
  }

  /**
   * LedgerHead findUniqueOrThrow
   */
  export type LedgerHeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * Filter, which LedgerHead to fetch.
     */
    where: LedgerHeadWhereUniqueInput
  }

  /**
   * LedgerHead findFirst
   */
  export type LedgerHeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * Filter, which LedgerHead to fetch.
     */
    where?: LedgerHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerHeads to fetch.
     */
    orderBy?: LedgerHeadOrderByWithRelationInput | LedgerHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerHeads.
     */
    cursor?: LedgerHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerHeads.
     */
    distinct?: LedgerHeadScalarFieldEnum | LedgerHeadScalarFieldEnum[]
  }

  /**
   * LedgerHead findFirstOrThrow
   */
  export type LedgerHeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * Filter, which LedgerHead to fetch.
     */
    where?: LedgerHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerHeads to fetch.
     */
    orderBy?: LedgerHeadOrderByWithRelationInput | LedgerHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerHeads.
     */
    cursor?: LedgerHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerHeads.
     */
    distinct?: LedgerHeadScalarFieldEnum | LedgerHeadScalarFieldEnum[]
  }

  /**
   * LedgerHead findMany
   */
  export type LedgerHeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * Filter, which LedgerHeads to fetch.
     */
    where?: LedgerHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerHeads to fetch.
     */
    orderBy?: LedgerHeadOrderByWithRelationInput | LedgerHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerHeads.
     */
    cursor?: LedgerHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerHeads.
     */
    skip?: number
    distinct?: LedgerHeadScalarFieldEnum | LedgerHeadScalarFieldEnum[]
  }

  /**
   * LedgerHead create
   */
  export type LedgerHeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerHead.
     */
    data: XOR<LedgerHeadCreateInput, LedgerHeadUncheckedCreateInput>
  }

  /**
   * LedgerHead createMany
   */
  export type LedgerHeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerHeads.
     */
    data: LedgerHeadCreateManyInput | LedgerHeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerHead update
   */
  export type LedgerHeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerHead.
     */
    data: XOR<LedgerHeadUpdateInput, LedgerHeadUncheckedUpdateInput>
    /**
     * Choose, which LedgerHead to update.
     */
    where: LedgerHeadWhereUniqueInput
  }

  /**
   * LedgerHead updateMany
   */
  export type LedgerHeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerHeads.
     */
    data: XOR<LedgerHeadUpdateManyMutationInput, LedgerHeadUncheckedUpdateManyInput>
    /**
     * Filter which LedgerHeads to update
     */
    where?: LedgerHeadWhereInput
    /**
     * Limit how many LedgerHeads to update.
     */
    limit?: number
  }

  /**
   * LedgerHead upsert
   */
  export type LedgerHeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerHead to update in case it exists.
     */
    where: LedgerHeadWhereUniqueInput
    /**
     * In case the LedgerHead found by the `where` argument doesn't exist, create a new LedgerHead with this data.
     */
    create: XOR<LedgerHeadCreateInput, LedgerHeadUncheckedCreateInput>
    /**
     * In case the LedgerHead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerHeadUpdateInput, LedgerHeadUncheckedUpdateInput>
  }

  /**
   * LedgerHead delete
   */
  export type LedgerHeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    /**
     * Filter which LedgerHead to delete.
     */
    where: LedgerHeadWhereUniqueInput
  }

  /**
   * LedgerHead deleteMany
   */
  export type LedgerHeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerHeads to delete
     */
    where?: LedgerHeadWhereInput
    /**
     * Limit how many LedgerHeads to delete.
     */
    limit?: number
  }

  /**
   * LedgerHead.fixedJournal
   */
  export type LedgerHead$fixedJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    where?: FixedJournalWhereInput
    orderBy?: FixedJournalOrderByWithRelationInput | FixedJournalOrderByWithRelationInput[]
    cursor?: FixedJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixedJournalScalarFieldEnum | FixedJournalScalarFieldEnum[]
  }

  /**
   * LedgerHead.journal
   */
  export type LedgerHead$journalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    cursor?: JournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * LedgerHead without action
   */
  export type LedgerHeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    subCategoryId: number | null
    stakeholderId: number | null
    unitId: number | null
    mrp: number | null
    tp: number | null
    balance: number | null
    quantity: number | null
    unitPrice: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    subCategoryId: number | null
    stakeholderId: number | null
    unitId: number | null
    mrp: number | null
    tp: number | null
    balance: number | null
    quantity: number | null
    unitPrice: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    subCategoryId: number | null
    stakeholderId: number | null
    size: string | null
    unitId: number | null
    mrp: number | null
    tp: number | null
    balance: number | null
    quantity: number | null
    unitPrice: number | null
    date: Date | null
    status: $Enums.Status | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    subCategoryId: number | null
    stakeholderId: number | null
    size: string | null
    unitId: number | null
    mrp: number | null
    tp: number | null
    balance: number | null
    quantity: number | null
    unitPrice: number | null
    date: Date | null
    status: $Enums.Status | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    subCategoryId: number
    stakeholderId: number
    size: number
    unitId: number
    mrp: number
    tp: number
    balance: number
    quantity: number
    unitPrice: number
    date: number
    status: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    subCategoryId?: true
    stakeholderId?: true
    unitId?: true
    mrp?: true
    tp?: true
    balance?: true
    quantity?: true
    unitPrice?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    subCategoryId?: true
    stakeholderId?: true
    unitId?: true
    mrp?: true
    tp?: true
    balance?: true
    quantity?: true
    unitPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subCategoryId?: true
    stakeholderId?: true
    size?: true
    unitId?: true
    mrp?: true
    tp?: true
    balance?: true
    quantity?: true
    unitPrice?: true
    date?: true
    status?: true
    createdAt?: true
    updateAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subCategoryId?: true
    stakeholderId?: true
    size?: true
    unitId?: true
    mrp?: true
    tp?: true
    balance?: true
    quantity?: true
    unitPrice?: true
    date?: true
    status?: true
    createdAt?: true
    updateAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subCategoryId?: true
    stakeholderId?: true
    size?: true
    unitId?: true
    mrp?: true
    tp?: true
    balance?: true
    quantity?: true
    unitPrice?: true
    date?: true
    status?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId: number | null
    size: string
    unitId: number
    mrp: number
    tp: number
    balance: number
    quantity: number
    unitPrice: number
    date: Date
    status: $Enums.Status
    createdAt: Date
    updateAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    subCategoryId?: boolean
    stakeholderId?: boolean
    size?: boolean
    unitId?: boolean
    mrp?: boolean
    tp?: boolean
    balance?: boolean
    quantity?: boolean
    unitPrice?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
    targetProductBatch?: boolean | Product$targetProductBatchArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    orderItem?: boolean | Product$orderItemArgs<ExtArgs>
    Stakeholder?: boolean | Product$StakeholderArgs<ExtArgs>
    subCategory?: boolean | SubCategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    subCategoryId?: boolean
    stakeholderId?: boolean
    size?: boolean
    unitId?: boolean
    mrp?: boolean
    tp?: boolean
    balance?: boolean
    quantity?: boolean
    unitPrice?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "subCategoryId" | "stakeholderId" | "size" | "unitId" | "mrp" | "tp" | "balance" | "quantity" | "unitPrice" | "date" | "status" | "createdAt" | "updateAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetProductBatch?: boolean | Product$targetProductBatchArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    orderItem?: boolean | Product$orderItemArgs<ExtArgs>
    Stakeholder?: boolean | Product$StakeholderArgs<ExtArgs>
    subCategory?: boolean | SubCategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      targetProductBatch: Prisma.$TargetProductBatchPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      orderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      Stakeholder: Prisma.$StakeholderPayload<ExtArgs> | null
      subCategory: Prisma.$SubCategoryPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      subCategoryId: number
      stakeholderId: number | null
      size: string
      unitId: number
      mrp: number
      tp: number
      balance: number
      quantity: number
      unitPrice: number
      date: Date
      status: $Enums.Status
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    targetProductBatch<T extends Product$targetProductBatchArgs<ExtArgs> = {}>(args?: Subset<T, Product$targetProductBatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends Product$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItem<T extends Product$orderItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Stakeholder<T extends Product$StakeholderArgs<ExtArgs> = {}>(args?: Subset<T, Product$StakeholderArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subCategory<T extends SubCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoryDefaultArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly subCategoryId: FieldRef<"Product", 'Int'>
    readonly stakeholderId: FieldRef<"Product", 'Int'>
    readonly size: FieldRef<"Product", 'String'>
    readonly unitId: FieldRef<"Product", 'Int'>
    readonly mrp: FieldRef<"Product", 'Float'>
    readonly tp: FieldRef<"Product", 'Float'>
    readonly balance: FieldRef<"Product", 'Float'>
    readonly quantity: FieldRef<"Product", 'Float'>
    readonly unitPrice: FieldRef<"Product", 'Float'>
    readonly date: FieldRef<"Product", 'DateTime'>
    readonly status: FieldRef<"Product", 'Status'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updateAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.targetProductBatch
   */
  export type Product$targetProductBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetProductBatch
     */
    select?: TargetProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TargetProductBatch
     */
    omit?: TargetProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetProductBatchInclude<ExtArgs> | null
    where?: TargetProductBatchWhereInput
    orderBy?: TargetProductBatchOrderByWithRelationInput | TargetProductBatchOrderByWithRelationInput[]
    cursor?: TargetProductBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TargetProductBatchScalarFieldEnum | TargetProductBatchScalarFieldEnum[]
  }

  /**
   * Product.inventory
   */
  export type Product$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Product.orderItem
   */
  export type Product$orderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.Stakeholder
   */
  export type Product$StakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    where?: StakeholderWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    id: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    id: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: number | null
    bankName: string | null
    branceName: string | null
    accountNumber: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: number | null
    bankName: string | null
    branceName: string | null
    accountNumber: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    bankName: number
    branceName: number
    accountNumber: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    id?: true
  }

  export type BankAccountSumAggregateInputType = {
    id?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    bankName?: true
    branceName?: true
    accountNumber?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    bankName?: true
    branceName?: true
    accountNumber?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    bankName?: true
    branceName?: true
    accountNumber?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: number
    bankName: string
    branceName: string | null
    accountNumber: string
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    branceName?: boolean
    accountNumber?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankTransaction?: boolean | BankAccount$bankTransactionArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>



  export type BankAccountSelectScalar = {
    id?: boolean
    bankName?: boolean
    branceName?: boolean
    accountNumber?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bankName" | "branceName" | "accountNumber" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankTransaction?: boolean | BankAccount$bankTransactionArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      bankTransaction: Prisma.$BankTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bankName: string
      branceName: string | null
      accountNumber: string
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bankTransaction<T extends BankAccount$bankTransactionArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$bankTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'Int'>
    readonly bankName: FieldRef<"BankAccount", 'String'>
    readonly branceName: FieldRef<"BankAccount", 'String'>
    readonly accountNumber: FieldRef<"BankAccount", 'String'>
    readonly status: FieldRef<"BankAccount", 'Status'>
    readonly createdAt: FieldRef<"BankAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount.bankTransaction
   */
  export type BankAccount$bankTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    cursor?: BankTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model BankTransaction
   */

  export type AggregateBankTransaction = {
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  export type BankTransactionAvgAggregateOutputType = {
    id: number | null
    bankAccountId: number | null
    debitAmount: number | null
    creditAmount: number | null
    journalId: number | null
  }

  export type BankTransactionSumAggregateOutputType = {
    id: number | null
    bankAccountId: number | null
    debitAmount: number | null
    creditAmount: number | null
    journalId: number | null
  }

  export type BankTransactionMinAggregateOutputType = {
    id: number | null
    date: Date | null
    bankAccountId: number | null
    debitAmount: number | null
    creditAmount: number | null
    journalId: number | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankTransactionMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    bankAccountId: number | null
    debitAmount: number | null
    creditAmount: number | null
    journalId: number | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankTransactionCountAggregateOutputType = {
    id: number
    date: number
    bankAccountId: number
    debitAmount: number
    creditAmount: number
    journalId: number
    isClosing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankTransactionAvgAggregateInputType = {
    id?: true
    bankAccountId?: true
    debitAmount?: true
    creditAmount?: true
    journalId?: true
  }

  export type BankTransactionSumAggregateInputType = {
    id?: true
    bankAccountId?: true
    debitAmount?: true
    creditAmount?: true
    journalId?: true
  }

  export type BankTransactionMinAggregateInputType = {
    id?: true
    date?: true
    bankAccountId?: true
    debitAmount?: true
    creditAmount?: true
    journalId?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankTransactionMaxAggregateInputType = {
    id?: true
    date?: true
    bankAccountId?: true
    debitAmount?: true
    creditAmount?: true
    journalId?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankTransactionCountAggregateInputType = {
    id?: true
    date?: true
    bankAccountId?: true
    debitAmount?: true
    creditAmount?: true
    journalId?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransaction to aggregate.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankTransactions
    **/
    _count?: true | BankTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankTransactionMaxAggregateInputType
  }

  export type GetBankTransactionAggregateType<T extends BankTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBankTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankTransaction[P]>
      : GetScalarType<T[P], AggregateBankTransaction[P]>
  }




  export type BankTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithAggregationInput | BankTransactionOrderByWithAggregationInput[]
    by: BankTransactionScalarFieldEnum[] | BankTransactionScalarFieldEnum
    having?: BankTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankTransactionCountAggregateInputType | true
    _avg?: BankTransactionAvgAggregateInputType
    _sum?: BankTransactionSumAggregateInputType
    _min?: BankTransactionMinAggregateInputType
    _max?: BankTransactionMaxAggregateInputType
  }

  export type BankTransactionGroupByOutputType = {
    id: number
    date: Date
    bankAccountId: number
    debitAmount: number | null
    creditAmount: number | null
    journalId: number | null
    isClosing: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  type GetBankTransactionGroupByPayload<T extends BankTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BankTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    bankAccountId?: boolean
    debitAmount?: boolean
    creditAmount?: boolean
    journalId?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    journal?: boolean | BankTransaction$journalArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>



  export type BankTransactionSelectScalar = {
    id?: boolean
    date?: boolean
    bankAccountId?: boolean
    debitAmount?: boolean
    creditAmount?: boolean
    journalId?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "bankAccountId" | "debitAmount" | "creditAmount" | "journalId" | "isClosing" | "createdAt" | "updatedAt", ExtArgs["result"]["bankTransaction"]>
  export type BankTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    journal?: boolean | BankTransaction$journalArgs<ExtArgs>
  }

  export type $BankTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankTransaction"
    objects: {
      bankAccount: Prisma.$BankAccountPayload<ExtArgs>
      journal: Prisma.$JournalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      bankAccountId: number
      debitAmount: number | null
      creditAmount: number | null
      journalId: number | null
      isClosing: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankTransaction"]>
    composites: {}
  }

  type BankTransactionGetPayload<S extends boolean | null | undefined | BankTransactionDefaultArgs> = $Result.GetResult<Prisma.$BankTransactionPayload, S>

  type BankTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankTransactionCountAggregateInputType | true
    }

  export interface BankTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankTransaction'], meta: { name: 'BankTransaction' } }
    /**
     * Find zero or one BankTransaction that matches the filter.
     * @param {BankTransactionFindUniqueArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankTransactionFindUniqueArgs>(args: SelectSubset<T, BankTransactionFindUniqueArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankTransactionFindUniqueOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BankTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankTransactionFindFirstArgs>(args?: SelectSubset<T, BankTransactionFindFirstArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BankTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany()
     * 
     * // Get first 10 BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankTransactionFindManyArgs>(args?: SelectSubset<T, BankTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankTransaction.
     * @param {BankTransactionCreateArgs} args - Arguments to create a BankTransaction.
     * @example
     * // Create one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.create({
     *   data: {
     *     // ... data to create a BankTransaction
     *   }
     * })
     * 
     */
    create<T extends BankTransactionCreateArgs>(args: SelectSubset<T, BankTransactionCreateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankTransactions.
     * @param {BankTransactionCreateManyArgs} args - Arguments to create many BankTransactions.
     * @example
     * // Create many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankTransactionCreateManyArgs>(args?: SelectSubset<T, BankTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BankTransaction.
     * @param {BankTransactionDeleteArgs} args - Arguments to delete one BankTransaction.
     * @example
     * // Delete one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.delete({
     *   where: {
     *     // ... filter to delete one BankTransaction
     *   }
     * })
     * 
     */
    delete<T extends BankTransactionDeleteArgs>(args: SelectSubset<T, BankTransactionDeleteArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankTransaction.
     * @param {BankTransactionUpdateArgs} args - Arguments to update one BankTransaction.
     * @example
     * // Update one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankTransactionUpdateArgs>(args: SelectSubset<T, BankTransactionUpdateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankTransactions.
     * @param {BankTransactionDeleteManyArgs} args - Arguments to filter BankTransactions to delete.
     * @example
     * // Delete a few BankTransactions
     * const { count } = await prisma.bankTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankTransactionDeleteManyArgs>(args?: SelectSubset<T, BankTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankTransactionUpdateManyArgs>(args: SelectSubset<T, BankTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankTransaction.
     * @param {BankTransactionUpsertArgs} args - Arguments to update or create a BankTransaction.
     * @example
     * // Update or create a BankTransaction
     * const bankTransaction = await prisma.bankTransaction.upsert({
     *   create: {
     *     // ... data to create a BankTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BankTransactionUpsertArgs>(args: SelectSubset<T, BankTransactionUpsertArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionCountArgs} args - Arguments to filter BankTransactions to count.
     * @example
     * // Count the number of BankTransactions
     * const count = await prisma.bankTransaction.count({
     *   where: {
     *     // ... the filter for the BankTransactions we want to count
     *   }
     * })
    **/
    count<T extends BankTransactionCountArgs>(
      args?: Subset<T, BankTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankTransactionAggregateArgs>(args: Subset<T, BankTransactionAggregateArgs>): Prisma.PrismaPromise<GetBankTransactionAggregateType<T>>

    /**
     * Group by BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BankTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankTransaction model
   */
  readonly fields: BankTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bankAccount<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    journal<T extends BankTransaction$journalArgs<ExtArgs> = {}>(args?: Subset<T, BankTransaction$journalArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankTransaction model
   */
  interface BankTransactionFieldRefs {
    readonly id: FieldRef<"BankTransaction", 'Int'>
    readonly date: FieldRef<"BankTransaction", 'DateTime'>
    readonly bankAccountId: FieldRef<"BankTransaction", 'Int'>
    readonly debitAmount: FieldRef<"BankTransaction", 'Int'>
    readonly creditAmount: FieldRef<"BankTransaction", 'Int'>
    readonly journalId: FieldRef<"BankTransaction", 'Int'>
    readonly isClosing: FieldRef<"BankTransaction", 'Boolean'>
    readonly createdAt: FieldRef<"BankTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"BankTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankTransaction findUnique
   */
  export type BankTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findUniqueOrThrow
   */
  export type BankTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findFirst
   */
  export type BankTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findFirstOrThrow
   */
  export type BankTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findMany
   */
  export type BankTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransactions to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction create
   */
  export type BankTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BankTransaction.
     */
    data: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
  }

  /**
   * BankTransaction createMany
   */
  export type BankTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankTransactions.
     */
    data: BankTransactionCreateManyInput | BankTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankTransaction update
   */
  export type BankTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BankTransaction.
     */
    data: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
    /**
     * Choose, which BankTransaction to update.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction updateMany
   */
  export type BankTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankTransactions.
     */
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BankTransactions to update
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to update.
     */
    limit?: number
  }

  /**
   * BankTransaction upsert
   */
  export type BankTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BankTransaction to update in case it exists.
     */
    where: BankTransactionWhereUniqueInput
    /**
     * In case the BankTransaction found by the `where` argument doesn't exist, create a new BankTransaction with this data.
     */
    create: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
    /**
     * In case the BankTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
  }

  /**
   * BankTransaction delete
   */
  export type BankTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter which BankTransaction to delete.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction deleteMany
   */
  export type BankTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransactions to delete
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to delete.
     */
    limit?: number
  }

  /**
   * BankTransaction.journal
   */
  export type BankTransaction$journalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
  }

  /**
   * BankTransaction without action
   */
  export type BankTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    depoId: number | null
    transactionId: number | null
    fixedJournalId: number | null
    unitPrice: number | null
    quantityAdd: number | null
    quantityLess: number | null
    debitAmount: number | null
    creditAmount: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
    productId: number | null
    depoId: number | null
    transactionId: number | null
    fixedJournalId: number | null
    unitPrice: number | null
    quantityAdd: number | null
    quantityLess: number | null
    debitAmount: number | null
    creditAmount: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    date: Date | null
    productId: number | null
    depoId: number | null
    employeeId: string | null
    transactionId: number | null
    fixedJournalId: number | null
    unitPrice: number | null
    quantityAdd: number | null
    quantityLess: number | null
    debitAmount: number | null
    creditAmount: number | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isFixted: boolean | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    productId: number | null
    depoId: number | null
    employeeId: string | null
    transactionId: number | null
    fixedJournalId: number | null
    unitPrice: number | null
    quantityAdd: number | null
    quantityLess: number | null
    debitAmount: number | null
    creditAmount: number | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isFixted: boolean | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    date: number
    productId: number
    depoId: number
    employeeId: number
    transactionId: number
    fixedJournalId: number
    unitPrice: number
    quantityAdd: number
    quantityLess: number
    debitAmount: number
    creditAmount: number
    isClosing: number
    createdAt: number
    updatedAt: number
    isFixted: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
    productId?: true
    depoId?: true
    transactionId?: true
    fixedJournalId?: true
    unitPrice?: true
    quantityAdd?: true
    quantityLess?: true
    debitAmount?: true
    creditAmount?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
    productId?: true
    depoId?: true
    transactionId?: true
    fixedJournalId?: true
    unitPrice?: true
    quantityAdd?: true
    quantityLess?: true
    debitAmount?: true
    creditAmount?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    date?: true
    productId?: true
    depoId?: true
    employeeId?: true
    transactionId?: true
    fixedJournalId?: true
    unitPrice?: true
    quantityAdd?: true
    quantityLess?: true
    debitAmount?: true
    creditAmount?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
    isFixted?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    date?: true
    productId?: true
    depoId?: true
    employeeId?: true
    transactionId?: true
    fixedJournalId?: true
    unitPrice?: true
    quantityAdd?: true
    quantityLess?: true
    debitAmount?: true
    creditAmount?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
    isFixted?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    date?: true
    productId?: true
    depoId?: true
    employeeId?: true
    transactionId?: true
    fixedJournalId?: true
    unitPrice?: true
    quantityAdd?: true
    quantityLess?: true
    debitAmount?: true
    creditAmount?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
    isFixted?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: number
    date: Date
    productId: number
    depoId: number | null
    employeeId: string | null
    transactionId: number | null
    fixedJournalId: number | null
    unitPrice: number
    quantityAdd: number | null
    quantityLess: number | null
    debitAmount: number | null
    creditAmount: number | null
    isClosing: boolean
    createdAt: Date
    updatedAt: Date
    isFixted: boolean
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    productId?: boolean
    depoId?: boolean
    employeeId?: boolean
    transactionId?: boolean
    fixedJournalId?: boolean
    unitPrice?: boolean
    quantityAdd?: boolean
    quantityLess?: boolean
    debitAmount?: boolean
    creditAmount?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFixted?: boolean
    depo?: boolean | Inventory$depoArgs<ExtArgs>
    fixedJournal?: boolean | Inventory$fixedJournalArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    transactionInfo?: boolean | Inventory$transactionInfoArgs<ExtArgs>
    user?: boolean | Inventory$userArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>



  export type InventorySelectScalar = {
    id?: boolean
    date?: boolean
    productId?: boolean
    depoId?: boolean
    employeeId?: boolean
    transactionId?: boolean
    fixedJournalId?: boolean
    unitPrice?: boolean
    quantityAdd?: boolean
    quantityLess?: boolean
    debitAmount?: boolean
    creditAmount?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFixted?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "productId" | "depoId" | "employeeId" | "transactionId" | "fixedJournalId" | "unitPrice" | "quantityAdd" | "quantityLess" | "debitAmount" | "creditAmount" | "isClosing" | "createdAt" | "updatedAt" | "isFixted", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    depo?: boolean | Inventory$depoArgs<ExtArgs>
    fixedJournal?: boolean | Inventory$fixedJournalArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    transactionInfo?: boolean | Inventory$transactionInfoArgs<ExtArgs>
    user?: boolean | Inventory$userArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      depo: Prisma.$DepoPayload<ExtArgs> | null
      fixedJournal: Prisma.$FixedJournalPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
      transactionInfo: Prisma.$TransactionInfoPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      productId: number
      depoId: number | null
      employeeId: string | null
      transactionId: number | null
      fixedJournalId: number | null
      unitPrice: number
      quantityAdd: number | null
      quantityLess: number | null
      debitAmount: number | null
      creditAmount: number | null
      isClosing: boolean
      createdAt: Date
      updatedAt: Date
      isFixted: boolean
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    depo<T extends Inventory$depoArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$depoArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fixedJournal<T extends Inventory$fixedJournalArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$fixedJournalArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactionInfo<T extends Inventory$transactionInfoArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$transactionInfoArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Inventory$userArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'Int'>
    readonly date: FieldRef<"Inventory", 'DateTime'>
    readonly productId: FieldRef<"Inventory", 'Int'>
    readonly depoId: FieldRef<"Inventory", 'Int'>
    readonly employeeId: FieldRef<"Inventory", 'String'>
    readonly transactionId: FieldRef<"Inventory", 'Int'>
    readonly fixedJournalId: FieldRef<"Inventory", 'Int'>
    readonly unitPrice: FieldRef<"Inventory", 'Float'>
    readonly quantityAdd: FieldRef<"Inventory", 'Float'>
    readonly quantityLess: FieldRef<"Inventory", 'Float'>
    readonly debitAmount: FieldRef<"Inventory", 'Float'>
    readonly creditAmount: FieldRef<"Inventory", 'Float'>
    readonly isClosing: FieldRef<"Inventory", 'Boolean'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
    readonly isFixted: FieldRef<"Inventory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory.depo
   */
  export type Inventory$depoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    where?: DepoWhereInput
  }

  /**
   * Inventory.fixedJournal
   */
  export type Inventory$fixedJournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    where?: FixedJournalWhereInput
  }

  /**
   * Inventory.transactionInfo
   */
  export type Inventory$transactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    where?: TransactionInfoWhereInput
  }

  /**
   * Inventory.user
   */
  export type Inventory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model TransactionInfo
   */

  export type AggregateTransactionInfo = {
    _count: TransactionInfoCountAggregateOutputType | null
    _avg: TransactionInfoAvgAggregateOutputType | null
    _sum: TransactionInfoSumAggregateOutputType | null
    _min: TransactionInfoMinAggregateOutputType | null
    _max: TransactionInfoMaxAggregateOutputType | null
  }

  export type TransactionInfoAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    partyId: number | null
  }

  export type TransactionInfoSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    partyId: number | null
  }

  export type TransactionInfoMinAggregateOutputType = {
    id: number | null
    date: Date | null
    voucherNo: string | null
    invoiceNo: string | null
    chemistId: string | null
    customerId: number | null
    stakeholderId: string | null
    employeeId: string | null
    partyId: number | null
    voucherType: $Enums.VoucherType | null
    paymentType: $Enums.PaymentType | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionInfoMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    voucherNo: string | null
    invoiceNo: string | null
    chemistId: string | null
    customerId: number | null
    stakeholderId: string | null
    employeeId: string | null
    partyId: number | null
    voucherType: $Enums.VoucherType | null
    paymentType: $Enums.PaymentType | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionInfoCountAggregateOutputType = {
    id: number
    date: number
    voucherNo: number
    invoiceNo: number
    chemistId: number
    customerId: number
    stakeholderId: number
    employeeId: number
    partyId: number
    voucherType: number
    paymentType: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionInfoAvgAggregateInputType = {
    id?: true
    customerId?: true
    partyId?: true
  }

  export type TransactionInfoSumAggregateInputType = {
    id?: true
    customerId?: true
    partyId?: true
  }

  export type TransactionInfoMinAggregateInputType = {
    id?: true
    date?: true
    voucherNo?: true
    invoiceNo?: true
    chemistId?: true
    customerId?: true
    stakeholderId?: true
    employeeId?: true
    partyId?: true
    voucherType?: true
    paymentType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionInfoMaxAggregateInputType = {
    id?: true
    date?: true
    voucherNo?: true
    invoiceNo?: true
    chemistId?: true
    customerId?: true
    stakeholderId?: true
    employeeId?: true
    partyId?: true
    voucherType?: true
    paymentType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionInfoCountAggregateInputType = {
    id?: true
    date?: true
    voucherNo?: true
    invoiceNo?: true
    chemistId?: true
    customerId?: true
    stakeholderId?: true
    employeeId?: true
    partyId?: true
    voucherType?: true
    paymentType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionInfo to aggregate.
     */
    where?: TransactionInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionInfos to fetch.
     */
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionInfos
    **/
    _count?: true | TransactionInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionInfoMaxAggregateInputType
  }

  export type GetTransactionInfoAggregateType<T extends TransactionInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionInfo[P]>
      : GetScalarType<T[P], AggregateTransactionInfo[P]>
  }




  export type TransactionInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionInfoWhereInput
    orderBy?: TransactionInfoOrderByWithAggregationInput | TransactionInfoOrderByWithAggregationInput[]
    by: TransactionInfoScalarFieldEnum[] | TransactionInfoScalarFieldEnum
    having?: TransactionInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionInfoCountAggregateInputType | true
    _avg?: TransactionInfoAvgAggregateInputType
    _sum?: TransactionInfoSumAggregateInputType
    _min?: TransactionInfoMinAggregateInputType
    _max?: TransactionInfoMaxAggregateInputType
  }

  export type TransactionInfoGroupByOutputType = {
    id: number
    date: Date
    voucherNo: string
    invoiceNo: string | null
    chemistId: string | null
    customerId: number | null
    stakeholderId: string | null
    employeeId: string | null
    partyId: number | null
    voucherType: $Enums.VoucherType
    paymentType: $Enums.PaymentType | null
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: TransactionInfoCountAggregateOutputType | null
    _avg: TransactionInfoAvgAggregateOutputType | null
    _sum: TransactionInfoSumAggregateOutputType | null
    _min: TransactionInfoMinAggregateOutputType | null
    _max: TransactionInfoMaxAggregateOutputType | null
  }

  type GetTransactionInfoGroupByPayload<T extends TransactionInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionInfoGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionInfoGroupByOutputType[P]>
        }
      >
    >


  export type TransactionInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    voucherNo?: boolean
    invoiceNo?: boolean
    chemistId?: boolean
    customerId?: boolean
    stakeholderId?: boolean
    employeeId?: boolean
    partyId?: boolean
    voucherType?: boolean
    paymentType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventory?: boolean | TransactionInfo$inventoryArgs<ExtArgs>
    journal?: boolean | TransactionInfo$journalArgs<ExtArgs>
    chemist?: boolean | TransactionInfo$chemistArgs<ExtArgs>
    customers?: boolean | TransactionInfo$customersArgs<ExtArgs>
    user?: boolean | TransactionInfo$userArgs<ExtArgs>
    party?: boolean | TransactionInfo$partyArgs<ExtArgs>
    stakeholder?: boolean | TransactionInfo$stakeholderArgs<ExtArgs>
    _count?: boolean | TransactionInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionInfo"]>



  export type TransactionInfoSelectScalar = {
    id?: boolean
    date?: boolean
    voucherNo?: boolean
    invoiceNo?: boolean
    chemistId?: boolean
    customerId?: boolean
    stakeholderId?: boolean
    employeeId?: boolean
    partyId?: boolean
    voucherType?: boolean
    paymentType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "voucherNo" | "invoiceNo" | "chemistId" | "customerId" | "stakeholderId" | "employeeId" | "partyId" | "voucherType" | "paymentType" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionInfo"]>
  export type TransactionInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | TransactionInfo$inventoryArgs<ExtArgs>
    journal?: boolean | TransactionInfo$journalArgs<ExtArgs>
    chemist?: boolean | TransactionInfo$chemistArgs<ExtArgs>
    customers?: boolean | TransactionInfo$customersArgs<ExtArgs>
    user?: boolean | TransactionInfo$userArgs<ExtArgs>
    party?: boolean | TransactionInfo$partyArgs<ExtArgs>
    stakeholder?: boolean | TransactionInfo$stakeholderArgs<ExtArgs>
    _count?: boolean | TransactionInfoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TransactionInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionInfo"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      journal: Prisma.$JournalPayload<ExtArgs>[]
      chemist: Prisma.$ChemistPayload<ExtArgs> | null
      customers: Prisma.$CustomersPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      party: Prisma.$PartyPayload<ExtArgs> | null
      stakeholder: Prisma.$StakeholderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      voucherNo: string
      invoiceNo: string | null
      chemistId: string | null
      customerId: number | null
      stakeholderId: string | null
      employeeId: string | null
      partyId: number | null
      voucherType: $Enums.VoucherType
      paymentType: $Enums.PaymentType | null
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionInfo"]>
    composites: {}
  }

  type TransactionInfoGetPayload<S extends boolean | null | undefined | TransactionInfoDefaultArgs> = $Result.GetResult<Prisma.$TransactionInfoPayload, S>

  type TransactionInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionInfoCountAggregateInputType | true
    }

  export interface TransactionInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionInfo'], meta: { name: 'TransactionInfo' } }
    /**
     * Find zero or one TransactionInfo that matches the filter.
     * @param {TransactionInfoFindUniqueArgs} args - Arguments to find a TransactionInfo
     * @example
     * // Get one TransactionInfo
     * const transactionInfo = await prisma.transactionInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionInfoFindUniqueArgs>(args: SelectSubset<T, TransactionInfoFindUniqueArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionInfoFindUniqueOrThrowArgs} args - Arguments to find a TransactionInfo
     * @example
     * // Get one TransactionInfo
     * const transactionInfo = await prisma.transactionInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionInfoFindFirstArgs} args - Arguments to find a TransactionInfo
     * @example
     * // Get one TransactionInfo
     * const transactionInfo = await prisma.transactionInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionInfoFindFirstArgs>(args?: SelectSubset<T, TransactionInfoFindFirstArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionInfoFindFirstOrThrowArgs} args - Arguments to find a TransactionInfo
     * @example
     * // Get one TransactionInfo
     * const transactionInfo = await prisma.transactionInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionInfos
     * const transactionInfos = await prisma.transactionInfo.findMany()
     * 
     * // Get first 10 TransactionInfos
     * const transactionInfos = await prisma.transactionInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionInfoWithIdOnly = await prisma.transactionInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionInfoFindManyArgs>(args?: SelectSubset<T, TransactionInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionInfo.
     * @param {TransactionInfoCreateArgs} args - Arguments to create a TransactionInfo.
     * @example
     * // Create one TransactionInfo
     * const TransactionInfo = await prisma.transactionInfo.create({
     *   data: {
     *     // ... data to create a TransactionInfo
     *   }
     * })
     * 
     */
    create<T extends TransactionInfoCreateArgs>(args: SelectSubset<T, TransactionInfoCreateArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionInfos.
     * @param {TransactionInfoCreateManyArgs} args - Arguments to create many TransactionInfos.
     * @example
     * // Create many TransactionInfos
     * const transactionInfo = await prisma.transactionInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionInfoCreateManyArgs>(args?: SelectSubset<T, TransactionInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionInfo.
     * @param {TransactionInfoDeleteArgs} args - Arguments to delete one TransactionInfo.
     * @example
     * // Delete one TransactionInfo
     * const TransactionInfo = await prisma.transactionInfo.delete({
     *   where: {
     *     // ... filter to delete one TransactionInfo
     *   }
     * })
     * 
     */
    delete<T extends TransactionInfoDeleteArgs>(args: SelectSubset<T, TransactionInfoDeleteArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionInfo.
     * @param {TransactionInfoUpdateArgs} args - Arguments to update one TransactionInfo.
     * @example
     * // Update one TransactionInfo
     * const transactionInfo = await prisma.transactionInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionInfoUpdateArgs>(args: SelectSubset<T, TransactionInfoUpdateArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionInfos.
     * @param {TransactionInfoDeleteManyArgs} args - Arguments to filter TransactionInfos to delete.
     * @example
     * // Delete a few TransactionInfos
     * const { count } = await prisma.transactionInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionInfoDeleteManyArgs>(args?: SelectSubset<T, TransactionInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionInfos
     * const transactionInfo = await prisma.transactionInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionInfoUpdateManyArgs>(args: SelectSubset<T, TransactionInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionInfo.
     * @param {TransactionInfoUpsertArgs} args - Arguments to update or create a TransactionInfo.
     * @example
     * // Update or create a TransactionInfo
     * const transactionInfo = await prisma.transactionInfo.upsert({
     *   create: {
     *     // ... data to create a TransactionInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionInfo we want to update
     *   }
     * })
     */
    upsert<T extends TransactionInfoUpsertArgs>(args: SelectSubset<T, TransactionInfoUpsertArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionInfoCountArgs} args - Arguments to filter TransactionInfos to count.
     * @example
     * // Count the number of TransactionInfos
     * const count = await prisma.transactionInfo.count({
     *   where: {
     *     // ... the filter for the TransactionInfos we want to count
     *   }
     * })
    **/
    count<T extends TransactionInfoCountArgs>(
      args?: Subset<T, TransactionInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionInfoAggregateArgs>(args: Subset<T, TransactionInfoAggregateArgs>): Prisma.PrismaPromise<GetTransactionInfoAggregateType<T>>

    /**
     * Group by TransactionInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionInfoGroupByArgs['orderBy'] }
        : { orderBy?: TransactionInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionInfo model
   */
  readonly fields: TransactionInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends TransactionInfo$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, TransactionInfo$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journal<T extends TransactionInfo$journalArgs<ExtArgs> = {}>(args?: Subset<T, TransactionInfo$journalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chemist<T extends TransactionInfo$chemistArgs<ExtArgs> = {}>(args?: Subset<T, TransactionInfo$chemistArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customers<T extends TransactionInfo$customersArgs<ExtArgs> = {}>(args?: Subset<T, TransactionInfo$customersArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends TransactionInfo$userArgs<ExtArgs> = {}>(args?: Subset<T, TransactionInfo$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    party<T extends TransactionInfo$partyArgs<ExtArgs> = {}>(args?: Subset<T, TransactionInfo$partyArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stakeholder<T extends TransactionInfo$stakeholderArgs<ExtArgs> = {}>(args?: Subset<T, TransactionInfo$stakeholderArgs<ExtArgs>>): Prisma__StakeholderClient<$Result.GetResult<Prisma.$StakeholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionInfo model
   */
  interface TransactionInfoFieldRefs {
    readonly id: FieldRef<"TransactionInfo", 'Int'>
    readonly date: FieldRef<"TransactionInfo", 'DateTime'>
    readonly voucherNo: FieldRef<"TransactionInfo", 'String'>
    readonly invoiceNo: FieldRef<"TransactionInfo", 'String'>
    readonly chemistId: FieldRef<"TransactionInfo", 'String'>
    readonly customerId: FieldRef<"TransactionInfo", 'Int'>
    readonly stakeholderId: FieldRef<"TransactionInfo", 'String'>
    readonly employeeId: FieldRef<"TransactionInfo", 'String'>
    readonly partyId: FieldRef<"TransactionInfo", 'Int'>
    readonly voucherType: FieldRef<"TransactionInfo", 'VoucherType'>
    readonly paymentType: FieldRef<"TransactionInfo", 'PaymentType'>
    readonly status: FieldRef<"TransactionInfo", 'Status'>
    readonly createdAt: FieldRef<"TransactionInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionInfo findUnique
   */
  export type TransactionInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * Filter, which TransactionInfo to fetch.
     */
    where: TransactionInfoWhereUniqueInput
  }

  /**
   * TransactionInfo findUniqueOrThrow
   */
  export type TransactionInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * Filter, which TransactionInfo to fetch.
     */
    where: TransactionInfoWhereUniqueInput
  }

  /**
   * TransactionInfo findFirst
   */
  export type TransactionInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * Filter, which TransactionInfo to fetch.
     */
    where?: TransactionInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionInfos to fetch.
     */
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionInfos.
     */
    cursor?: TransactionInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionInfos.
     */
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * TransactionInfo findFirstOrThrow
   */
  export type TransactionInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * Filter, which TransactionInfo to fetch.
     */
    where?: TransactionInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionInfos to fetch.
     */
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionInfos.
     */
    cursor?: TransactionInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionInfos.
     */
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * TransactionInfo findMany
   */
  export type TransactionInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * Filter, which TransactionInfos to fetch.
     */
    where?: TransactionInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionInfos to fetch.
     */
    orderBy?: TransactionInfoOrderByWithRelationInput | TransactionInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionInfos.
     */
    cursor?: TransactionInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionInfos.
     */
    skip?: number
    distinct?: TransactionInfoScalarFieldEnum | TransactionInfoScalarFieldEnum[]
  }

  /**
   * TransactionInfo create
   */
  export type TransactionInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionInfo.
     */
    data: XOR<TransactionInfoCreateInput, TransactionInfoUncheckedCreateInput>
  }

  /**
   * TransactionInfo createMany
   */
  export type TransactionInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionInfos.
     */
    data: TransactionInfoCreateManyInput | TransactionInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionInfo update
   */
  export type TransactionInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionInfo.
     */
    data: XOR<TransactionInfoUpdateInput, TransactionInfoUncheckedUpdateInput>
    /**
     * Choose, which TransactionInfo to update.
     */
    where: TransactionInfoWhereUniqueInput
  }

  /**
   * TransactionInfo updateMany
   */
  export type TransactionInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionInfos.
     */
    data: XOR<TransactionInfoUpdateManyMutationInput, TransactionInfoUncheckedUpdateManyInput>
    /**
     * Filter which TransactionInfos to update
     */
    where?: TransactionInfoWhereInput
    /**
     * Limit how many TransactionInfos to update.
     */
    limit?: number
  }

  /**
   * TransactionInfo upsert
   */
  export type TransactionInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionInfo to update in case it exists.
     */
    where: TransactionInfoWhereUniqueInput
    /**
     * In case the TransactionInfo found by the `where` argument doesn't exist, create a new TransactionInfo with this data.
     */
    create: XOR<TransactionInfoCreateInput, TransactionInfoUncheckedCreateInput>
    /**
     * In case the TransactionInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionInfoUpdateInput, TransactionInfoUncheckedUpdateInput>
  }

  /**
   * TransactionInfo delete
   */
  export type TransactionInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    /**
     * Filter which TransactionInfo to delete.
     */
    where: TransactionInfoWhereUniqueInput
  }

  /**
   * TransactionInfo deleteMany
   */
  export type TransactionInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionInfos to delete
     */
    where?: TransactionInfoWhereInput
    /**
     * Limit how many TransactionInfos to delete.
     */
    limit?: number
  }

  /**
   * TransactionInfo.inventory
   */
  export type TransactionInfo$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * TransactionInfo.journal
   */
  export type TransactionInfo$journalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    cursor?: JournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * TransactionInfo.chemist
   */
  export type TransactionInfo$chemistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chemist
     */
    select?: ChemistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chemist
     */
    omit?: ChemistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChemistInclude<ExtArgs> | null
    where?: ChemistWhereInput
  }

  /**
   * TransactionInfo.customers
   */
  export type TransactionInfo$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
  }

  /**
   * TransactionInfo.user
   */
  export type TransactionInfo$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TransactionInfo.party
   */
  export type TransactionInfo$partyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    where?: PartyWhereInput
  }

  /**
   * TransactionInfo.stakeholder
   */
  export type TransactionInfo$stakeholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stakeholder
     */
    select?: StakeholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stakeholder
     */
    omit?: StakeholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StakeholderInclude<ExtArgs> | null
    where?: StakeholderWhereInput
  }

  /**
   * TransactionInfo without action
   */
  export type TransactionInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
  }


  /**
   * Model Journal
   */

  export type AggregateJournal = {
    _count: JournalCountAggregateOutputType | null
    _avg: JournalAvgAggregateOutputType | null
    _sum: JournalSumAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  export type JournalAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    ledgerHeadId: number | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
  }

  export type JournalSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    ledgerHeadId: number | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
  }

  export type JournalMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    ledgerHeadId: number | null
    date: Date | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
    narration: string | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    ledgerHeadId: number | null
    date: Date | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
    narration: string | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalCountAggregateOutputType = {
    id: number
    transactionId: number
    ledgerHeadId: number
    date: number
    depoId: number
    creditAmount: number
    debitAmount: number
    narration: number
    isClosing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalAvgAggregateInputType = {
    id?: true
    transactionId?: true
    ledgerHeadId?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
  }

  export type JournalSumAggregateInputType = {
    id?: true
    transactionId?: true
    ledgerHeadId?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
  }

  export type JournalMinAggregateInputType = {
    id?: true
    transactionId?: true
    ledgerHeadId?: true
    date?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
    narration?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalMaxAggregateInputType = {
    id?: true
    transactionId?: true
    ledgerHeadId?: true
    date?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
    narration?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalCountAggregateInputType = {
    id?: true
    transactionId?: true
    ledgerHeadId?: true
    date?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
    narration?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journal to aggregate.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMaxAggregateInputType
  }

  export type GetJournalAggregateType<T extends JournalAggregateArgs> = {
        [P in keyof T & keyof AggregateJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournal[P]>
      : GetScalarType<T[P], AggregateJournal[P]>
  }




  export type JournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithAggregationInput | JournalOrderByWithAggregationInput[]
    by: JournalScalarFieldEnum[] | JournalScalarFieldEnum
    having?: JournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCountAggregateInputType | true
    _avg?: JournalAvgAggregateInputType
    _sum?: JournalSumAggregateInputType
    _min?: JournalMinAggregateInputType
    _max?: JournalMaxAggregateInputType
  }

  export type JournalGroupByOutputType = {
    id: number
    transactionId: number | null
    ledgerHeadId: number | null
    date: Date
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
    narration: string | null
    isClosing: boolean
    createdAt: Date
    updatedAt: Date
    _count: JournalCountAggregateOutputType | null
    _avg: JournalAvgAggregateOutputType | null
    _sum: JournalSumAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  type GetJournalGroupByPayload<T extends JournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalGroupByOutputType[P]>
            : GetScalarType<T[P], JournalGroupByOutputType[P]>
        }
      >
    >


  export type JournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    ledgerHeadId?: boolean
    date?: boolean
    depoId?: boolean
    creditAmount?: boolean
    debitAmount?: boolean
    narration?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    depo?: boolean | Journal$depoArgs<ExtArgs>
    ledgerHead?: boolean | Journal$ledgerHeadArgs<ExtArgs>
    transactionInfo?: boolean | Journal$transactionInfoArgs<ExtArgs>
    bankTransaction?: boolean | Journal$bankTransactionArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>



  export type JournalSelectScalar = {
    id?: boolean
    transactionId?: boolean
    ledgerHeadId?: boolean
    date?: boolean
    depoId?: boolean
    creditAmount?: boolean
    debitAmount?: boolean
    narration?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "ledgerHeadId" | "date" | "depoId" | "creditAmount" | "debitAmount" | "narration" | "isClosing" | "createdAt" | "updatedAt", ExtArgs["result"]["journal"]>
  export type JournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    depo?: boolean | Journal$depoArgs<ExtArgs>
    ledgerHead?: boolean | Journal$ledgerHeadArgs<ExtArgs>
    transactionInfo?: boolean | Journal$transactionInfoArgs<ExtArgs>
    bankTransaction?: boolean | Journal$bankTransactionArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journal"
    objects: {
      depo: Prisma.$DepoPayload<ExtArgs> | null
      ledgerHead: Prisma.$LedgerHeadPayload<ExtArgs> | null
      transactionInfo: Prisma.$TransactionInfoPayload<ExtArgs> | null
      bankTransaction: Prisma.$BankTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number | null
      ledgerHeadId: number | null
      date: Date
      depoId: number | null
      creditAmount: number | null
      debitAmount: number | null
      narration: string | null
      isClosing: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journal"]>
    composites: {}
  }

  type JournalGetPayload<S extends boolean | null | undefined | JournalDefaultArgs> = $Result.GetResult<Prisma.$JournalPayload, S>

  type JournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalCountAggregateInputType | true
    }

  export interface JournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journal'], meta: { name: 'Journal' } }
    /**
     * Find zero or one Journal that matches the filter.
     * @param {JournalFindUniqueArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFindUniqueArgs>(args: SelectSubset<T, JournalFindUniqueArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Journal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalFindUniqueOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFindFirstArgs>(args?: SelectSubset<T, JournalFindFirstArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journal.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalWithIdOnly = await prisma.journal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFindManyArgs>(args?: SelectSubset<T, JournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Journal.
     * @param {JournalCreateArgs} args - Arguments to create a Journal.
     * @example
     * // Create one Journal
     * const Journal = await prisma.journal.create({
     *   data: {
     *     // ... data to create a Journal
     *   }
     * })
     * 
     */
    create<T extends JournalCreateArgs>(args: SelectSubset<T, JournalCreateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Journals.
     * @param {JournalCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCreateManyArgs>(args?: SelectSubset<T, JournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Journal.
     * @param {JournalDeleteArgs} args - Arguments to delete one Journal.
     * @example
     * // Delete one Journal
     * const Journal = await prisma.journal.delete({
     *   where: {
     *     // ... filter to delete one Journal
     *   }
     * })
     * 
     */
    delete<T extends JournalDeleteArgs>(args: SelectSubset<T, JournalDeleteArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Journal.
     * @param {JournalUpdateArgs} args - Arguments to update one Journal.
     * @example
     * // Update one Journal
     * const journal = await prisma.journal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalUpdateArgs>(args: SelectSubset<T, JournalUpdateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Journals.
     * @param {JournalDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalDeleteManyArgs>(args?: SelectSubset<T, JournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalUpdateManyArgs>(args: SelectSubset<T, JournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Journal.
     * @param {JournalUpsertArgs} args - Arguments to update or create a Journal.
     * @example
     * // Update or create a Journal
     * const journal = await prisma.journal.upsert({
     *   create: {
     *     // ... data to create a Journal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journal we want to update
     *   }
     * })
     */
    upsert<T extends JournalUpsertArgs>(args: SelectSubset<T, JournalUpsertArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journal.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalCountArgs>(
      args?: Subset<T, JournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAggregateArgs>(args: Subset<T, JournalAggregateArgs>): Prisma.PrismaPromise<GetJournalAggregateType<T>>

    /**
     * Group by Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalGroupByArgs['orderBy'] }
        : { orderBy?: JournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journal model
   */
  readonly fields: JournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    depo<T extends Journal$depoArgs<ExtArgs> = {}>(args?: Subset<T, Journal$depoArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ledgerHead<T extends Journal$ledgerHeadArgs<ExtArgs> = {}>(args?: Subset<T, Journal$ledgerHeadArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactionInfo<T extends Journal$transactionInfoArgs<ExtArgs> = {}>(args?: Subset<T, Journal$transactionInfoArgs<ExtArgs>>): Prisma__TransactionInfoClient<$Result.GetResult<Prisma.$TransactionInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bankTransaction<T extends Journal$bankTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Journal$bankTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journal model
   */
  interface JournalFieldRefs {
    readonly id: FieldRef<"Journal", 'Int'>
    readonly transactionId: FieldRef<"Journal", 'Int'>
    readonly ledgerHeadId: FieldRef<"Journal", 'Int'>
    readonly date: FieldRef<"Journal", 'DateTime'>
    readonly depoId: FieldRef<"Journal", 'Int'>
    readonly creditAmount: FieldRef<"Journal", 'Float'>
    readonly debitAmount: FieldRef<"Journal", 'Float'>
    readonly narration: FieldRef<"Journal", 'String'>
    readonly isClosing: FieldRef<"Journal", 'Boolean'>
    readonly createdAt: FieldRef<"Journal", 'DateTime'>
    readonly updatedAt: FieldRef<"Journal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Journal findUnique
   */
  export type JournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findUniqueOrThrow
   */
  export type JournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findFirst
   */
  export type JournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findFirstOrThrow
   */
  export type JournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findMany
   */
  export type JournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal create
   */
  export type JournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to create a Journal.
     */
    data: XOR<JournalCreateInput, JournalUncheckedCreateInput>
  }

  /**
   * Journal createMany
   */
  export type JournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journal update
   */
  export type JournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to update a Journal.
     */
    data: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
    /**
     * Choose, which Journal to update.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal updateMany
   */
  export type JournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
  }

  /**
   * Journal upsert
   */
  export type JournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The filter to search for the Journal to update in case it exists.
     */
    where: JournalWhereUniqueInput
    /**
     * In case the Journal found by the `where` argument doesn't exist, create a new Journal with this data.
     */
    create: XOR<JournalCreateInput, JournalUncheckedCreateInput>
    /**
     * In case the Journal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
  }

  /**
   * Journal delete
   */
  export type JournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter which Journal to delete.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal deleteMany
   */
  export type JournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalWhereInput
    /**
     * Limit how many Journals to delete.
     */
    limit?: number
  }

  /**
   * Journal.depo
   */
  export type Journal$depoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depo
     */
    select?: DepoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depo
     */
    omit?: DepoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepoInclude<ExtArgs> | null
    where?: DepoWhereInput
  }

  /**
   * Journal.ledgerHead
   */
  export type Journal$ledgerHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerHead
     */
    select?: LedgerHeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerHead
     */
    omit?: LedgerHeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerHeadInclude<ExtArgs> | null
    where?: LedgerHeadWhereInput
  }

  /**
   * Journal.transactionInfo
   */
  export type Journal$transactionInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionInfo
     */
    select?: TransactionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionInfo
     */
    omit?: TransactionInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInfoInclude<ExtArgs> | null
    where?: TransactionInfoWhereInput
  }

  /**
   * Journal.bankTransaction
   */
  export type Journal$bankTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    cursor?: BankTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * Journal without action
   */
  export type JournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
  }


  /**
   * Model FixedJournal
   */

  export type AggregateFixedJournal = {
    _count: FixedJournalCountAggregateOutputType | null
    _avg: FixedJournalAvgAggregateOutputType | null
    _sum: FixedJournalSumAggregateOutputType | null
    _min: FixedJournalMinAggregateOutputType | null
    _max: FixedJournalMaxAggregateOutputType | null
  }

  export type FixedJournalAvgAggregateOutputType = {
    id: number | null
    ledgerHeadId: number | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
  }

  export type FixedJournalSumAggregateOutputType = {
    id: number | null
    ledgerHeadId: number | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
  }

  export type FixedJournalMinAggregateOutputType = {
    id: number | null
    date: Date | null
    voucherNo: string | null
    chemistId: string | null
    ledgerHeadId: number | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
    narration: string | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixedJournalMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    voucherNo: string | null
    chemistId: string | null
    ledgerHeadId: number | null
    depoId: number | null
    creditAmount: number | null
    debitAmount: number | null
    narration: string | null
    isClosing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixedJournalCountAggregateOutputType = {
    id: number
    date: number
    voucherNo: number
    chemistId: number
    ledgerHeadId: number
    depoId: number
    creditAmount: number
    debitAmount: number
    narration: number
    isClosing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FixedJournalAvgAggregateInputType = {
    id?: true
    ledgerHeadId?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
  }

  export type FixedJournalSumAggregateInputType = {
    id?: true
    ledgerHeadId?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
  }

  export type FixedJournalMinAggregateInputType = {
    id?: true
    date?: true
    voucherNo?: true
    chemistId?: true
    ledgerHeadId?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
    narration?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixedJournalMaxAggregateInputType = {
    id?: true
    date?: true
    voucherNo?: true
    chemistId?: true
    ledgerHeadId?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
    narration?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixedJournalCountAggregateInputType = {
    id?: true
    date?: true
    voucherNo?: true
    chemistId?: true
    ledgerHeadId?: true
    depoId?: true
    creditAmount?: true
    debitAmount?: true
    narration?: true
    isClosing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FixedJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FixedJournal to aggregate.
     */
    where?: FixedJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedJournals to fetch.
     */
    orderBy?: FixedJournalOrderByWithRelationInput | FixedJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FixedJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FixedJournals
    **/
    _count?: true | FixedJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FixedJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FixedJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FixedJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FixedJournalMaxAggregateInputType
  }

  export type GetFixedJournalAggregateType<T extends FixedJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateFixedJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFixedJournal[P]>
      : GetScalarType<T[P], AggregateFixedJournal[P]>
  }




  export type FixedJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixedJournalWhereInput
    orderBy?: FixedJournalOrderByWithAggregationInput | FixedJournalOrderByWithAggregationInput[]
    by: FixedJournalScalarFieldEnum[] | FixedJournalScalarFieldEnum
    having?: FixedJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FixedJournalCountAggregateInputType | true
    _avg?: FixedJournalAvgAggregateInputType
    _sum?: FixedJournalSumAggregateInputType
    _min?: FixedJournalMinAggregateInputType
    _max?: FixedJournalMaxAggregateInputType
  }

  export type FixedJournalGroupByOutputType = {
    id: number
    date: Date
    voucherNo: string
    chemistId: string
    ledgerHeadId: number
    depoId: number
    creditAmount: number | null
    debitAmount: number | null
    narration: string | null
    isClosing: boolean
    createdAt: Date
    updatedAt: Date
    _count: FixedJournalCountAggregateOutputType | null
    _avg: FixedJournalAvgAggregateOutputType | null
    _sum: FixedJournalSumAggregateOutputType | null
    _min: FixedJournalMinAggregateOutputType | null
    _max: FixedJournalMaxAggregateOutputType | null
  }

  type GetFixedJournalGroupByPayload<T extends FixedJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FixedJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FixedJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FixedJournalGroupByOutputType[P]>
            : GetScalarType<T[P], FixedJournalGroupByOutputType[P]>
        }
      >
    >


  export type FixedJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    voucherNo?: boolean
    chemistId?: boolean
    ledgerHeadId?: boolean
    depoId?: boolean
    creditAmount?: boolean
    debitAmount?: boolean
    narration?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chemist?: boolean | ChemistDefaultArgs<ExtArgs>
    depo?: boolean | DepoDefaultArgs<ExtArgs>
    ledgerHead?: boolean | LedgerHeadDefaultArgs<ExtArgs>
    inventory?: boolean | FixedJournal$inventoryArgs<ExtArgs>
    _count?: boolean | FixedJournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fixedJournal"]>



  export type FixedJournalSelectScalar = {
    id?: boolean
    date?: boolean
    voucherNo?: boolean
    chemistId?: boolean
    ledgerHeadId?: boolean
    depoId?: boolean
    creditAmount?: boolean
    debitAmount?: boolean
    narration?: boolean
    isClosing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FixedJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "voucherNo" | "chemistId" | "ledgerHeadId" | "depoId" | "creditAmount" | "debitAmount" | "narration" | "isClosing" | "createdAt" | "updatedAt", ExtArgs["result"]["fixedJournal"]>
  export type FixedJournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chemist?: boolean | ChemistDefaultArgs<ExtArgs>
    depo?: boolean | DepoDefaultArgs<ExtArgs>
    ledgerHead?: boolean | LedgerHeadDefaultArgs<ExtArgs>
    inventory?: boolean | FixedJournal$inventoryArgs<ExtArgs>
    _count?: boolean | FixedJournalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FixedJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FixedJournal"
    objects: {
      chemist: Prisma.$ChemistPayload<ExtArgs>
      depo: Prisma.$DepoPayload<ExtArgs>
      ledgerHead: Prisma.$LedgerHeadPayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      voucherNo: string
      chemistId: string
      ledgerHeadId: number
      depoId: number
      creditAmount: number | null
      debitAmount: number | null
      narration: string | null
      isClosing: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fixedJournal"]>
    composites: {}
  }

  type FixedJournalGetPayload<S extends boolean | null | undefined | FixedJournalDefaultArgs> = $Result.GetResult<Prisma.$FixedJournalPayload, S>

  type FixedJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FixedJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FixedJournalCountAggregateInputType | true
    }

  export interface FixedJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FixedJournal'], meta: { name: 'FixedJournal' } }
    /**
     * Find zero or one FixedJournal that matches the filter.
     * @param {FixedJournalFindUniqueArgs} args - Arguments to find a FixedJournal
     * @example
     * // Get one FixedJournal
     * const fixedJournal = await prisma.fixedJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FixedJournalFindUniqueArgs>(args: SelectSubset<T, FixedJournalFindUniqueArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FixedJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FixedJournalFindUniqueOrThrowArgs} args - Arguments to find a FixedJournal
     * @example
     * // Get one FixedJournal
     * const fixedJournal = await prisma.fixedJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FixedJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, FixedJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FixedJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedJournalFindFirstArgs} args - Arguments to find a FixedJournal
     * @example
     * // Get one FixedJournal
     * const fixedJournal = await prisma.fixedJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FixedJournalFindFirstArgs>(args?: SelectSubset<T, FixedJournalFindFirstArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FixedJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedJournalFindFirstOrThrowArgs} args - Arguments to find a FixedJournal
     * @example
     * // Get one FixedJournal
     * const fixedJournal = await prisma.fixedJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FixedJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, FixedJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FixedJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FixedJournals
     * const fixedJournals = await prisma.fixedJournal.findMany()
     * 
     * // Get first 10 FixedJournals
     * const fixedJournals = await prisma.fixedJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fixedJournalWithIdOnly = await prisma.fixedJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FixedJournalFindManyArgs>(args?: SelectSubset<T, FixedJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FixedJournal.
     * @param {FixedJournalCreateArgs} args - Arguments to create a FixedJournal.
     * @example
     * // Create one FixedJournal
     * const FixedJournal = await prisma.fixedJournal.create({
     *   data: {
     *     // ... data to create a FixedJournal
     *   }
     * })
     * 
     */
    create<T extends FixedJournalCreateArgs>(args: SelectSubset<T, FixedJournalCreateArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FixedJournals.
     * @param {FixedJournalCreateManyArgs} args - Arguments to create many FixedJournals.
     * @example
     * // Create many FixedJournals
     * const fixedJournal = await prisma.fixedJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FixedJournalCreateManyArgs>(args?: SelectSubset<T, FixedJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FixedJournal.
     * @param {FixedJournalDeleteArgs} args - Arguments to delete one FixedJournal.
     * @example
     * // Delete one FixedJournal
     * const FixedJournal = await prisma.fixedJournal.delete({
     *   where: {
     *     // ... filter to delete one FixedJournal
     *   }
     * })
     * 
     */
    delete<T extends FixedJournalDeleteArgs>(args: SelectSubset<T, FixedJournalDeleteArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FixedJournal.
     * @param {FixedJournalUpdateArgs} args - Arguments to update one FixedJournal.
     * @example
     * // Update one FixedJournal
     * const fixedJournal = await prisma.fixedJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FixedJournalUpdateArgs>(args: SelectSubset<T, FixedJournalUpdateArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FixedJournals.
     * @param {FixedJournalDeleteManyArgs} args - Arguments to filter FixedJournals to delete.
     * @example
     * // Delete a few FixedJournals
     * const { count } = await prisma.fixedJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FixedJournalDeleteManyArgs>(args?: SelectSubset<T, FixedJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FixedJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FixedJournals
     * const fixedJournal = await prisma.fixedJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FixedJournalUpdateManyArgs>(args: SelectSubset<T, FixedJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FixedJournal.
     * @param {FixedJournalUpsertArgs} args - Arguments to update or create a FixedJournal.
     * @example
     * // Update or create a FixedJournal
     * const fixedJournal = await prisma.fixedJournal.upsert({
     *   create: {
     *     // ... data to create a FixedJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FixedJournal we want to update
     *   }
     * })
     */
    upsert<T extends FixedJournalUpsertArgs>(args: SelectSubset<T, FixedJournalUpsertArgs<ExtArgs>>): Prisma__FixedJournalClient<$Result.GetResult<Prisma.$FixedJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FixedJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedJournalCountArgs} args - Arguments to filter FixedJournals to count.
     * @example
     * // Count the number of FixedJournals
     * const count = await prisma.fixedJournal.count({
     *   where: {
     *     // ... the filter for the FixedJournals we want to count
     *   }
     * })
    **/
    count<T extends FixedJournalCountArgs>(
      args?: Subset<T, FixedJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FixedJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FixedJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FixedJournalAggregateArgs>(args: Subset<T, FixedJournalAggregateArgs>): Prisma.PrismaPromise<GetFixedJournalAggregateType<T>>

    /**
     * Group by FixedJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FixedJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FixedJournalGroupByArgs['orderBy'] }
        : { orderBy?: FixedJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FixedJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFixedJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FixedJournal model
   */
  readonly fields: FixedJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FixedJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FixedJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chemist<T extends ChemistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChemistDefaultArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    depo<T extends DepoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepoDefaultArgs<ExtArgs>>): Prisma__DepoClient<$Result.GetResult<Prisma.$DepoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ledgerHead<T extends LedgerHeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LedgerHeadDefaultArgs<ExtArgs>>): Prisma__LedgerHeadClient<$Result.GetResult<Prisma.$LedgerHeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventory<T extends FixedJournal$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, FixedJournal$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FixedJournal model
   */
  interface FixedJournalFieldRefs {
    readonly id: FieldRef<"FixedJournal", 'Int'>
    readonly date: FieldRef<"FixedJournal", 'DateTime'>
    readonly voucherNo: FieldRef<"FixedJournal", 'String'>
    readonly chemistId: FieldRef<"FixedJournal", 'String'>
    readonly ledgerHeadId: FieldRef<"FixedJournal", 'Int'>
    readonly depoId: FieldRef<"FixedJournal", 'Int'>
    readonly creditAmount: FieldRef<"FixedJournal", 'Float'>
    readonly debitAmount: FieldRef<"FixedJournal", 'Float'>
    readonly narration: FieldRef<"FixedJournal", 'String'>
    readonly isClosing: FieldRef<"FixedJournal", 'Boolean'>
    readonly createdAt: FieldRef<"FixedJournal", 'DateTime'>
    readonly updatedAt: FieldRef<"FixedJournal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FixedJournal findUnique
   */
  export type FixedJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * Filter, which FixedJournal to fetch.
     */
    where: FixedJournalWhereUniqueInput
  }

  /**
   * FixedJournal findUniqueOrThrow
   */
  export type FixedJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * Filter, which FixedJournal to fetch.
     */
    where: FixedJournalWhereUniqueInput
  }

  /**
   * FixedJournal findFirst
   */
  export type FixedJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * Filter, which FixedJournal to fetch.
     */
    where?: FixedJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedJournals to fetch.
     */
    orderBy?: FixedJournalOrderByWithRelationInput | FixedJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FixedJournals.
     */
    cursor?: FixedJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FixedJournals.
     */
    distinct?: FixedJournalScalarFieldEnum | FixedJournalScalarFieldEnum[]
  }

  /**
   * FixedJournal findFirstOrThrow
   */
  export type FixedJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * Filter, which FixedJournal to fetch.
     */
    where?: FixedJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedJournals to fetch.
     */
    orderBy?: FixedJournalOrderByWithRelationInput | FixedJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FixedJournals.
     */
    cursor?: FixedJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FixedJournals.
     */
    distinct?: FixedJournalScalarFieldEnum | FixedJournalScalarFieldEnum[]
  }

  /**
   * FixedJournal findMany
   */
  export type FixedJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * Filter, which FixedJournals to fetch.
     */
    where?: FixedJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedJournals to fetch.
     */
    orderBy?: FixedJournalOrderByWithRelationInput | FixedJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FixedJournals.
     */
    cursor?: FixedJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedJournals.
     */
    skip?: number
    distinct?: FixedJournalScalarFieldEnum | FixedJournalScalarFieldEnum[]
  }

  /**
   * FixedJournal create
   */
  export type FixedJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * The data needed to create a FixedJournal.
     */
    data: XOR<FixedJournalCreateInput, FixedJournalUncheckedCreateInput>
  }

  /**
   * FixedJournal createMany
   */
  export type FixedJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FixedJournals.
     */
    data: FixedJournalCreateManyInput | FixedJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FixedJournal update
   */
  export type FixedJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * The data needed to update a FixedJournal.
     */
    data: XOR<FixedJournalUpdateInput, FixedJournalUncheckedUpdateInput>
    /**
     * Choose, which FixedJournal to update.
     */
    where: FixedJournalWhereUniqueInput
  }

  /**
   * FixedJournal updateMany
   */
  export type FixedJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FixedJournals.
     */
    data: XOR<FixedJournalUpdateManyMutationInput, FixedJournalUncheckedUpdateManyInput>
    /**
     * Filter which FixedJournals to update
     */
    where?: FixedJournalWhereInput
    /**
     * Limit how many FixedJournals to update.
     */
    limit?: number
  }

  /**
   * FixedJournal upsert
   */
  export type FixedJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * The filter to search for the FixedJournal to update in case it exists.
     */
    where: FixedJournalWhereUniqueInput
    /**
     * In case the FixedJournal found by the `where` argument doesn't exist, create a new FixedJournal with this data.
     */
    create: XOR<FixedJournalCreateInput, FixedJournalUncheckedCreateInput>
    /**
     * In case the FixedJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FixedJournalUpdateInput, FixedJournalUncheckedUpdateInput>
  }

  /**
   * FixedJournal delete
   */
  export type FixedJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
    /**
     * Filter which FixedJournal to delete.
     */
    where: FixedJournalWhereUniqueInput
  }

  /**
   * FixedJournal deleteMany
   */
  export type FixedJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FixedJournals to delete
     */
    where?: FixedJournalWhereInput
    /**
     * Limit how many FixedJournals to delete.
     */
    limit?: number
  }

  /**
   * FixedJournal.inventory
   */
  export type FixedJournal$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * FixedJournal without action
   */
  export type FixedJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedJournal
     */
    select?: FixedJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedJournal
     */
    omit?: FixedJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedJournalInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    discount: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    discount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    chemistId: string | null
    orderNo: string | null
    date: Date | null
    discount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    chemistId: string | null
    orderNo: string | null
    date: Date | null
    discount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    employeeId: number
    chemistId: number
    orderNo: number
    date: number
    discount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    discount?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    discount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    employeeId?: true
    chemistId?: true
    orderNo?: true
    date?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    employeeId?: true
    chemistId?: true
    orderNo?: true
    date?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    employeeId?: true
    chemistId?: true
    orderNo?: true
    date?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    employeeId: string
    chemistId: string
    orderNo: string
    date: Date
    discount: number | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    chemistId?: boolean
    orderNo?: boolean
    date?: boolean
    discount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | Order$orderItemArgs<ExtArgs>
    orderStatus?: boolean | Order$orderStatusArgs<ExtArgs>
    chemist?: boolean | ChemistDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    id?: boolean
    employeeId?: boolean
    chemistId?: boolean
    orderNo?: boolean
    date?: boolean
    discount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "chemistId" | "orderNo" | "date" | "discount" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | Order$orderItemArgs<ExtArgs>
    orderStatus?: boolean | Order$orderStatusArgs<ExtArgs>
    chemist?: boolean | ChemistDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      orderStatus: Prisma.$OrderStatusPayload<ExtArgs>[]
      chemist: Prisma.$ChemistPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      chemistId: string
      orderNo: string
      date: Date
      discount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends Order$orderItemArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderStatus<T extends Order$orderStatusArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chemist<T extends ChemistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChemistDefaultArgs<ExtArgs>>): Prisma__ChemistClient<$Result.GetResult<Prisma.$ChemistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly employeeId: FieldRef<"Order", 'String'>
    readonly chemistId: FieldRef<"Order", 'String'>
    readonly orderNo: FieldRef<"Order", 'String'>
    readonly date: FieldRef<"Order", 'DateTime'>
    readonly discount: FieldRef<"Order", 'Int'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.orderItem
   */
  export type Order$orderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.orderStatus
   */
  export type Order$orderStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    where?: OrderStatusWhereInput
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    cursor?: OrderStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quintity: number | null
    tpRate: number | null
    amount: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quintity: number | null
    tpRate: number | null
    amount: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quintity: number | null
    tpRate: number | null
    amount: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quintity: number | null
    tpRate: number | null
    amount: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quintity: number
    tpRate: number
    amount: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quintity?: true
    tpRate?: true
    amount?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quintity?: true
    tpRate?: true
    amount?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quintity?: true
    tpRate?: true
    amount?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quintity?: true
    tpRate?: true
    amount?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quintity?: true
    tpRate?: true
    amount?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    productId: number
    quintity: number
    tpRate: number
    amount: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quintity?: boolean
    tpRate?: boolean
    amount?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>



  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quintity?: boolean
    tpRate?: boolean
    amount?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quintity" | "tpRate" | "amount", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      productId: number
      quintity: number
      tpRate: number
      amount: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
    readonly quintity: FieldRef<"OrderItem", 'Int'>
    readonly tpRate: FieldRef<"OrderItem", 'Int'>
    readonly amount: FieldRef<"OrderItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model OrderStatus
   */

  export type AggregateOrderStatus = {
    _count: OrderStatusCountAggregateOutputType | null
    _avg: OrderStatusAvgAggregateOutputType | null
    _sum: OrderStatusSumAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  export type OrderStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type OrderStatusSumAggregateOutputType = {
    id: number | null
  }

  export type OrderStatusMinAggregateOutputType = {
    id: number | null
    orderNo: string | null
    status: $Enums.OrdStatus | null
    comments: string | null
    dateTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderStatusMaxAggregateOutputType = {
    id: number | null
    orderNo: string | null
    status: $Enums.OrdStatus | null
    comments: string | null
    dateTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderStatusCountAggregateOutputType = {
    id: number
    orderNo: number
    status: number
    comments: number
    dateTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderStatusAvgAggregateInputType = {
    id?: true
  }

  export type OrderStatusSumAggregateInputType = {
    id?: true
  }

  export type OrderStatusMinAggregateInputType = {
    id?: true
    orderNo?: true
    status?: true
    comments?: true
    dateTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderStatusMaxAggregateInputType = {
    id?: true
    orderNo?: true
    status?: true
    comments?: true
    dateTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderStatusCountAggregateInputType = {
    id?: true
    orderNo?: true
    status?: true
    comments?: true
    dateTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatus to aggregate.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderStatuses
    **/
    _count?: true | OrderStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStatusMaxAggregateInputType
  }

  export type GetOrderStatusAggregateType<T extends OrderStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStatus[P]>
      : GetScalarType<T[P], AggregateOrderStatus[P]>
  }




  export type OrderStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusWhereInput
    orderBy?: OrderStatusOrderByWithAggregationInput | OrderStatusOrderByWithAggregationInput[]
    by: OrderStatusScalarFieldEnum[] | OrderStatusScalarFieldEnum
    having?: OrderStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStatusCountAggregateInputType | true
    _avg?: OrderStatusAvgAggregateInputType
    _sum?: OrderStatusSumAggregateInputType
    _min?: OrderStatusMinAggregateInputType
    _max?: OrderStatusMaxAggregateInputType
  }

  export type OrderStatusGroupByOutputType = {
    id: number
    orderNo: string | null
    status: $Enums.OrdStatus
    comments: string | null
    dateTime: Date
    createdAt: Date
    updatedAt: Date
    _count: OrderStatusCountAggregateOutputType | null
    _avg: OrderStatusAvgAggregateOutputType | null
    _sum: OrderStatusSumAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  type GetOrderStatusGroupByPayload<T extends OrderStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
        }
      >
    >


  export type OrderStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    status?: boolean
    comments?: boolean
    dateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderStatus$orderArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatus"]>



  export type OrderStatusSelectScalar = {
    id?: boolean
    orderNo?: boolean
    status?: boolean
    comments?: boolean
    dateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNo" | "status" | "comments" | "dateTime" | "createdAt" | "updatedAt", ExtArgs["result"]["orderStatus"]>
  export type OrderStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderStatus$orderArgs<ExtArgs>
  }

  export type $OrderStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderStatus"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNo: string | null
      status: $Enums.OrdStatus
      comments: string | null
      dateTime: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderStatus"]>
    composites: {}
  }

  type OrderStatusGetPayload<S extends boolean | null | undefined | OrderStatusDefaultArgs> = $Result.GetResult<Prisma.$OrderStatusPayload, S>

  type OrderStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderStatusCountAggregateInputType | true
    }

  export interface OrderStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderStatus'], meta: { name: 'OrderStatus' } }
    /**
     * Find zero or one OrderStatus that matches the filter.
     * @param {OrderStatusFindUniqueArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderStatusFindUniqueArgs>(args: SelectSubset<T, OrderStatusFindUniqueArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderStatusFindUniqueOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderStatusFindFirstArgs>(args?: SelectSubset<T, OrderStatusFindFirstArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany()
     * 
     * // Get first 10 OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderStatusWithIdOnly = await prisma.orderStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderStatusFindManyArgs>(args?: SelectSubset<T, OrderStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderStatus.
     * @param {OrderStatusCreateArgs} args - Arguments to create a OrderStatus.
     * @example
     * // Create one OrderStatus
     * const OrderStatus = await prisma.orderStatus.create({
     *   data: {
     *     // ... data to create a OrderStatus
     *   }
     * })
     * 
     */
    create<T extends OrderStatusCreateArgs>(args: SelectSubset<T, OrderStatusCreateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderStatuses.
     * @param {OrderStatusCreateManyArgs} args - Arguments to create many OrderStatuses.
     * @example
     * // Create many OrderStatuses
     * const orderStatus = await prisma.orderStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderStatusCreateManyArgs>(args?: SelectSubset<T, OrderStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderStatus.
     * @param {OrderStatusDeleteArgs} args - Arguments to delete one OrderStatus.
     * @example
     * // Delete one OrderStatus
     * const OrderStatus = await prisma.orderStatus.delete({
     *   where: {
     *     // ... filter to delete one OrderStatus
     *   }
     * })
     * 
     */
    delete<T extends OrderStatusDeleteArgs>(args: SelectSubset<T, OrderStatusDeleteArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderStatus.
     * @param {OrderStatusUpdateArgs} args - Arguments to update one OrderStatus.
     * @example
     * // Update one OrderStatus
     * const orderStatus = await prisma.orderStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderStatusUpdateArgs>(args: SelectSubset<T, OrderStatusUpdateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderStatuses.
     * @param {OrderStatusDeleteManyArgs} args - Arguments to filter OrderStatuses to delete.
     * @example
     * // Delete a few OrderStatuses
     * const { count } = await prisma.orderStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderStatusDeleteManyArgs>(args?: SelectSubset<T, OrderStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderStatuses
     * const orderStatus = await prisma.orderStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderStatusUpdateManyArgs>(args: SelectSubset<T, OrderStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderStatus.
     * @param {OrderStatusUpsertArgs} args - Arguments to update or create a OrderStatus.
     * @example
     * // Update or create a OrderStatus
     * const orderStatus = await prisma.orderStatus.upsert({
     *   create: {
     *     // ... data to create a OrderStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStatus we want to update
     *   }
     * })
     */
    upsert<T extends OrderStatusUpsertArgs>(args: SelectSubset<T, OrderStatusUpsertArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusCountArgs} args - Arguments to filter OrderStatuses to count.
     * @example
     * // Count the number of OrderStatuses
     * const count = await prisma.orderStatus.count({
     *   where: {
     *     // ... the filter for the OrderStatuses we want to count
     *   }
     * })
    **/
    count<T extends OrderStatusCountArgs>(
      args?: Subset<T, OrderStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStatusAggregateArgs>(args: Subset<T, OrderStatusAggregateArgs>): Prisma.PrismaPromise<GetOrderStatusAggregateType<T>>

    /**
     * Group by OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStatusGroupByArgs['orderBy'] }
        : { orderBy?: OrderStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderStatus model
   */
  readonly fields: OrderStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderStatus$orderArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatus$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderStatus model
   */
  interface OrderStatusFieldRefs {
    readonly id: FieldRef<"OrderStatus", 'Int'>
    readonly orderNo: FieldRef<"OrderStatus", 'String'>
    readonly status: FieldRef<"OrderStatus", 'OrdStatus'>
    readonly comments: FieldRef<"OrderStatus", 'String'>
    readonly dateTime: FieldRef<"OrderStatus", 'DateTime'>
    readonly createdAt: FieldRef<"OrderStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderStatus findUnique
   */
  export type OrderStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findUniqueOrThrow
   */
  export type OrderStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findFirst
   */
  export type OrderStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findFirstOrThrow
   */
  export type OrderStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findMany
   */
  export type OrderStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatuses to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus create
   */
  export type OrderStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderStatus.
     */
    data: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
  }

  /**
   * OrderStatus createMany
   */
  export type OrderStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderStatuses.
     */
    data: OrderStatusCreateManyInput | OrderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStatus update
   */
  export type OrderStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderStatus.
     */
    data: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
    /**
     * Choose, which OrderStatus to update.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus updateMany
   */
  export type OrderStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderStatuses.
     */
    data: XOR<OrderStatusUpdateManyMutationInput, OrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatuses to update
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to update.
     */
    limit?: number
  }

  /**
   * OrderStatus upsert
   */
  export type OrderStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderStatus to update in case it exists.
     */
    where: OrderStatusWhereUniqueInput
    /**
     * In case the OrderStatus found by the `where` argument doesn't exist, create a new OrderStatus with this data.
     */
    create: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
    /**
     * In case the OrderStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
  }

  /**
   * OrderStatus delete
   */
  export type OrderStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter which OrderStatus to delete.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus deleteMany
   */
  export type OrderStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatuses to delete
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to delete.
     */
    limit?: number
  }

  /**
   * OrderStatus.order
   */
  export type OrderStatus$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * OrderStatus without action
   */
  export type OrderStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    date: Date | null
    time: string | null
    status: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    date: Date | null
    time: string | null
    status: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    time: number
    status: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    time?: true
    status?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    time?: true
    status?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    time?: true
    status?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: number
    employeeId: string
    date: Date
    time: string
    status: string
    comments: string
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    time?: boolean
    status?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>



  export type AttendanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    time?: boolean
    status?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "time" | "status" | "comments" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      date: Date
      time: string
      status: string
      comments: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'Int'>
    readonly employeeId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly time: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'String'>
    readonly comments: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Overtime
   */

  export type AggregateOvertime = {
    _count: OvertimeCountAggregateOutputType | null
    _avg: OvertimeAvgAggregateOutputType | null
    _sum: OvertimeSumAggregateOutputType | null
    _min: OvertimeMinAggregateOutputType | null
    _max: OvertimeMaxAggregateOutputType | null
  }

  export type OvertimeAvgAggregateOutputType = {
    id: number | null
  }

  export type OvertimeSumAggregateOutputType = {
    id: number | null
  }

  export type OvertimeMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    overtimeDate: Date | null
    overtimeHours: string | null
    others: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimeMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    overtimeDate: Date | null
    overtimeHours: string | null
    others: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimeCountAggregateOutputType = {
    id: number
    employeeId: number
    overtimeDate: number
    overtimeHours: number
    others: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OvertimeAvgAggregateInputType = {
    id?: true
  }

  export type OvertimeSumAggregateInputType = {
    id?: true
  }

  export type OvertimeMinAggregateInputType = {
    id?: true
    employeeId?: true
    overtimeDate?: true
    overtimeHours?: true
    others?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimeMaxAggregateInputType = {
    id?: true
    employeeId?: true
    overtimeDate?: true
    overtimeHours?: true
    others?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimeCountAggregateInputType = {
    id?: true
    employeeId?: true
    overtimeDate?: true
    overtimeHours?: true
    others?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OvertimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overtime to aggregate.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Overtimes
    **/
    _count?: true | OvertimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OvertimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OvertimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OvertimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OvertimeMaxAggregateInputType
  }

  export type GetOvertimeAggregateType<T extends OvertimeAggregateArgs> = {
        [P in keyof T & keyof AggregateOvertime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOvertime[P]>
      : GetScalarType<T[P], AggregateOvertime[P]>
  }




  export type OvertimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithAggregationInput | OvertimeOrderByWithAggregationInput[]
    by: OvertimeScalarFieldEnum[] | OvertimeScalarFieldEnum
    having?: OvertimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OvertimeCountAggregateInputType | true
    _avg?: OvertimeAvgAggregateInputType
    _sum?: OvertimeSumAggregateInputType
    _min?: OvertimeMinAggregateInputType
    _max?: OvertimeMaxAggregateInputType
  }

  export type OvertimeGroupByOutputType = {
    id: number
    employeeId: string
    overtimeDate: Date
    overtimeHours: string
    others: string
    createdAt: Date
    updatedAt: Date
    _count: OvertimeCountAggregateOutputType | null
    _avg: OvertimeAvgAggregateOutputType | null
    _sum: OvertimeSumAggregateOutputType | null
    _min: OvertimeMinAggregateOutputType | null
    _max: OvertimeMaxAggregateOutputType | null
  }

  type GetOvertimeGroupByPayload<T extends OvertimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OvertimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OvertimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OvertimeGroupByOutputType[P]>
            : GetScalarType<T[P], OvertimeGroupByOutputType[P]>
        }
      >
    >


  export type OvertimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    overtimeDate?: boolean
    overtimeHours?: boolean
    others?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overtime"]>



  export type OvertimeSelectScalar = {
    id?: boolean
    employeeId?: boolean
    overtimeDate?: boolean
    overtimeHours?: boolean
    others?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OvertimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "overtimeDate" | "overtimeHours" | "others" | "createdAt" | "updatedAt", ExtArgs["result"]["overtime"]>
  export type OvertimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OvertimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Overtime"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      overtimeDate: Date
      overtimeHours: string
      others: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["overtime"]>
    composites: {}
  }

  type OvertimeGetPayload<S extends boolean | null | undefined | OvertimeDefaultArgs> = $Result.GetResult<Prisma.$OvertimePayload, S>

  type OvertimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OvertimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OvertimeCountAggregateInputType | true
    }

  export interface OvertimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Overtime'], meta: { name: 'Overtime' } }
    /**
     * Find zero or one Overtime that matches the filter.
     * @param {OvertimeFindUniqueArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OvertimeFindUniqueArgs>(args: SelectSubset<T, OvertimeFindUniqueArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Overtime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OvertimeFindUniqueOrThrowArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OvertimeFindUniqueOrThrowArgs>(args: SelectSubset<T, OvertimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindFirstArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OvertimeFindFirstArgs>(args?: SelectSubset<T, OvertimeFindFirstArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindFirstOrThrowArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OvertimeFindFirstOrThrowArgs>(args?: SelectSubset<T, OvertimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Overtimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Overtimes
     * const overtimes = await prisma.overtime.findMany()
     * 
     * // Get first 10 Overtimes
     * const overtimes = await prisma.overtime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overtimeWithIdOnly = await prisma.overtime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OvertimeFindManyArgs>(args?: SelectSubset<T, OvertimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Overtime.
     * @param {OvertimeCreateArgs} args - Arguments to create a Overtime.
     * @example
     * // Create one Overtime
     * const Overtime = await prisma.overtime.create({
     *   data: {
     *     // ... data to create a Overtime
     *   }
     * })
     * 
     */
    create<T extends OvertimeCreateArgs>(args: SelectSubset<T, OvertimeCreateArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Overtimes.
     * @param {OvertimeCreateManyArgs} args - Arguments to create many Overtimes.
     * @example
     * // Create many Overtimes
     * const overtime = await prisma.overtime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OvertimeCreateManyArgs>(args?: SelectSubset<T, OvertimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Overtime.
     * @param {OvertimeDeleteArgs} args - Arguments to delete one Overtime.
     * @example
     * // Delete one Overtime
     * const Overtime = await prisma.overtime.delete({
     *   where: {
     *     // ... filter to delete one Overtime
     *   }
     * })
     * 
     */
    delete<T extends OvertimeDeleteArgs>(args: SelectSubset<T, OvertimeDeleteArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Overtime.
     * @param {OvertimeUpdateArgs} args - Arguments to update one Overtime.
     * @example
     * // Update one Overtime
     * const overtime = await prisma.overtime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OvertimeUpdateArgs>(args: SelectSubset<T, OvertimeUpdateArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Overtimes.
     * @param {OvertimeDeleteManyArgs} args - Arguments to filter Overtimes to delete.
     * @example
     * // Delete a few Overtimes
     * const { count } = await prisma.overtime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OvertimeDeleteManyArgs>(args?: SelectSubset<T, OvertimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Overtimes
     * const overtime = await prisma.overtime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OvertimeUpdateManyArgs>(args: SelectSubset<T, OvertimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Overtime.
     * @param {OvertimeUpsertArgs} args - Arguments to update or create a Overtime.
     * @example
     * // Update or create a Overtime
     * const overtime = await prisma.overtime.upsert({
     *   create: {
     *     // ... data to create a Overtime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Overtime we want to update
     *   }
     * })
     */
    upsert<T extends OvertimeUpsertArgs>(args: SelectSubset<T, OvertimeUpsertArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Overtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeCountArgs} args - Arguments to filter Overtimes to count.
     * @example
     * // Count the number of Overtimes
     * const count = await prisma.overtime.count({
     *   where: {
     *     // ... the filter for the Overtimes we want to count
     *   }
     * })
    **/
    count<T extends OvertimeCountArgs>(
      args?: Subset<T, OvertimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OvertimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Overtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OvertimeAggregateArgs>(args: Subset<T, OvertimeAggregateArgs>): Prisma.PrismaPromise<GetOvertimeAggregateType<T>>

    /**
     * Group by Overtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OvertimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OvertimeGroupByArgs['orderBy'] }
        : { orderBy?: OvertimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OvertimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOvertimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Overtime model
   */
  readonly fields: OvertimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Overtime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OvertimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Overtime model
   */
  interface OvertimeFieldRefs {
    readonly id: FieldRef<"Overtime", 'Int'>
    readonly employeeId: FieldRef<"Overtime", 'String'>
    readonly overtimeDate: FieldRef<"Overtime", 'DateTime'>
    readonly overtimeHours: FieldRef<"Overtime", 'String'>
    readonly others: FieldRef<"Overtime", 'String'>
    readonly createdAt: FieldRef<"Overtime", 'DateTime'>
    readonly updatedAt: FieldRef<"Overtime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Overtime findUnique
   */
  export type OvertimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime findUniqueOrThrow
   */
  export type OvertimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime findFirst
   */
  export type OvertimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overtimes.
     */
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime findFirstOrThrow
   */
  export type OvertimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overtimes.
     */
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime findMany
   */
  export type OvertimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtimes to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime create
   */
  export type OvertimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The data needed to create a Overtime.
     */
    data: XOR<OvertimeCreateInput, OvertimeUncheckedCreateInput>
  }

  /**
   * Overtime createMany
   */
  export type OvertimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Overtimes.
     */
    data: OvertimeCreateManyInput | OvertimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Overtime update
   */
  export type OvertimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The data needed to update a Overtime.
     */
    data: XOR<OvertimeUpdateInput, OvertimeUncheckedUpdateInput>
    /**
     * Choose, which Overtime to update.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime updateMany
   */
  export type OvertimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Overtimes.
     */
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyInput>
    /**
     * Filter which Overtimes to update
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to update.
     */
    limit?: number
  }

  /**
   * Overtime upsert
   */
  export type OvertimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The filter to search for the Overtime to update in case it exists.
     */
    where: OvertimeWhereUniqueInput
    /**
     * In case the Overtime found by the `where` argument doesn't exist, create a new Overtime with this data.
     */
    create: XOR<OvertimeCreateInput, OvertimeUncheckedCreateInput>
    /**
     * In case the Overtime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OvertimeUpdateInput, OvertimeUncheckedUpdateInput>
  }

  /**
   * Overtime delete
   */
  export type OvertimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter which Overtime to delete.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime deleteMany
   */
  export type OvertimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overtimes to delete
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to delete.
     */
    limit?: number
  }

  /**
   * Overtime without action
   */
  export type OvertimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
  }


  /**
   * Model LeaveType
   */

  export type AggregateLeaveType = {
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  export type LeaveTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type LeaveTypeSumAggregateOutputType = {
    id: number | null
  }

  export type LeaveTypeMinAggregateOutputType = {
    id: number | null
    leaveName: string | null
  }

  export type LeaveTypeMaxAggregateOutputType = {
    id: number | null
    leaveName: string | null
  }

  export type LeaveTypeCountAggregateOutputType = {
    id: number
    leaveName: number
    _all: number
  }


  export type LeaveTypeAvgAggregateInputType = {
    id?: true
  }

  export type LeaveTypeSumAggregateInputType = {
    id?: true
  }

  export type LeaveTypeMinAggregateInputType = {
    id?: true
    leaveName?: true
  }

  export type LeaveTypeMaxAggregateInputType = {
    id?: true
    leaveName?: true
  }

  export type LeaveTypeCountAggregateInputType = {
    id?: true
    leaveName?: true
    _all?: true
  }

  export type LeaveTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveType to aggregate.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveTypes
    **/
    _count?: true | LeaveTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type GetLeaveTypeAggregateType<T extends LeaveTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveType[P]>
      : GetScalarType<T[P], AggregateLeaveType[P]>
  }




  export type LeaveTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithAggregationInput | LeaveTypeOrderByWithAggregationInput[]
    by: LeaveTypeScalarFieldEnum[] | LeaveTypeScalarFieldEnum
    having?: LeaveTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveTypeCountAggregateInputType | true
    _avg?: LeaveTypeAvgAggregateInputType
    _sum?: LeaveTypeSumAggregateInputType
    _min?: LeaveTypeMinAggregateInputType
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type LeaveTypeGroupByOutputType = {
    id: number
    leaveName: string
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  type GetLeaveTypeGroupByPayload<T extends LeaveTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
        }
      >
    >


  export type LeaveTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveName?: boolean
    leves?: boolean | LeaveType$levesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>



  export type LeaveTypeSelectScalar = {
    id?: boolean
    leaveName?: boolean
  }

  export type LeaveTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaveName", ExtArgs["result"]["leaveType"]>
  export type LeaveTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leves?: boolean | LeaveType$levesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LeaveTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveType"
    objects: {
      leves: Prisma.$LevesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      leaveName: string
    }, ExtArgs["result"]["leaveType"]>
    composites: {}
  }

  type LeaveTypeGetPayload<S extends boolean | null | undefined | LeaveTypeDefaultArgs> = $Result.GetResult<Prisma.$LeaveTypePayload, S>

  type LeaveTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveTypeCountAggregateInputType | true
    }

  export interface LeaveTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveType'], meta: { name: 'LeaveType' } }
    /**
     * Find zero or one LeaveType that matches the filter.
     * @param {LeaveTypeFindUniqueArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveTypeFindUniqueArgs>(args: SelectSubset<T, LeaveTypeFindUniqueArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveTypeFindUniqueOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveTypeFindFirstArgs>(args?: SelectSubset<T, LeaveTypeFindFirstArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany()
     * 
     * // Get first 10 LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveTypeFindManyArgs>(args?: SelectSubset<T, LeaveTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveType.
     * @param {LeaveTypeCreateArgs} args - Arguments to create a LeaveType.
     * @example
     * // Create one LeaveType
     * const LeaveType = await prisma.leaveType.create({
     *   data: {
     *     // ... data to create a LeaveType
     *   }
     * })
     * 
     */
    create<T extends LeaveTypeCreateArgs>(args: SelectSubset<T, LeaveTypeCreateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveTypes.
     * @param {LeaveTypeCreateManyArgs} args - Arguments to create many LeaveTypes.
     * @example
     * // Create many LeaveTypes
     * const leaveType = await prisma.leaveType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveTypeCreateManyArgs>(args?: SelectSubset<T, LeaveTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LeaveType.
     * @param {LeaveTypeDeleteArgs} args - Arguments to delete one LeaveType.
     * @example
     * // Delete one LeaveType
     * const LeaveType = await prisma.leaveType.delete({
     *   where: {
     *     // ... filter to delete one LeaveType
     *   }
     * })
     * 
     */
    delete<T extends LeaveTypeDeleteArgs>(args: SelectSubset<T, LeaveTypeDeleteArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveType.
     * @param {LeaveTypeUpdateArgs} args - Arguments to update one LeaveType.
     * @example
     * // Update one LeaveType
     * const leaveType = await prisma.leaveType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveTypeUpdateArgs>(args: SelectSubset<T, LeaveTypeUpdateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveTypes.
     * @param {LeaveTypeDeleteManyArgs} args - Arguments to filter LeaveTypes to delete.
     * @example
     * // Delete a few LeaveTypes
     * const { count } = await prisma.leaveType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveTypeDeleteManyArgs>(args?: SelectSubset<T, LeaveTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveTypes
     * const leaveType = await prisma.leaveType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveTypeUpdateManyArgs>(args: SelectSubset<T, LeaveTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveType.
     * @param {LeaveTypeUpsertArgs} args - Arguments to update or create a LeaveType.
     * @example
     * // Update or create a LeaveType
     * const leaveType = await prisma.leaveType.upsert({
     *   create: {
     *     // ... data to create a LeaveType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveType we want to update
     *   }
     * })
     */
    upsert<T extends LeaveTypeUpsertArgs>(args: SelectSubset<T, LeaveTypeUpsertArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeCountArgs} args - Arguments to filter LeaveTypes to count.
     * @example
     * // Count the number of LeaveTypes
     * const count = await prisma.leaveType.count({
     *   where: {
     *     // ... the filter for the LeaveTypes we want to count
     *   }
     * })
    **/
    count<T extends LeaveTypeCountArgs>(
      args?: Subset<T, LeaveTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveTypeAggregateArgs>(args: Subset<T, LeaveTypeAggregateArgs>): Prisma.PrismaPromise<GetLeaveTypeAggregateType<T>>

    /**
     * Group by LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveTypeGroupByArgs['orderBy'] }
        : { orderBy?: LeaveTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveType model
   */
  readonly fields: LeaveTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leves<T extends LeaveType$levesArgs<ExtArgs> = {}>(args?: Subset<T, LeaveType$levesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveType model
   */
  interface LeaveTypeFieldRefs {
    readonly id: FieldRef<"LeaveType", 'Int'>
    readonly leaveName: FieldRef<"LeaveType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LeaveType findUnique
   */
  export type LeaveTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findUniqueOrThrow
   */
  export type LeaveTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findFirst
   */
  export type LeaveTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findFirstOrThrow
   */
  export type LeaveTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findMany
   */
  export type LeaveTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveTypes to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType create
   */
  export type LeaveTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveType.
     */
    data: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
  }

  /**
   * LeaveType createMany
   */
  export type LeaveTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveTypes.
     */
    data: LeaveTypeCreateManyInput | LeaveTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveType update
   */
  export type LeaveTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveType.
     */
    data: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
    /**
     * Choose, which LeaveType to update.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType updateMany
   */
  export type LeaveTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveTypes.
     */
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaveTypes to update
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to update.
     */
    limit?: number
  }

  /**
   * LeaveType upsert
   */
  export type LeaveTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveType to update in case it exists.
     */
    where: LeaveTypeWhereUniqueInput
    /**
     * In case the LeaveType found by the `where` argument doesn't exist, create a new LeaveType with this data.
     */
    create: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
    /**
     * In case the LeaveType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
  }

  /**
   * LeaveType delete
   */
  export type LeaveTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter which LeaveType to delete.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType deleteMany
   */
  export type LeaveTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveTypes to delete
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to delete.
     */
    limit?: number
  }

  /**
   * LeaveType.leves
   */
  export type LeaveType$levesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    where?: LevesWhereInput
    orderBy?: LevesOrderByWithRelationInput | LevesOrderByWithRelationInput[]
    cursor?: LevesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevesScalarFieldEnum | LevesScalarFieldEnum[]
  }

  /**
   * LeaveType without action
   */
  export type LeaveTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
  }


  /**
   * Model Leves
   */

  export type AggregateLeves = {
    _count: LevesCountAggregateOutputType | null
    _avg: LevesAvgAggregateOutputType | null
    _sum: LevesSumAggregateOutputType | null
    _min: LevesMinAggregateOutputType | null
    _max: LevesMaxAggregateOutputType | null
  }

  export type LevesAvgAggregateOutputType = {
    id: number | null
    leaveTypeId: number | null
  }

  export type LevesSumAggregateOutputType = {
    id: number | null
    leaveTypeId: number | null
  }

  export type LevesMinAggregateOutputType = {
    id: number | null
    leaveTypeId: number | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    leaveReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevesMaxAggregateOutputType = {
    id: number | null
    leaveTypeId: number | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    leaveReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevesCountAggregateOutputType = {
    id: number
    leaveTypeId: number
    employeeId: number
    startDate: number
    endDate: number
    leaveReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevesAvgAggregateInputType = {
    id?: true
    leaveTypeId?: true
  }

  export type LevesSumAggregateInputType = {
    id?: true
    leaveTypeId?: true
  }

  export type LevesMinAggregateInputType = {
    id?: true
    leaveTypeId?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    leaveReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevesMaxAggregateInputType = {
    id?: true
    leaveTypeId?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    leaveReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevesCountAggregateInputType = {
    id?: true
    leaveTypeId?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    leaveReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leves to aggregate.
     */
    where?: LevesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leves to fetch.
     */
    orderBy?: LevesOrderByWithRelationInput | LevesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leves
    **/
    _count?: true | LevesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevesMaxAggregateInputType
  }

  export type GetLevesAggregateType<T extends LevesAggregateArgs> = {
        [P in keyof T & keyof AggregateLeves]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeves[P]>
      : GetScalarType<T[P], AggregateLeves[P]>
  }




  export type LevesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevesWhereInput
    orderBy?: LevesOrderByWithAggregationInput | LevesOrderByWithAggregationInput[]
    by: LevesScalarFieldEnum[] | LevesScalarFieldEnum
    having?: LevesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevesCountAggregateInputType | true
    _avg?: LevesAvgAggregateInputType
    _sum?: LevesSumAggregateInputType
    _min?: LevesMinAggregateInputType
    _max?: LevesMaxAggregateInputType
  }

  export type LevesGroupByOutputType = {
    id: number
    leaveTypeId: number
    employeeId: string
    startDate: Date
    endDate: Date
    leaveReason: string
    createdAt: Date
    updatedAt: Date
    _count: LevesCountAggregateOutputType | null
    _avg: LevesAvgAggregateOutputType | null
    _sum: LevesSumAggregateOutputType | null
    _min: LevesMinAggregateOutputType | null
    _max: LevesMaxAggregateOutputType | null
  }

  type GetLevesGroupByPayload<T extends LevesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevesGroupByOutputType[P]>
            : GetScalarType<T[P], LevesGroupByOutputType[P]>
        }
      >
    >


  export type LevesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveTypeId?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leves"]>



  export type LevesSelectScalar = {
    id?: boolean
    leaveTypeId?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LevesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaveTypeId" | "employeeId" | "startDate" | "endDate" | "leaveReason" | "createdAt" | "updatedAt", ExtArgs["result"]["leves"]>
  export type LevesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }

  export type $LevesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leves"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      leaveType: Prisma.$LeaveTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      leaveTypeId: number
      employeeId: string
      startDate: Date
      endDate: Date
      leaveReason: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leves"]>
    composites: {}
  }

  type LevesGetPayload<S extends boolean | null | undefined | LevesDefaultArgs> = $Result.GetResult<Prisma.$LevesPayload, S>

  type LevesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevesCountAggregateInputType | true
    }

  export interface LevesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leves'], meta: { name: 'Leves' } }
    /**
     * Find zero or one Leves that matches the filter.
     * @param {LevesFindUniqueArgs} args - Arguments to find a Leves
     * @example
     * // Get one Leves
     * const leves = await prisma.leves.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevesFindUniqueArgs>(args: SelectSubset<T, LevesFindUniqueArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leves that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevesFindUniqueOrThrowArgs} args - Arguments to find a Leves
     * @example
     * // Get one Leves
     * const leves = await prisma.leves.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevesFindUniqueOrThrowArgs>(args: SelectSubset<T, LevesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevesFindFirstArgs} args - Arguments to find a Leves
     * @example
     * // Get one Leves
     * const leves = await prisma.leves.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevesFindFirstArgs>(args?: SelectSubset<T, LevesFindFirstArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leves that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevesFindFirstOrThrowArgs} args - Arguments to find a Leves
     * @example
     * // Get one Leves
     * const leves = await prisma.leves.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevesFindFirstOrThrowArgs>(args?: SelectSubset<T, LevesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leves
     * const leves = await prisma.leves.findMany()
     * 
     * // Get first 10 Leves
     * const leves = await prisma.leves.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levesWithIdOnly = await prisma.leves.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevesFindManyArgs>(args?: SelectSubset<T, LevesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leves.
     * @param {LevesCreateArgs} args - Arguments to create a Leves.
     * @example
     * // Create one Leves
     * const Leves = await prisma.leves.create({
     *   data: {
     *     // ... data to create a Leves
     *   }
     * })
     * 
     */
    create<T extends LevesCreateArgs>(args: SelectSubset<T, LevesCreateArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leves.
     * @param {LevesCreateManyArgs} args - Arguments to create many Leves.
     * @example
     * // Create many Leves
     * const leves = await prisma.leves.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevesCreateManyArgs>(args?: SelectSubset<T, LevesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leves.
     * @param {LevesDeleteArgs} args - Arguments to delete one Leves.
     * @example
     * // Delete one Leves
     * const Leves = await prisma.leves.delete({
     *   where: {
     *     // ... filter to delete one Leves
     *   }
     * })
     * 
     */
    delete<T extends LevesDeleteArgs>(args: SelectSubset<T, LevesDeleteArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leves.
     * @param {LevesUpdateArgs} args - Arguments to update one Leves.
     * @example
     * // Update one Leves
     * const leves = await prisma.leves.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevesUpdateArgs>(args: SelectSubset<T, LevesUpdateArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leves.
     * @param {LevesDeleteManyArgs} args - Arguments to filter Leves to delete.
     * @example
     * // Delete a few Leves
     * const { count } = await prisma.leves.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevesDeleteManyArgs>(args?: SelectSubset<T, LevesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leves
     * const leves = await prisma.leves.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevesUpdateManyArgs>(args: SelectSubset<T, LevesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leves.
     * @param {LevesUpsertArgs} args - Arguments to update or create a Leves.
     * @example
     * // Update or create a Leves
     * const leves = await prisma.leves.upsert({
     *   create: {
     *     // ... data to create a Leves
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leves we want to update
     *   }
     * })
     */
    upsert<T extends LevesUpsertArgs>(args: SelectSubset<T, LevesUpsertArgs<ExtArgs>>): Prisma__LevesClient<$Result.GetResult<Prisma.$LevesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevesCountArgs} args - Arguments to filter Leves to count.
     * @example
     * // Count the number of Leves
     * const count = await prisma.leves.count({
     *   where: {
     *     // ... the filter for the Leves we want to count
     *   }
     * })
    **/
    count<T extends LevesCountArgs>(
      args?: Subset<T, LevesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevesAggregateArgs>(args: Subset<T, LevesAggregateArgs>): Prisma.PrismaPromise<GetLevesAggregateType<T>>

    /**
     * Group by Leves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevesGroupByArgs['orderBy'] }
        : { orderBy?: LevesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leves model
   */
  readonly fields: LevesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leves.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaveType<T extends LeaveTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveTypeDefaultArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leves model
   */
  interface LevesFieldRefs {
    readonly id: FieldRef<"Leves", 'Int'>
    readonly leaveTypeId: FieldRef<"Leves", 'Int'>
    readonly employeeId: FieldRef<"Leves", 'String'>
    readonly startDate: FieldRef<"Leves", 'DateTime'>
    readonly endDate: FieldRef<"Leves", 'DateTime'>
    readonly leaveReason: FieldRef<"Leves", 'String'>
    readonly createdAt: FieldRef<"Leves", 'DateTime'>
    readonly updatedAt: FieldRef<"Leves", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leves findUnique
   */
  export type LevesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * Filter, which Leves to fetch.
     */
    where: LevesWhereUniqueInput
  }

  /**
   * Leves findUniqueOrThrow
   */
  export type LevesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * Filter, which Leves to fetch.
     */
    where: LevesWhereUniqueInput
  }

  /**
   * Leves findFirst
   */
  export type LevesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * Filter, which Leves to fetch.
     */
    where?: LevesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leves to fetch.
     */
    orderBy?: LevesOrderByWithRelationInput | LevesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leves.
     */
    cursor?: LevesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leves.
     */
    distinct?: LevesScalarFieldEnum | LevesScalarFieldEnum[]
  }

  /**
   * Leves findFirstOrThrow
   */
  export type LevesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * Filter, which Leves to fetch.
     */
    where?: LevesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leves to fetch.
     */
    orderBy?: LevesOrderByWithRelationInput | LevesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leves.
     */
    cursor?: LevesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leves.
     */
    distinct?: LevesScalarFieldEnum | LevesScalarFieldEnum[]
  }

  /**
   * Leves findMany
   */
  export type LevesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * Filter, which Leves to fetch.
     */
    where?: LevesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leves to fetch.
     */
    orderBy?: LevesOrderByWithRelationInput | LevesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leves.
     */
    cursor?: LevesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leves.
     */
    skip?: number
    distinct?: LevesScalarFieldEnum | LevesScalarFieldEnum[]
  }

  /**
   * Leves create
   */
  export type LevesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * The data needed to create a Leves.
     */
    data: XOR<LevesCreateInput, LevesUncheckedCreateInput>
  }

  /**
   * Leves createMany
   */
  export type LevesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leves.
     */
    data: LevesCreateManyInput | LevesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leves update
   */
  export type LevesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * The data needed to update a Leves.
     */
    data: XOR<LevesUpdateInput, LevesUncheckedUpdateInput>
    /**
     * Choose, which Leves to update.
     */
    where: LevesWhereUniqueInput
  }

  /**
   * Leves updateMany
   */
  export type LevesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leves.
     */
    data: XOR<LevesUpdateManyMutationInput, LevesUncheckedUpdateManyInput>
    /**
     * Filter which Leves to update
     */
    where?: LevesWhereInput
    /**
     * Limit how many Leves to update.
     */
    limit?: number
  }

  /**
   * Leves upsert
   */
  export type LevesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * The filter to search for the Leves to update in case it exists.
     */
    where: LevesWhereUniqueInput
    /**
     * In case the Leves found by the `where` argument doesn't exist, create a new Leves with this data.
     */
    create: XOR<LevesCreateInput, LevesUncheckedCreateInput>
    /**
     * In case the Leves was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevesUpdateInput, LevesUncheckedUpdateInput>
  }

  /**
   * Leves delete
   */
  export type LevesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
    /**
     * Filter which Leves to delete.
     */
    where: LevesWhereUniqueInput
  }

  /**
   * Leves deleteMany
   */
  export type LevesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leves to delete
     */
    where?: LevesWhereInput
    /**
     * Limit how many Leves to delete.
     */
    limit?: number
  }

  /**
   * Leves without action
   */
  export type LevesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leves
     */
    select?: LevesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leves
     */
    omit?: LevesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevesInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeBankDetails
   */

  export type AggregateEmployeeBankDetails = {
    _count: EmployeeBankDetailsCountAggregateOutputType | null
    _avg: EmployeeBankDetailsAvgAggregateOutputType | null
    _sum: EmployeeBankDetailsSumAggregateOutputType | null
    _min: EmployeeBankDetailsMinAggregateOutputType | null
    _max: EmployeeBankDetailsMaxAggregateOutputType | null
  }

  export type EmployeeBankDetailsAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeeBankDetailsSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeeBankDetailsMinAggregateOutputType = {
    id: number | null
    bankName: string | null
    bankAccountNumber: string | null
    branchName: string | null
    ifsscode: string | null
  }

  export type EmployeeBankDetailsMaxAggregateOutputType = {
    id: number | null
    bankName: string | null
    bankAccountNumber: string | null
    branchName: string | null
    ifsscode: string | null
  }

  export type EmployeeBankDetailsCountAggregateOutputType = {
    id: number
    bankName: number
    bankAccountNumber: number
    branchName: number
    ifsscode: number
    _all: number
  }


  export type EmployeeBankDetailsAvgAggregateInputType = {
    id?: true
  }

  export type EmployeeBankDetailsSumAggregateInputType = {
    id?: true
  }

  export type EmployeeBankDetailsMinAggregateInputType = {
    id?: true
    bankName?: true
    bankAccountNumber?: true
    branchName?: true
    ifsscode?: true
  }

  export type EmployeeBankDetailsMaxAggregateInputType = {
    id?: true
    bankName?: true
    bankAccountNumber?: true
    branchName?: true
    ifsscode?: true
  }

  export type EmployeeBankDetailsCountAggregateInputType = {
    id?: true
    bankName?: true
    bankAccountNumber?: true
    branchName?: true
    ifsscode?: true
    _all?: true
  }

  export type EmployeeBankDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBankDetails to aggregate.
     */
    where?: EmployeeBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBankDetails to fetch.
     */
    orderBy?: EmployeeBankDetailsOrderByWithRelationInput | EmployeeBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeBankDetails
    **/
    _count?: true | EmployeeBankDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeBankDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeBankDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeBankDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeBankDetailsMaxAggregateInputType
  }

  export type GetEmployeeBankDetailsAggregateType<T extends EmployeeBankDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeBankDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeBankDetails[P]>
      : GetScalarType<T[P], AggregateEmployeeBankDetails[P]>
  }




  export type EmployeeBankDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBankDetailsWhereInput
    orderBy?: EmployeeBankDetailsOrderByWithAggregationInput | EmployeeBankDetailsOrderByWithAggregationInput[]
    by: EmployeeBankDetailsScalarFieldEnum[] | EmployeeBankDetailsScalarFieldEnum
    having?: EmployeeBankDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeBankDetailsCountAggregateInputType | true
    _avg?: EmployeeBankDetailsAvgAggregateInputType
    _sum?: EmployeeBankDetailsSumAggregateInputType
    _min?: EmployeeBankDetailsMinAggregateInputType
    _max?: EmployeeBankDetailsMaxAggregateInputType
  }

  export type EmployeeBankDetailsGroupByOutputType = {
    id: number
    bankName: string
    bankAccountNumber: string
    branchName: string
    ifsscode: string
    _count: EmployeeBankDetailsCountAggregateOutputType | null
    _avg: EmployeeBankDetailsAvgAggregateOutputType | null
    _sum: EmployeeBankDetailsSumAggregateOutputType | null
    _min: EmployeeBankDetailsMinAggregateOutputType | null
    _max: EmployeeBankDetailsMaxAggregateOutputType | null
  }

  type GetEmployeeBankDetailsGroupByPayload<T extends EmployeeBankDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeBankDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeBankDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeBankDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeBankDetailsGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeBankDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    bankAccountNumber?: boolean
    branchName?: boolean
    ifsscode?: boolean
  }, ExtArgs["result"]["employeeBankDetails"]>



  export type EmployeeBankDetailsSelectScalar = {
    id?: boolean
    bankName?: boolean
    bankAccountNumber?: boolean
    branchName?: boolean
    ifsscode?: boolean
  }

  export type EmployeeBankDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bankName" | "bankAccountNumber" | "branchName" | "ifsscode", ExtArgs["result"]["employeeBankDetails"]>

  export type $EmployeeBankDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeBankDetails"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bankName: string
      bankAccountNumber: string
      branchName: string
      ifsscode: string
    }, ExtArgs["result"]["employeeBankDetails"]>
    composites: {}
  }

  type EmployeeBankDetailsGetPayload<S extends boolean | null | undefined | EmployeeBankDetailsDefaultArgs> = $Result.GetResult<Prisma.$EmployeeBankDetailsPayload, S>

  type EmployeeBankDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeBankDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeBankDetailsCountAggregateInputType | true
    }

  export interface EmployeeBankDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeBankDetails'], meta: { name: 'EmployeeBankDetails' } }
    /**
     * Find zero or one EmployeeBankDetails that matches the filter.
     * @param {EmployeeBankDetailsFindUniqueArgs} args - Arguments to find a EmployeeBankDetails
     * @example
     * // Get one EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeBankDetailsFindUniqueArgs>(args: SelectSubset<T, EmployeeBankDetailsFindUniqueArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeBankDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeBankDetailsFindUniqueOrThrowArgs} args - Arguments to find a EmployeeBankDetails
     * @example
     * // Get one EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeBankDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeBankDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeBankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBankDetailsFindFirstArgs} args - Arguments to find a EmployeeBankDetails
     * @example
     * // Get one EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeBankDetailsFindFirstArgs>(args?: SelectSubset<T, EmployeeBankDetailsFindFirstArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeBankDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBankDetailsFindFirstOrThrowArgs} args - Arguments to find a EmployeeBankDetails
     * @example
     * // Get one EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeBankDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeBankDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeBankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBankDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.findMany()
     * 
     * // Get first 10 EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeBankDetailsWithIdOnly = await prisma.employeeBankDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeBankDetailsFindManyArgs>(args?: SelectSubset<T, EmployeeBankDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeBankDetails.
     * @param {EmployeeBankDetailsCreateArgs} args - Arguments to create a EmployeeBankDetails.
     * @example
     * // Create one EmployeeBankDetails
     * const EmployeeBankDetails = await prisma.employeeBankDetails.create({
     *   data: {
     *     // ... data to create a EmployeeBankDetails
     *   }
     * })
     * 
     */
    create<T extends EmployeeBankDetailsCreateArgs>(args: SelectSubset<T, EmployeeBankDetailsCreateArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeBankDetails.
     * @param {EmployeeBankDetailsCreateManyArgs} args - Arguments to create many EmployeeBankDetails.
     * @example
     * // Create many EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeBankDetailsCreateManyArgs>(args?: SelectSubset<T, EmployeeBankDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeBankDetails.
     * @param {EmployeeBankDetailsDeleteArgs} args - Arguments to delete one EmployeeBankDetails.
     * @example
     * // Delete one EmployeeBankDetails
     * const EmployeeBankDetails = await prisma.employeeBankDetails.delete({
     *   where: {
     *     // ... filter to delete one EmployeeBankDetails
     *   }
     * })
     * 
     */
    delete<T extends EmployeeBankDetailsDeleteArgs>(args: SelectSubset<T, EmployeeBankDetailsDeleteArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeBankDetails.
     * @param {EmployeeBankDetailsUpdateArgs} args - Arguments to update one EmployeeBankDetails.
     * @example
     * // Update one EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeBankDetailsUpdateArgs>(args: SelectSubset<T, EmployeeBankDetailsUpdateArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeBankDetails.
     * @param {EmployeeBankDetailsDeleteManyArgs} args - Arguments to filter EmployeeBankDetails to delete.
     * @example
     * // Delete a few EmployeeBankDetails
     * const { count } = await prisma.employeeBankDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeBankDetailsDeleteManyArgs>(args?: SelectSubset<T, EmployeeBankDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBankDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeBankDetailsUpdateManyArgs>(args: SelectSubset<T, EmployeeBankDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeBankDetails.
     * @param {EmployeeBankDetailsUpsertArgs} args - Arguments to update or create a EmployeeBankDetails.
     * @example
     * // Update or create a EmployeeBankDetails
     * const employeeBankDetails = await prisma.employeeBankDetails.upsert({
     *   create: {
     *     // ... data to create a EmployeeBankDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeBankDetails we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeBankDetailsUpsertArgs>(args: SelectSubset<T, EmployeeBankDetailsUpsertArgs<ExtArgs>>): Prisma__EmployeeBankDetailsClient<$Result.GetResult<Prisma.$EmployeeBankDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBankDetailsCountArgs} args - Arguments to filter EmployeeBankDetails to count.
     * @example
     * // Count the number of EmployeeBankDetails
     * const count = await prisma.employeeBankDetails.count({
     *   where: {
     *     // ... the filter for the EmployeeBankDetails we want to count
     *   }
     * })
    **/
    count<T extends EmployeeBankDetailsCountArgs>(
      args?: Subset<T, EmployeeBankDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeBankDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBankDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeBankDetailsAggregateArgs>(args: Subset<T, EmployeeBankDetailsAggregateArgs>): Prisma.PrismaPromise<GetEmployeeBankDetailsAggregateType<T>>

    /**
     * Group by EmployeeBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBankDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeBankDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeBankDetailsGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeBankDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeBankDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeBankDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeBankDetails model
   */
  readonly fields: EmployeeBankDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeBankDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeBankDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeBankDetails model
   */
  interface EmployeeBankDetailsFieldRefs {
    readonly id: FieldRef<"EmployeeBankDetails", 'Int'>
    readonly bankName: FieldRef<"EmployeeBankDetails", 'String'>
    readonly bankAccountNumber: FieldRef<"EmployeeBankDetails", 'String'>
    readonly branchName: FieldRef<"EmployeeBankDetails", 'String'>
    readonly ifsscode: FieldRef<"EmployeeBankDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeBankDetails findUnique
   */
  export type EmployeeBankDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * Filter, which EmployeeBankDetails to fetch.
     */
    where: EmployeeBankDetailsWhereUniqueInput
  }

  /**
   * EmployeeBankDetails findUniqueOrThrow
   */
  export type EmployeeBankDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * Filter, which EmployeeBankDetails to fetch.
     */
    where: EmployeeBankDetailsWhereUniqueInput
  }

  /**
   * EmployeeBankDetails findFirst
   */
  export type EmployeeBankDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * Filter, which EmployeeBankDetails to fetch.
     */
    where?: EmployeeBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBankDetails to fetch.
     */
    orderBy?: EmployeeBankDetailsOrderByWithRelationInput | EmployeeBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBankDetails.
     */
    cursor?: EmployeeBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBankDetails.
     */
    distinct?: EmployeeBankDetailsScalarFieldEnum | EmployeeBankDetailsScalarFieldEnum[]
  }

  /**
   * EmployeeBankDetails findFirstOrThrow
   */
  export type EmployeeBankDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * Filter, which EmployeeBankDetails to fetch.
     */
    where?: EmployeeBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBankDetails to fetch.
     */
    orderBy?: EmployeeBankDetailsOrderByWithRelationInput | EmployeeBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBankDetails.
     */
    cursor?: EmployeeBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBankDetails.
     */
    distinct?: EmployeeBankDetailsScalarFieldEnum | EmployeeBankDetailsScalarFieldEnum[]
  }

  /**
   * EmployeeBankDetails findMany
   */
  export type EmployeeBankDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * Filter, which EmployeeBankDetails to fetch.
     */
    where?: EmployeeBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBankDetails to fetch.
     */
    orderBy?: EmployeeBankDetailsOrderByWithRelationInput | EmployeeBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeBankDetails.
     */
    cursor?: EmployeeBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBankDetails.
     */
    skip?: number
    distinct?: EmployeeBankDetailsScalarFieldEnum | EmployeeBankDetailsScalarFieldEnum[]
  }

  /**
   * EmployeeBankDetails create
   */
  export type EmployeeBankDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * The data needed to create a EmployeeBankDetails.
     */
    data: XOR<EmployeeBankDetailsCreateInput, EmployeeBankDetailsUncheckedCreateInput>
  }

  /**
   * EmployeeBankDetails createMany
   */
  export type EmployeeBankDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeBankDetails.
     */
    data: EmployeeBankDetailsCreateManyInput | EmployeeBankDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeBankDetails update
   */
  export type EmployeeBankDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * The data needed to update a EmployeeBankDetails.
     */
    data: XOR<EmployeeBankDetailsUpdateInput, EmployeeBankDetailsUncheckedUpdateInput>
    /**
     * Choose, which EmployeeBankDetails to update.
     */
    where: EmployeeBankDetailsWhereUniqueInput
  }

  /**
   * EmployeeBankDetails updateMany
   */
  export type EmployeeBankDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeBankDetails.
     */
    data: XOR<EmployeeBankDetailsUpdateManyMutationInput, EmployeeBankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeBankDetails to update
     */
    where?: EmployeeBankDetailsWhereInput
    /**
     * Limit how many EmployeeBankDetails to update.
     */
    limit?: number
  }

  /**
   * EmployeeBankDetails upsert
   */
  export type EmployeeBankDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * The filter to search for the EmployeeBankDetails to update in case it exists.
     */
    where: EmployeeBankDetailsWhereUniqueInput
    /**
     * In case the EmployeeBankDetails found by the `where` argument doesn't exist, create a new EmployeeBankDetails with this data.
     */
    create: XOR<EmployeeBankDetailsCreateInput, EmployeeBankDetailsUncheckedCreateInput>
    /**
     * In case the EmployeeBankDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeBankDetailsUpdateInput, EmployeeBankDetailsUncheckedUpdateInput>
  }

  /**
   * EmployeeBankDetails delete
   */
  export type EmployeeBankDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
    /**
     * Filter which EmployeeBankDetails to delete.
     */
    where: EmployeeBankDetailsWhereUniqueInput
  }

  /**
   * EmployeeBankDetails deleteMany
   */
  export type EmployeeBankDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBankDetails to delete
     */
    where?: EmployeeBankDetailsWhereInput
    /**
     * Limit how many EmployeeBankDetails to delete.
     */
    limit?: number
  }

  /**
   * EmployeeBankDetails without action
   */
  export type EmployeeBankDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBankDetails
     */
    select?: EmployeeBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeBankDetails
     */
    omit?: EmployeeBankDetailsOmit<ExtArgs> | null
  }


  /**
   * Model SalaryInfo
   */

  export type AggregateSalaryInfo = {
    _count: SalaryInfoCountAggregateOutputType | null
    _avg: SalaryInfoAvgAggregateOutputType | null
    _sum: SalaryInfoSumAggregateOutputType | null
    _min: SalaryInfoMinAggregateOutputType | null
    _max: SalaryInfoMaxAggregateOutputType | null
  }

  export type SalaryInfoAvgAggregateOutputType = {
    id: number | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insuranceAmount: number | null
  }

  export type SalaryInfoSumAggregateOutputType = {
    id: number | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insuranceAmount: number | null
  }

  export type SalaryInfoMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insuranceAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryInfoMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insuranceAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryInfoCountAggregateOutputType = {
    id: number
    employeeId: number
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalaryInfoAvgAggregateInputType = {
    id?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insuranceAmount?: true
  }

  export type SalaryInfoSumAggregateInputType = {
    id?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insuranceAmount?: true
  }

  export type SalaryInfoMinAggregateInputType = {
    id?: true
    employeeId?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insuranceAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryInfoMaxAggregateInputType = {
    id?: true
    employeeId?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insuranceAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryInfoCountAggregateInputType = {
    id?: true
    employeeId?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insuranceAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalaryInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryInfo to aggregate.
     */
    where?: SalaryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryInfos to fetch.
     */
    orderBy?: SalaryInfoOrderByWithRelationInput | SalaryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryInfos
    **/
    _count?: true | SalaryInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryInfoMaxAggregateInputType
  }

  export type GetSalaryInfoAggregateType<T extends SalaryInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryInfo[P]>
      : GetScalarType<T[P], AggregateSalaryInfo[P]>
  }




  export type SalaryInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryInfoWhereInput
    orderBy?: SalaryInfoOrderByWithAggregationInput | SalaryInfoOrderByWithAggregationInput[]
    by: SalaryInfoScalarFieldEnum[] | SalaryInfoScalarFieldEnum
    having?: SalaryInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryInfoCountAggregateInputType | true
    _avg?: SalaryInfoAvgAggregateInputType
    _sum?: SalaryInfoSumAggregateInputType
    _min?: SalaryInfoMinAggregateInputType
    _max?: SalaryInfoMaxAggregateInputType
  }

  export type SalaryInfoGroupByOutputType = {
    id: number
    employeeId: string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt: Date
    updatedAt: Date
    _count: SalaryInfoCountAggregateOutputType | null
    _avg: SalaryInfoAvgAggregateOutputType | null
    _sum: SalaryInfoSumAggregateOutputType | null
    _min: SalaryInfoMinAggregateOutputType | null
    _max: SalaryInfoMaxAggregateOutputType | null
  }

  type GetSalaryInfoGroupByPayload<T extends SalaryInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryInfoGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryInfoGroupByOutputType[P]>
        }
      >
    >


  export type SalaryInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    basicSalary?: boolean
    houseRend?: boolean
    mobile?: boolean
    medial?: boolean
    taDa?: boolean
    insuranceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryInfo"]>



  export type SalaryInfoSelectScalar = {
    id?: boolean
    employeeId?: boolean
    basicSalary?: boolean
    houseRend?: boolean
    mobile?: boolean
    medial?: boolean
    taDa?: boolean
    insuranceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalaryInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "basicSalary" | "houseRend" | "mobile" | "medial" | "taDa" | "insuranceAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["salaryInfo"]>
  export type SalaryInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalaryInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryInfo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      basicSalary: number
      houseRend: number
      mobile: number
      medial: number
      taDa: number
      insuranceAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salaryInfo"]>
    composites: {}
  }

  type SalaryInfoGetPayload<S extends boolean | null | undefined | SalaryInfoDefaultArgs> = $Result.GetResult<Prisma.$SalaryInfoPayload, S>

  type SalaryInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryInfoCountAggregateInputType | true
    }

  export interface SalaryInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryInfo'], meta: { name: 'SalaryInfo' } }
    /**
     * Find zero or one SalaryInfo that matches the filter.
     * @param {SalaryInfoFindUniqueArgs} args - Arguments to find a SalaryInfo
     * @example
     * // Get one SalaryInfo
     * const salaryInfo = await prisma.salaryInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryInfoFindUniqueArgs>(args: SelectSubset<T, SalaryInfoFindUniqueArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryInfoFindUniqueOrThrowArgs} args - Arguments to find a SalaryInfo
     * @example
     * // Get one SalaryInfo
     * const salaryInfo = await prisma.salaryInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryInfoFindFirstArgs} args - Arguments to find a SalaryInfo
     * @example
     * // Get one SalaryInfo
     * const salaryInfo = await prisma.salaryInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryInfoFindFirstArgs>(args?: SelectSubset<T, SalaryInfoFindFirstArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryInfoFindFirstOrThrowArgs} args - Arguments to find a SalaryInfo
     * @example
     * // Get one SalaryInfo
     * const salaryInfo = await prisma.salaryInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryInfos
     * const salaryInfos = await prisma.salaryInfo.findMany()
     * 
     * // Get first 10 SalaryInfos
     * const salaryInfos = await prisma.salaryInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryInfoWithIdOnly = await prisma.salaryInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryInfoFindManyArgs>(args?: SelectSubset<T, SalaryInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryInfo.
     * @param {SalaryInfoCreateArgs} args - Arguments to create a SalaryInfo.
     * @example
     * // Create one SalaryInfo
     * const SalaryInfo = await prisma.salaryInfo.create({
     *   data: {
     *     // ... data to create a SalaryInfo
     *   }
     * })
     * 
     */
    create<T extends SalaryInfoCreateArgs>(args: SelectSubset<T, SalaryInfoCreateArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryInfos.
     * @param {SalaryInfoCreateManyArgs} args - Arguments to create many SalaryInfos.
     * @example
     * // Create many SalaryInfos
     * const salaryInfo = await prisma.salaryInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryInfoCreateManyArgs>(args?: SelectSubset<T, SalaryInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SalaryInfo.
     * @param {SalaryInfoDeleteArgs} args - Arguments to delete one SalaryInfo.
     * @example
     * // Delete one SalaryInfo
     * const SalaryInfo = await prisma.salaryInfo.delete({
     *   where: {
     *     // ... filter to delete one SalaryInfo
     *   }
     * })
     * 
     */
    delete<T extends SalaryInfoDeleteArgs>(args: SelectSubset<T, SalaryInfoDeleteArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryInfo.
     * @param {SalaryInfoUpdateArgs} args - Arguments to update one SalaryInfo.
     * @example
     * // Update one SalaryInfo
     * const salaryInfo = await prisma.salaryInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryInfoUpdateArgs>(args: SelectSubset<T, SalaryInfoUpdateArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryInfos.
     * @param {SalaryInfoDeleteManyArgs} args - Arguments to filter SalaryInfos to delete.
     * @example
     * // Delete a few SalaryInfos
     * const { count } = await prisma.salaryInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryInfoDeleteManyArgs>(args?: SelectSubset<T, SalaryInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryInfos
     * const salaryInfo = await prisma.salaryInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryInfoUpdateManyArgs>(args: SelectSubset<T, SalaryInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryInfo.
     * @param {SalaryInfoUpsertArgs} args - Arguments to update or create a SalaryInfo.
     * @example
     * // Update or create a SalaryInfo
     * const salaryInfo = await prisma.salaryInfo.upsert({
     *   create: {
     *     // ... data to create a SalaryInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryInfo we want to update
     *   }
     * })
     */
    upsert<T extends SalaryInfoUpsertArgs>(args: SelectSubset<T, SalaryInfoUpsertArgs<ExtArgs>>): Prisma__SalaryInfoClient<$Result.GetResult<Prisma.$SalaryInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryInfoCountArgs} args - Arguments to filter SalaryInfos to count.
     * @example
     * // Count the number of SalaryInfos
     * const count = await prisma.salaryInfo.count({
     *   where: {
     *     // ... the filter for the SalaryInfos we want to count
     *   }
     * })
    **/
    count<T extends SalaryInfoCountArgs>(
      args?: Subset<T, SalaryInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryInfoAggregateArgs>(args: Subset<T, SalaryInfoAggregateArgs>): Prisma.PrismaPromise<GetSalaryInfoAggregateType<T>>

    /**
     * Group by SalaryInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryInfoGroupByArgs['orderBy'] }
        : { orderBy?: SalaryInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryInfo model
   */
  readonly fields: SalaryInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryInfo model
   */
  interface SalaryInfoFieldRefs {
    readonly id: FieldRef<"SalaryInfo", 'Int'>
    readonly employeeId: FieldRef<"SalaryInfo", 'String'>
    readonly basicSalary: FieldRef<"SalaryInfo", 'Float'>
    readonly houseRend: FieldRef<"SalaryInfo", 'Float'>
    readonly mobile: FieldRef<"SalaryInfo", 'Float'>
    readonly medial: FieldRef<"SalaryInfo", 'Float'>
    readonly taDa: FieldRef<"SalaryInfo", 'Float'>
    readonly insuranceAmount: FieldRef<"SalaryInfo", 'Float'>
    readonly createdAt: FieldRef<"SalaryInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryInfo findUnique
   */
  export type SalaryInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * Filter, which SalaryInfo to fetch.
     */
    where: SalaryInfoWhereUniqueInput
  }

  /**
   * SalaryInfo findUniqueOrThrow
   */
  export type SalaryInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * Filter, which SalaryInfo to fetch.
     */
    where: SalaryInfoWhereUniqueInput
  }

  /**
   * SalaryInfo findFirst
   */
  export type SalaryInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * Filter, which SalaryInfo to fetch.
     */
    where?: SalaryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryInfos to fetch.
     */
    orderBy?: SalaryInfoOrderByWithRelationInput | SalaryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryInfos.
     */
    cursor?: SalaryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryInfos.
     */
    distinct?: SalaryInfoScalarFieldEnum | SalaryInfoScalarFieldEnum[]
  }

  /**
   * SalaryInfo findFirstOrThrow
   */
  export type SalaryInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * Filter, which SalaryInfo to fetch.
     */
    where?: SalaryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryInfos to fetch.
     */
    orderBy?: SalaryInfoOrderByWithRelationInput | SalaryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryInfos.
     */
    cursor?: SalaryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryInfos.
     */
    distinct?: SalaryInfoScalarFieldEnum | SalaryInfoScalarFieldEnum[]
  }

  /**
   * SalaryInfo findMany
   */
  export type SalaryInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * Filter, which SalaryInfos to fetch.
     */
    where?: SalaryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryInfos to fetch.
     */
    orderBy?: SalaryInfoOrderByWithRelationInput | SalaryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryInfos.
     */
    cursor?: SalaryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryInfos.
     */
    skip?: number
    distinct?: SalaryInfoScalarFieldEnum | SalaryInfoScalarFieldEnum[]
  }

  /**
   * SalaryInfo create
   */
  export type SalaryInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryInfo.
     */
    data: XOR<SalaryInfoCreateInput, SalaryInfoUncheckedCreateInput>
  }

  /**
   * SalaryInfo createMany
   */
  export type SalaryInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryInfos.
     */
    data: SalaryInfoCreateManyInput | SalaryInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryInfo update
   */
  export type SalaryInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryInfo.
     */
    data: XOR<SalaryInfoUpdateInput, SalaryInfoUncheckedUpdateInput>
    /**
     * Choose, which SalaryInfo to update.
     */
    where: SalaryInfoWhereUniqueInput
  }

  /**
   * SalaryInfo updateMany
   */
  export type SalaryInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryInfos.
     */
    data: XOR<SalaryInfoUpdateManyMutationInput, SalaryInfoUncheckedUpdateManyInput>
    /**
     * Filter which SalaryInfos to update
     */
    where?: SalaryInfoWhereInput
    /**
     * Limit how many SalaryInfos to update.
     */
    limit?: number
  }

  /**
   * SalaryInfo upsert
   */
  export type SalaryInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryInfo to update in case it exists.
     */
    where: SalaryInfoWhereUniqueInput
    /**
     * In case the SalaryInfo found by the `where` argument doesn't exist, create a new SalaryInfo with this data.
     */
    create: XOR<SalaryInfoCreateInput, SalaryInfoUncheckedCreateInput>
    /**
     * In case the SalaryInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryInfoUpdateInput, SalaryInfoUncheckedUpdateInput>
  }

  /**
   * SalaryInfo delete
   */
  export type SalaryInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
    /**
     * Filter which SalaryInfo to delete.
     */
    where: SalaryInfoWhereUniqueInput
  }

  /**
   * SalaryInfo deleteMany
   */
  export type SalaryInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryInfos to delete
     */
    where?: SalaryInfoWhereInput
    /**
     * Limit how many SalaryInfos to delete.
     */
    limit?: number
  }

  /**
   * SalaryInfo without action
   */
  export type SalaryInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryInfo
     */
    select?: SalaryInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryInfo
     */
    omit?: SalaryInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInfoInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    id: number | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insentive: number | null
    eidBonus: number | null
    boishakhi: number | null
    others: number | null
    fp: number | null
    insurance: number | null
  }

  export type PayrollSumAggregateOutputType = {
    id: number | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insentive: number | null
    eidBonus: number | null
    boishakhi: number | null
    others: number | null
    fp: number | null
    insurance: number | null
  }

  export type PayrollMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    payDate: Date | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insentive: number | null
    eidBonus: number | null
    boishakhi: number | null
    others: number | null
    fp: number | null
    insurance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    payDate: Date | null
    basicSalary: number | null
    houseRend: number | null
    mobile: number | null
    medial: number | null
    taDa: number | null
    insentive: number | null
    eidBonus: number | null
    boishakhi: number | null
    others: number | null
    fp: number | null
    insurance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    employeeId: number
    payDate: number
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    id?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insentive?: true
    eidBonus?: true
    boishakhi?: true
    others?: true
    fp?: true
    insurance?: true
  }

  export type PayrollSumAggregateInputType = {
    id?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insentive?: true
    eidBonus?: true
    boishakhi?: true
    others?: true
    fp?: true
    insurance?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    employeeId?: true
    payDate?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insentive?: true
    eidBonus?: true
    boishakhi?: true
    others?: true
    fp?: true
    insurance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    employeeId?: true
    payDate?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insentive?: true
    eidBonus?: true
    boishakhi?: true
    others?: true
    fp?: true
    insurance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    employeeId?: true
    payDate?: true
    basicSalary?: true
    houseRend?: true
    mobile?: true
    medial?: true
    taDa?: true
    insentive?: true
    eidBonus?: true
    boishakhi?: true
    others?: true
    fp?: true
    insurance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: number
    employeeId: string
    payDate: Date
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt: Date
    updatedAt: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    payDate?: boolean
    basicSalary?: boolean
    houseRend?: boolean
    mobile?: boolean
    medial?: boolean
    taDa?: boolean
    insentive?: boolean
    eidBonus?: boolean
    boishakhi?: boolean
    others?: boolean
    fp?: boolean
    insurance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>



  export type PayrollSelectScalar = {
    id?: boolean
    employeeId?: boolean
    payDate?: boolean
    basicSalary?: boolean
    houseRend?: boolean
    mobile?: boolean
    medial?: boolean
    taDa?: boolean
    insentive?: boolean
    eidBonus?: boolean
    boishakhi?: boolean
    others?: boolean
    fp?: boolean
    insurance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "payDate" | "basicSalary" | "houseRend" | "mobile" | "medial" | "taDa" | "insentive" | "eidBonus" | "boishakhi" | "others" | "fp" | "insurance" | "createdAt" | "updatedAt", ExtArgs["result"]["payroll"]>
  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      payDate: Date
      basicSalary: number
      houseRend: number
      mobile: number
      medial: number
      taDa: number
      insentive: number
      eidBonus: number
      boishakhi: number
      others: number
      fp: number
      insurance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'Int'>
    readonly employeeId: FieldRef<"Payroll", 'String'>
    readonly payDate: FieldRef<"Payroll", 'DateTime'>
    readonly basicSalary: FieldRef<"Payroll", 'Float'>
    readonly houseRend: FieldRef<"Payroll", 'Float'>
    readonly mobile: FieldRef<"Payroll", 'Float'>
    readonly medial: FieldRef<"Payroll", 'Float'>
    readonly taDa: FieldRef<"Payroll", 'Float'>
    readonly insentive: FieldRef<"Payroll", 'Float'>
    readonly eidBonus: FieldRef<"Payroll", 'Float'>
    readonly boishakhi: FieldRef<"Payroll", 'Float'>
    readonly others: FieldRef<"Payroll", 'Float'>
    readonly fp: FieldRef<"Payroll", 'Float'>
    readonly insurance: FieldRef<"Payroll", 'Float'>
    readonly createdAt: FieldRef<"Payroll", 'DateTime'>
    readonly updatedAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to delete.
     */
    limit?: number
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    name: 'name',
    email: 'email',
    password: 'password',
    photo: 'photo',
    roles: 'roles',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeProfileScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    fatherName: 'fatherName',
    motherName: 'motherName',
    officeContactNo: 'officeContactNo',
    currentAddress: 'currentAddress',
    permanentAddress: 'permanentAddress',
    nid: 'nid',
    dob: 'dob',
    contactNo: 'contactNo',
    emergencyContactNo: 'emergencyContactNo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeProfileScalarFieldEnum = (typeof EmployeeProfileScalarFieldEnum)[keyof typeof EmployeeProfileScalarFieldEnum]


  export const JobPostScalarFieldEnum: {
    id: 'id',
    depoId: 'depoId',
    postName: 'postName',
    qualification: 'qualification',
    responsibility: 'responsibility',
    isDelete: 'isDelete',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobPostScalarFieldEnum = (typeof JobPostScalarFieldEnum)[keyof typeof JobPostScalarFieldEnum]


  export const ChemistScalarFieldEnum: {
    id: 'id',
    chemistId: 'chemistId',
    depoId: 'depoId',
    pharmacyName: 'pharmacyName',
    contactPerson: 'contactPerson',
    contactNo: 'contactNo',
    address: 'address',
    photo: 'photo',
    discountRate: 'discountRate',
    openingDueAmount: 'openingDueAmount',
    openingDate: 'openingDate',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChemistScalarFieldEnum = (typeof ChemistScalarFieldEnum)[keyof typeof ChemistScalarFieldEnum]


  export const DepoScalarFieldEnum: {
    id: 'id',
    depoName: 'depoName',
    location: 'location',
    scopeId: 'scopeId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepoScalarFieldEnum = (typeof DepoScalarFieldEnum)[keyof typeof DepoScalarFieldEnum]


  export const PartyScalarFieldEnum: {
    id: 'id',
    partyName: 'partyName',
    contactNo: 'contactNo',
    address: 'address',
    partytype: 'partytype',
    openingAmount: 'openingAmount',
    openingDate: 'openingDate',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartyScalarFieldEnum = (typeof PartyScalarFieldEnum)[keyof typeof PartyScalarFieldEnum]


  export const StakeholderScalarFieldEnum: {
    id: 'id',
    scopeId: 'scopeId',
    stakeId: 'stakeId',
    name: 'name',
    designationId: 'designationId',
    degreeId: 'degreeId',
    category: 'category',
    officeAddress: 'officeAddress',
    contactNo: 'contactNo',
    honorary: 'honorary',
    paymentDate: 'paymentDate',
    rxCommitment: 'rxCommitment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StakeholderScalarFieldEnum = (typeof StakeholderScalarFieldEnum)[keyof typeof StakeholderScalarFieldEnum]


  export const StakeholderDeisgnationScalarFieldEnum: {
    id: 'id',
    designation: 'designation',
    description: 'description',
    isDelete: 'isDelete',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StakeholderDeisgnationScalarFieldEnum = (typeof StakeholderDeisgnationScalarFieldEnum)[keyof typeof StakeholderDeisgnationScalarFieldEnum]


  export const StakeholderDegreeScalarFieldEnum: {
    id: 'id',
    degreeName: 'degreeName',
    description: 'description',
    isDelete: 'isDelete',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StakeholderDegreeScalarFieldEnum = (typeof StakeholderDegreeScalarFieldEnum)[keyof typeof StakeholderDegreeScalarFieldEnum]


  export const StakeholderChemberScalarFieldEnum: {
    id: 'id',
    stakeId: 'stakeId',
    address: 'address',
    chemberDay: 'chemberDay',
    chemberTime: 'chemberTime',
    chemberName: 'chemberName',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StakeholderChemberScalarFieldEnum = (typeof StakeholderChemberScalarFieldEnum)[keyof typeof StakeholderChemberScalarFieldEnum]


  export const StakeholderOcationScalarFieldEnum: {
    id: 'id',
    stakeId: 'stakeId',
    ocationName: 'ocationName',
    relation: 'relation',
    personName: 'personName',
    dob: 'dob',
    otherInfo: 'otherInfo'
  };

  export type StakeholderOcationScalarFieldEnum = (typeof StakeholderOcationScalarFieldEnum)[keyof typeof StakeholderOcationScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactNo: 'contactNo',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const ScopeScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScopeScalarFieldEnum = (typeof ScopeScalarFieldEnum)[keyof typeof ScopeScalarFieldEnum]


  export const MpoTargetScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    month: 'month',
    tergatAmount: 'tergatAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MpoTargetScalarFieldEnum = (typeof MpoTargetScalarFieldEnum)[keyof typeof MpoTargetScalarFieldEnum]


  export const ProductWiseTargetScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    targetStart: 'targetStart',
    targetEnd: 'targetEnd',
    targetType: 'targetType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductWiseTargetScalarFieldEnum = (typeof ProductWiseTargetScalarFieldEnum)[keyof typeof ProductWiseTargetScalarFieldEnum]


  export const TargetProductBatchScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    productTargetId: 'productTargetId',
    numberOfProduct: 'numberOfProduct',
    insentiveAmount: 'insentiveAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TargetProductBatchScalarFieldEnum = (typeof TargetProductBatchScalarFieldEnum)[keyof typeof TargetProductBatchScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    categoryName: 'categoryName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubCategoryScalarFieldEnum: {
    id: 'id',
    subCategoryName: 'subCategoryName',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubCategoryScalarFieldEnum = (typeof SubCategoryScalarFieldEnum)[keyof typeof SubCategoryScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const AccountHeadScalarFieldEnum: {
    id: 'id',
    headName: 'headName',
    headCode: 'headCode',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type AccountHeadScalarFieldEnum = (typeof AccountHeadScalarFieldEnum)[keyof typeof AccountHeadScalarFieldEnum]


  export const LedgerHeadScalarFieldEnum: {
    id: 'id',
    ledgerName: 'ledgerName',
    ledgerCode: 'ledgerCode',
    headCodeId: 'headCodeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LedgerHeadScalarFieldEnum = (typeof LedgerHeadScalarFieldEnum)[keyof typeof LedgerHeadScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    subCategoryId: 'subCategoryId',
    stakeholderId: 'stakeholderId',
    size: 'size',
    unitId: 'unitId',
    mrp: 'mrp',
    tp: 'tp',
    balance: 'balance',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    date: 'date',
    status: 'status',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    bankName: 'bankName',
    branceName: 'branceName',
    accountNumber: 'accountNumber',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const BankTransactionScalarFieldEnum: {
    id: 'id',
    date: 'date',
    bankAccountId: 'bankAccountId',
    debitAmount: 'debitAmount',
    creditAmount: 'creditAmount',
    journalId: 'journalId',
    isClosing: 'isClosing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankTransactionScalarFieldEnum = (typeof BankTransactionScalarFieldEnum)[keyof typeof BankTransactionScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    productId: 'productId',
    depoId: 'depoId',
    employeeId: 'employeeId',
    transactionId: 'transactionId',
    fixedJournalId: 'fixedJournalId',
    unitPrice: 'unitPrice',
    quantityAdd: 'quantityAdd',
    quantityLess: 'quantityLess',
    debitAmount: 'debitAmount',
    creditAmount: 'creditAmount',
    isClosing: 'isClosing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isFixted: 'isFixted'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const TransactionInfoScalarFieldEnum: {
    id: 'id',
    date: 'date',
    voucherNo: 'voucherNo',
    invoiceNo: 'invoiceNo',
    chemistId: 'chemistId',
    customerId: 'customerId',
    stakeholderId: 'stakeholderId',
    employeeId: 'employeeId',
    partyId: 'partyId',
    voucherType: 'voucherType',
    paymentType: 'paymentType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionInfoScalarFieldEnum = (typeof TransactionInfoScalarFieldEnum)[keyof typeof TransactionInfoScalarFieldEnum]


  export const JournalScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    ledgerHeadId: 'ledgerHeadId',
    date: 'date',
    depoId: 'depoId',
    creditAmount: 'creditAmount',
    debitAmount: 'debitAmount',
    narration: 'narration',
    isClosing: 'isClosing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]


  export const FixedJournalScalarFieldEnum: {
    id: 'id',
    date: 'date',
    voucherNo: 'voucherNo',
    chemistId: 'chemistId',
    ledgerHeadId: 'ledgerHeadId',
    depoId: 'depoId',
    creditAmount: 'creditAmount',
    debitAmount: 'debitAmount',
    narration: 'narration',
    isClosing: 'isClosing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FixedJournalScalarFieldEnum = (typeof FixedJournalScalarFieldEnum)[keyof typeof FixedJournalScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    chemistId: 'chemistId',
    orderNo: 'orderNo',
    date: 'date',
    discount: 'discount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quintity: 'quintity',
    tpRate: 'tpRate',
    amount: 'amount'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderStatusScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    status: 'status',
    comments: 'comments',
    dateTime: 'dateTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderStatusScalarFieldEnum = (typeof OrderStatusScalarFieldEnum)[keyof typeof OrderStatusScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    time: 'time',
    status: 'status',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const OvertimeScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    overtimeDate: 'overtimeDate',
    overtimeHours: 'overtimeHours',
    others: 'others',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OvertimeScalarFieldEnum = (typeof OvertimeScalarFieldEnum)[keyof typeof OvertimeScalarFieldEnum]


  export const LeaveTypeScalarFieldEnum: {
    id: 'id',
    leaveName: 'leaveName'
  };

  export type LeaveTypeScalarFieldEnum = (typeof LeaveTypeScalarFieldEnum)[keyof typeof LeaveTypeScalarFieldEnum]


  export const LevesScalarFieldEnum: {
    id: 'id',
    leaveTypeId: 'leaveTypeId',
    employeeId: 'employeeId',
    startDate: 'startDate',
    endDate: 'endDate',
    leaveReason: 'leaveReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevesScalarFieldEnum = (typeof LevesScalarFieldEnum)[keyof typeof LevesScalarFieldEnum]


  export const EmployeeBankDetailsScalarFieldEnum: {
    id: 'id',
    bankName: 'bankName',
    bankAccountNumber: 'bankAccountNumber',
    branchName: 'branchName',
    ifsscode: 'ifsscode'
  };

  export type EmployeeBankDetailsScalarFieldEnum = (typeof EmployeeBankDetailsScalarFieldEnum)[keyof typeof EmployeeBankDetailsScalarFieldEnum]


  export const SalaryInfoScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    basicSalary: 'basicSalary',
    houseRend: 'houseRend',
    mobile: 'mobile',
    medial: 'medial',
    taDa: 'taDa',
    insuranceAmount: 'insuranceAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalaryInfoScalarFieldEnum = (typeof SalaryInfoScalarFieldEnum)[keyof typeof SalaryInfoScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    payDate: 'payDate',
    basicSalary: 'basicSalary',
    houseRend: 'houseRend',
    mobile: 'mobile',
    medial: 'medial',
    taDa: 'taDa',
    insentive: 'insentive',
    eidBonus: 'eidBonus',
    boishakhi: 'boishakhi',
    others: 'others',
    fp: 'fp',
    insurance: 'insurance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    name: 'name',
    email: 'email',
    password: 'password',
    photo: 'photo'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const EmployeeProfileOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    fatherName: 'fatherName',
    motherName: 'motherName',
    officeContactNo: 'officeContactNo',
    currentAddress: 'currentAddress',
    permanentAddress: 'permanentAddress',
    nid: 'nid',
    contactNo: 'contactNo',
    emergencyContactNo: 'emergencyContactNo'
  };

  export type EmployeeProfileOrderByRelevanceFieldEnum = (typeof EmployeeProfileOrderByRelevanceFieldEnum)[keyof typeof EmployeeProfileOrderByRelevanceFieldEnum]


  export const JobPostOrderByRelevanceFieldEnum: {
    postName: 'postName',
    qualification: 'qualification',
    responsibility: 'responsibility'
  };

  export type JobPostOrderByRelevanceFieldEnum = (typeof JobPostOrderByRelevanceFieldEnum)[keyof typeof JobPostOrderByRelevanceFieldEnum]


  export const ChemistOrderByRelevanceFieldEnum: {
    chemistId: 'chemistId',
    pharmacyName: 'pharmacyName',
    contactPerson: 'contactPerson',
    contactNo: 'contactNo',
    address: 'address',
    photo: 'photo'
  };

  export type ChemistOrderByRelevanceFieldEnum = (typeof ChemistOrderByRelevanceFieldEnum)[keyof typeof ChemistOrderByRelevanceFieldEnum]


  export const DepoOrderByRelevanceFieldEnum: {
    depoName: 'depoName',
    location: 'location'
  };

  export type DepoOrderByRelevanceFieldEnum = (typeof DepoOrderByRelevanceFieldEnum)[keyof typeof DepoOrderByRelevanceFieldEnum]


  export const PartyOrderByRelevanceFieldEnum: {
    partyName: 'partyName',
    contactNo: 'contactNo',
    address: 'address'
  };

  export type PartyOrderByRelevanceFieldEnum = (typeof PartyOrderByRelevanceFieldEnum)[keyof typeof PartyOrderByRelevanceFieldEnum]


  export const StakeholderOrderByRelevanceFieldEnum: {
    stakeId: 'stakeId',
    name: 'name',
    category: 'category',
    officeAddress: 'officeAddress',
    contactNo: 'contactNo'
  };

  export type StakeholderOrderByRelevanceFieldEnum = (typeof StakeholderOrderByRelevanceFieldEnum)[keyof typeof StakeholderOrderByRelevanceFieldEnum]


  export const StakeholderDeisgnationOrderByRelevanceFieldEnum: {
    designation: 'designation',
    description: 'description'
  };

  export type StakeholderDeisgnationOrderByRelevanceFieldEnum = (typeof StakeholderDeisgnationOrderByRelevanceFieldEnum)[keyof typeof StakeholderDeisgnationOrderByRelevanceFieldEnum]


  export const StakeholderDegreeOrderByRelevanceFieldEnum: {
    degreeName: 'degreeName',
    description: 'description'
  };

  export type StakeholderDegreeOrderByRelevanceFieldEnum = (typeof StakeholderDegreeOrderByRelevanceFieldEnum)[keyof typeof StakeholderDegreeOrderByRelevanceFieldEnum]


  export const stakeholderChemberOrderByRelevanceFieldEnum: {
    stakeId: 'stakeId',
    address: 'address',
    chemberDay: 'chemberDay',
    chemberTime: 'chemberTime',
    chemberName: 'chemberName',
    location: 'location'
  };

  export type stakeholderChemberOrderByRelevanceFieldEnum = (typeof stakeholderChemberOrderByRelevanceFieldEnum)[keyof typeof stakeholderChemberOrderByRelevanceFieldEnum]


  export const StakeholderOcationOrderByRelevanceFieldEnum: {
    stakeId: 'stakeId',
    ocationName: 'ocationName',
    relation: 'relation',
    personName: 'personName',
    otherInfo: 'otherInfo'
  };

  export type StakeholderOcationOrderByRelevanceFieldEnum = (typeof StakeholderOcationOrderByRelevanceFieldEnum)[keyof typeof StakeholderOcationOrderByRelevanceFieldEnum]


  export const CustomersOrderByRelevanceFieldEnum: {
    name: 'name',
    contactNo: 'contactNo',
    address: 'address'
  };

  export type CustomersOrderByRelevanceFieldEnum = (typeof CustomersOrderByRelevanceFieldEnum)[keyof typeof CustomersOrderByRelevanceFieldEnum]


  export const ScopeOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId'
  };

  export type ScopeOrderByRelevanceFieldEnum = (typeof ScopeOrderByRelevanceFieldEnum)[keyof typeof ScopeOrderByRelevanceFieldEnum]


  export const MpoTargetOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    month: 'month'
  };

  export type MpoTargetOrderByRelevanceFieldEnum = (typeof MpoTargetOrderByRelevanceFieldEnum)[keyof typeof MpoTargetOrderByRelevanceFieldEnum]


  export const ProductWiseTargetOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId'
  };

  export type ProductWiseTargetOrderByRelevanceFieldEnum = (typeof ProductWiseTargetOrderByRelevanceFieldEnum)[keyof typeof ProductWiseTargetOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    categoryName: 'categoryName'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const SubCategoryOrderByRelevanceFieldEnum: {
    subCategoryName: 'subCategoryName'
  };

  export type SubCategoryOrderByRelevanceFieldEnum = (typeof SubCategoryOrderByRelevanceFieldEnum)[keyof typeof SubCategoryOrderByRelevanceFieldEnum]


  export const UnitOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type UnitOrderByRelevanceFieldEnum = (typeof UnitOrderByRelevanceFieldEnum)[keyof typeof UnitOrderByRelevanceFieldEnum]


  export const AccountHeadOrderByRelevanceFieldEnum: {
    headName: 'headName',
    headCode: 'headCode'
  };

  export type AccountHeadOrderByRelevanceFieldEnum = (typeof AccountHeadOrderByRelevanceFieldEnum)[keyof typeof AccountHeadOrderByRelevanceFieldEnum]


  export const LedgerHeadOrderByRelevanceFieldEnum: {
    ledgerName: 'ledgerName',
    ledgerCode: 'ledgerCode'
  };

  export type LedgerHeadOrderByRelevanceFieldEnum = (typeof LedgerHeadOrderByRelevanceFieldEnum)[keyof typeof LedgerHeadOrderByRelevanceFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    size: 'size'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const BankAccountOrderByRelevanceFieldEnum: {
    bankName: 'bankName',
    branceName: 'branceName',
    accountNumber: 'accountNumber'
  };

  export type BankAccountOrderByRelevanceFieldEnum = (typeof BankAccountOrderByRelevanceFieldEnum)[keyof typeof BankAccountOrderByRelevanceFieldEnum]


  export const InventoryOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId'
  };

  export type InventoryOrderByRelevanceFieldEnum = (typeof InventoryOrderByRelevanceFieldEnum)[keyof typeof InventoryOrderByRelevanceFieldEnum]


  export const TransactionInfoOrderByRelevanceFieldEnum: {
    voucherNo: 'voucherNo',
    invoiceNo: 'invoiceNo',
    chemistId: 'chemistId',
    stakeholderId: 'stakeholderId',
    employeeId: 'employeeId'
  };

  export type TransactionInfoOrderByRelevanceFieldEnum = (typeof TransactionInfoOrderByRelevanceFieldEnum)[keyof typeof TransactionInfoOrderByRelevanceFieldEnum]


  export const JournalOrderByRelevanceFieldEnum: {
    narration: 'narration'
  };

  export type JournalOrderByRelevanceFieldEnum = (typeof JournalOrderByRelevanceFieldEnum)[keyof typeof JournalOrderByRelevanceFieldEnum]


  export const FixedJournalOrderByRelevanceFieldEnum: {
    voucherNo: 'voucherNo',
    chemistId: 'chemistId',
    narration: 'narration'
  };

  export type FixedJournalOrderByRelevanceFieldEnum = (typeof FixedJournalOrderByRelevanceFieldEnum)[keyof typeof FixedJournalOrderByRelevanceFieldEnum]


  export const OrderOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    chemistId: 'chemistId',
    orderNo: 'orderNo'
  };

  export type OrderOrderByRelevanceFieldEnum = (typeof OrderOrderByRelevanceFieldEnum)[keyof typeof OrderOrderByRelevanceFieldEnum]


  export const OrderStatusOrderByRelevanceFieldEnum: {
    orderNo: 'orderNo',
    comments: 'comments'
  };

  export type OrderStatusOrderByRelevanceFieldEnum = (typeof OrderStatusOrderByRelevanceFieldEnum)[keyof typeof OrderStatusOrderByRelevanceFieldEnum]


  export const AttendanceOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    time: 'time',
    status: 'status',
    comments: 'comments'
  };

  export type AttendanceOrderByRelevanceFieldEnum = (typeof AttendanceOrderByRelevanceFieldEnum)[keyof typeof AttendanceOrderByRelevanceFieldEnum]


  export const OvertimeOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    overtimeHours: 'overtimeHours',
    others: 'others'
  };

  export type OvertimeOrderByRelevanceFieldEnum = (typeof OvertimeOrderByRelevanceFieldEnum)[keyof typeof OvertimeOrderByRelevanceFieldEnum]


  export const LeaveTypeOrderByRelevanceFieldEnum: {
    leaveName: 'leaveName'
  };

  export type LeaveTypeOrderByRelevanceFieldEnum = (typeof LeaveTypeOrderByRelevanceFieldEnum)[keyof typeof LeaveTypeOrderByRelevanceFieldEnum]


  export const LevesOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    leaveReason: 'leaveReason'
  };

  export type LevesOrderByRelevanceFieldEnum = (typeof LevesOrderByRelevanceFieldEnum)[keyof typeof LevesOrderByRelevanceFieldEnum]


  export const EmployeeBankDetailsOrderByRelevanceFieldEnum: {
    bankName: 'bankName',
    bankAccountNumber: 'bankAccountNumber',
    branchName: 'branchName',
    ifsscode: 'ifsscode'
  };

  export type EmployeeBankDetailsOrderByRelevanceFieldEnum = (typeof EmployeeBankDetailsOrderByRelevanceFieldEnum)[keyof typeof EmployeeBankDetailsOrderByRelevanceFieldEnum]


  export const SalaryInfoOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId'
  };

  export type SalaryInfoOrderByRelevanceFieldEnum = (typeof SalaryInfoOrderByRelevanceFieldEnum)[keyof typeof SalaryInfoOrderByRelevanceFieldEnum]


  export const PayrollOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId'
  };

  export type PayrollOrderByRelevanceFieldEnum = (typeof PayrollOrderByRelevanceFieldEnum)[keyof typeof PayrollOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'PartyType'
   */
  export type EnumPartyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartyType'>
    


  /**
   * Reference to a field of type 'TargetType'
   */
  export type EnumTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetType'>
    


  /**
   * Reference to a field of type 'VoucherType'
   */
  export type EnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'OrdStatus'
   */
  export type EnumOrdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrdStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    employeeId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    photo?: StringNullableFilter<"User"> | string | null
    roles?: JsonFilter<"User">
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    productWiseTarget?: XOR<ProductWiseTargetNullableScalarRelationFilter, ProductWiseTargetWhereInput> | null
    attendance?: AttendanceListRelationFilter
    employeeProfile?: XOR<EmployeeProfileNullableScalarRelationFilter, EmployeeProfileWhereInput> | null
    leves?: LevesListRelationFilter
    mpoTarget?: XOR<MpoTargetNullableScalarRelationFilter, MpoTargetWhereInput> | null
    order?: OrderListRelationFilter
    overtime?: OvertimeListRelationFilter
    payroll?: PayrollListRelationFilter
    salaryInfo?: SalaryInfoListRelationFilter
    scope?: XOR<ScopeNullableScalarRelationFilter, ScopeWhereInput> | null
    transactionInfo?: TransactionInfoListRelationFilter
    inventories?: InventoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    photo?: SortOrderInput | SortOrder
    roles?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productWiseTarget?: ProductWiseTargetOrderByWithRelationInput
    attendance?: AttendanceOrderByRelationAggregateInput
    employeeProfile?: EmployeeProfileOrderByWithRelationInput
    leves?: LevesOrderByRelationAggregateInput
    mpoTarget?: MpoTargetOrderByWithRelationInput
    order?: OrderOrderByRelationAggregateInput
    overtime?: OvertimeOrderByRelationAggregateInput
    payroll?: PayrollOrderByRelationAggregateInput
    salaryInfo?: SalaryInfoOrderByRelationAggregateInput
    scope?: ScopeOrderByWithRelationInput
    transactionInfo?: TransactionInfoOrderByRelationAggregateInput
    inventories?: InventoryOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    photo?: StringNullableFilter<"User"> | string | null
    roles?: JsonFilter<"User">
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    productWiseTarget?: XOR<ProductWiseTargetNullableScalarRelationFilter, ProductWiseTargetWhereInput> | null
    attendance?: AttendanceListRelationFilter
    employeeProfile?: XOR<EmployeeProfileNullableScalarRelationFilter, EmployeeProfileWhereInput> | null
    leves?: LevesListRelationFilter
    mpoTarget?: XOR<MpoTargetNullableScalarRelationFilter, MpoTargetWhereInput> | null
    order?: OrderListRelationFilter
    overtime?: OvertimeListRelationFilter
    payroll?: PayrollListRelationFilter
    salaryInfo?: SalaryInfoListRelationFilter
    scope?: XOR<ScopeNullableScalarRelationFilter, ScopeWhereInput> | null
    transactionInfo?: TransactionInfoListRelationFilter
    inventories?: InventoryListRelationFilter
  }, "id" | "employeeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    photo?: SortOrderInput | SortOrder
    roles?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    employeeId?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    roles?: JsonWithAggregatesFilter<"User">
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EmployeeProfileWhereInput = {
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    id?: IntFilter<"EmployeeProfile"> | number
    employeeId?: StringFilter<"EmployeeProfile"> | string
    fatherName?: StringFilter<"EmployeeProfile"> | string
    motherName?: StringFilter<"EmployeeProfile"> | string
    officeContactNo?: StringNullableFilter<"EmployeeProfile"> | string | null
    currentAddress?: StringNullableFilter<"EmployeeProfile"> | string | null
    permanentAddress?: StringNullableFilter<"EmployeeProfile"> | string | null
    nid?: StringNullableFilter<"EmployeeProfile"> | string | null
    dob?: DateTimeFilter<"EmployeeProfile"> | Date | string
    contactNo?: StringFilter<"EmployeeProfile"> | string
    emergencyContactNo?: StringNullableFilter<"EmployeeProfile"> | string | null
    createdAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmployeeProfileOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    officeContactNo?: SortOrderInput | SortOrder
    currentAddress?: SortOrderInput | SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    nid?: SortOrderInput | SortOrder
    dob?: SortOrder
    contactNo?: SortOrder
    emergencyContactNo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: EmployeeProfileOrderByRelevanceInput
  }

  export type EmployeeProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId?: string
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    fatherName?: StringFilter<"EmployeeProfile"> | string
    motherName?: StringFilter<"EmployeeProfile"> | string
    officeContactNo?: StringNullableFilter<"EmployeeProfile"> | string | null
    currentAddress?: StringNullableFilter<"EmployeeProfile"> | string | null
    permanentAddress?: StringNullableFilter<"EmployeeProfile"> | string | null
    nid?: StringNullableFilter<"EmployeeProfile"> | string | null
    dob?: DateTimeFilter<"EmployeeProfile"> | Date | string
    contactNo?: StringFilter<"EmployeeProfile"> | string
    emergencyContactNo?: StringNullableFilter<"EmployeeProfile"> | string | null
    createdAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "employeeId">

  export type EmployeeProfileOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    officeContactNo?: SortOrderInput | SortOrder
    currentAddress?: SortOrderInput | SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    nid?: SortOrderInput | SortOrder
    dob?: SortOrder
    contactNo?: SortOrder
    emergencyContactNo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeProfileCountOrderByAggregateInput
    _avg?: EmployeeProfileAvgOrderByAggregateInput
    _max?: EmployeeProfileMaxOrderByAggregateInput
    _min?: EmployeeProfileMinOrderByAggregateInput
    _sum?: EmployeeProfileSumOrderByAggregateInput
  }

  export type EmployeeProfileScalarWhereWithAggregatesInput = {
    AND?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    OR?: EmployeeProfileScalarWhereWithAggregatesInput[]
    NOT?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeProfile"> | number
    employeeId?: StringWithAggregatesFilter<"EmployeeProfile"> | string
    fatherName?: StringWithAggregatesFilter<"EmployeeProfile"> | string
    motherName?: StringWithAggregatesFilter<"EmployeeProfile"> | string
    officeContactNo?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    currentAddress?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    permanentAddress?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    nid?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    dob?: DateTimeWithAggregatesFilter<"EmployeeProfile"> | Date | string
    contactNo?: StringWithAggregatesFilter<"EmployeeProfile"> | string
    emergencyContactNo?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeProfile"> | Date | string
  }

  export type JobPostWhereInput = {
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    id?: IntFilter<"JobPost"> | number
    depoId?: IntFilter<"JobPost"> | number
    postName?: StringFilter<"JobPost"> | string
    qualification?: StringFilter<"JobPost"> | string
    responsibility?: StringFilter<"JobPost"> | string
    isDelete?: BoolFilter<"JobPost"> | boolean
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeFilter<"JobPost"> | Date | string
    depo?: XOR<DepoScalarRelationFilter, DepoWhereInput>
    scope?: ScopeListRelationFilter
  }

  export type JobPostOrderByWithRelationInput = {
    id?: SortOrder
    depoId?: SortOrder
    postName?: SortOrder
    qualification?: SortOrder
    responsibility?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    depo?: DepoOrderByWithRelationInput
    scope?: ScopeOrderByRelationAggregateInput
    _relevance?: JobPostOrderByRelevanceInput
  }

  export type JobPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    postName?: string
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    depoId?: IntFilter<"JobPost"> | number
    qualification?: StringFilter<"JobPost"> | string
    responsibility?: StringFilter<"JobPost"> | string
    isDelete?: BoolFilter<"JobPost"> | boolean
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeFilter<"JobPost"> | Date | string
    depo?: XOR<DepoScalarRelationFilter, DepoWhereInput>
    scope?: ScopeListRelationFilter
  }, "id" | "postName">

  export type JobPostOrderByWithAggregationInput = {
    id?: SortOrder
    depoId?: SortOrder
    postName?: SortOrder
    qualification?: SortOrder
    responsibility?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobPostCountOrderByAggregateInput
    _avg?: JobPostAvgOrderByAggregateInput
    _max?: JobPostMaxOrderByAggregateInput
    _min?: JobPostMinOrderByAggregateInput
    _sum?: JobPostSumOrderByAggregateInput
  }

  export type JobPostScalarWhereWithAggregatesInput = {
    AND?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    OR?: JobPostScalarWhereWithAggregatesInput[]
    NOT?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobPost"> | number
    depoId?: IntWithAggregatesFilter<"JobPost"> | number
    postName?: StringWithAggregatesFilter<"JobPost"> | string
    qualification?: StringWithAggregatesFilter<"JobPost"> | string
    responsibility?: StringWithAggregatesFilter<"JobPost"> | string
    isDelete?: BoolWithAggregatesFilter<"JobPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobPost"> | Date | string
  }

  export type ChemistWhereInput = {
    AND?: ChemistWhereInput | ChemistWhereInput[]
    OR?: ChemistWhereInput[]
    NOT?: ChemistWhereInput | ChemistWhereInput[]
    id?: IntFilter<"Chemist"> | number
    chemistId?: StringFilter<"Chemist"> | string
    depoId?: IntFilter<"Chemist"> | number
    pharmacyName?: StringFilter<"Chemist"> | string
    contactPerson?: StringFilter<"Chemist"> | string
    contactNo?: StringFilter<"Chemist"> | string
    address?: StringFilter<"Chemist"> | string
    photo?: StringNullableFilter<"Chemist"> | string | null
    discountRate?: IntNullableFilter<"Chemist"> | number | null
    openingDueAmount?: FloatNullableFilter<"Chemist"> | number | null
    openingDate?: DateTimeFilter<"Chemist"> | Date | string
    isDeleted?: BoolFilter<"Chemist"> | boolean
    createdAt?: DateTimeFilter<"Chemist"> | Date | string
    updatedAt?: DateTimeFilter<"Chemist"> | Date | string
    depo?: XOR<DepoScalarRelationFilter, DepoWhereInput>
    scopes?: ScopeListRelationFilter
    FixedJournal?: FixedJournalListRelationFilter
    order?: OrderListRelationFilter
    transactionInfo?: TransactionInfoListRelationFilter
  }

  export type ChemistOrderByWithRelationInput = {
    id?: SortOrder
    chemistId?: SortOrder
    depoId?: SortOrder
    pharmacyName?: SortOrder
    contactPerson?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    photo?: SortOrderInput | SortOrder
    discountRate?: SortOrderInput | SortOrder
    openingDueAmount?: SortOrderInput | SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    depo?: DepoOrderByWithRelationInput
    scopes?: ScopeOrderByRelationAggregateInput
    FixedJournal?: FixedJournalOrderByRelationAggregateInput
    order?: OrderOrderByRelationAggregateInput
    transactionInfo?: TransactionInfoOrderByRelationAggregateInput
    _relevance?: ChemistOrderByRelevanceInput
  }

  export type ChemistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chemistId?: string
    AND?: ChemistWhereInput | ChemistWhereInput[]
    OR?: ChemistWhereInput[]
    NOT?: ChemistWhereInput | ChemistWhereInput[]
    depoId?: IntFilter<"Chemist"> | number
    pharmacyName?: StringFilter<"Chemist"> | string
    contactPerson?: StringFilter<"Chemist"> | string
    contactNo?: StringFilter<"Chemist"> | string
    address?: StringFilter<"Chemist"> | string
    photo?: StringNullableFilter<"Chemist"> | string | null
    discountRate?: IntNullableFilter<"Chemist"> | number | null
    openingDueAmount?: FloatNullableFilter<"Chemist"> | number | null
    openingDate?: DateTimeFilter<"Chemist"> | Date | string
    isDeleted?: BoolFilter<"Chemist"> | boolean
    createdAt?: DateTimeFilter<"Chemist"> | Date | string
    updatedAt?: DateTimeFilter<"Chemist"> | Date | string
    depo?: XOR<DepoScalarRelationFilter, DepoWhereInput>
    scopes?: ScopeListRelationFilter
    FixedJournal?: FixedJournalListRelationFilter
    order?: OrderListRelationFilter
    transactionInfo?: TransactionInfoListRelationFilter
  }, "id" | "chemistId">

  export type ChemistOrderByWithAggregationInput = {
    id?: SortOrder
    chemistId?: SortOrder
    depoId?: SortOrder
    pharmacyName?: SortOrder
    contactPerson?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    photo?: SortOrderInput | SortOrder
    discountRate?: SortOrderInput | SortOrder
    openingDueAmount?: SortOrderInput | SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChemistCountOrderByAggregateInput
    _avg?: ChemistAvgOrderByAggregateInput
    _max?: ChemistMaxOrderByAggregateInput
    _min?: ChemistMinOrderByAggregateInput
    _sum?: ChemistSumOrderByAggregateInput
  }

  export type ChemistScalarWhereWithAggregatesInput = {
    AND?: ChemistScalarWhereWithAggregatesInput | ChemistScalarWhereWithAggregatesInput[]
    OR?: ChemistScalarWhereWithAggregatesInput[]
    NOT?: ChemistScalarWhereWithAggregatesInput | ChemistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chemist"> | number
    chemistId?: StringWithAggregatesFilter<"Chemist"> | string
    depoId?: IntWithAggregatesFilter<"Chemist"> | number
    pharmacyName?: StringWithAggregatesFilter<"Chemist"> | string
    contactPerson?: StringWithAggregatesFilter<"Chemist"> | string
    contactNo?: StringWithAggregatesFilter<"Chemist"> | string
    address?: StringWithAggregatesFilter<"Chemist"> | string
    photo?: StringNullableWithAggregatesFilter<"Chemist"> | string | null
    discountRate?: IntNullableWithAggregatesFilter<"Chemist"> | number | null
    openingDueAmount?: FloatNullableWithAggregatesFilter<"Chemist"> | number | null
    openingDate?: DateTimeWithAggregatesFilter<"Chemist"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Chemist"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Chemist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chemist"> | Date | string
  }

  export type DepoWhereInput = {
    AND?: DepoWhereInput | DepoWhereInput[]
    OR?: DepoWhereInput[]
    NOT?: DepoWhereInput | DepoWhereInput[]
    id?: IntFilter<"Depo"> | number
    depoName?: StringFilter<"Depo"> | string
    location?: StringFilter<"Depo"> | string
    scopeId?: IntNullableFilter<"Depo"> | number | null
    status?: EnumStatusFilter<"Depo"> | $Enums.Status
    createdAt?: DateTimeFilter<"Depo"> | Date | string
    updatedAt?: DateTimeFilter<"Depo"> | Date | string
    chemist?: ChemistListRelationFilter
    FixedJournal?: FixedJournalListRelationFilter
    inventory?: InventoryListRelationFilter
    jobPost?: JobPostListRelationFilter
    journal?: JournalListRelationFilter
    scopes?: ScopeListRelationFilter
  }

  export type DepoOrderByWithRelationInput = {
    id?: SortOrder
    depoName?: SortOrder
    location?: SortOrder
    scopeId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chemist?: ChemistOrderByRelationAggregateInput
    FixedJournal?: FixedJournalOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    jobPost?: JobPostOrderByRelationAggregateInput
    journal?: JournalOrderByRelationAggregateInput
    scopes?: ScopeOrderByRelationAggregateInput
    _relevance?: DepoOrderByRelevanceInput
  }

  export type DepoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    depoName?: string
    AND?: DepoWhereInput | DepoWhereInput[]
    OR?: DepoWhereInput[]
    NOT?: DepoWhereInput | DepoWhereInput[]
    location?: StringFilter<"Depo"> | string
    scopeId?: IntNullableFilter<"Depo"> | number | null
    status?: EnumStatusFilter<"Depo"> | $Enums.Status
    createdAt?: DateTimeFilter<"Depo"> | Date | string
    updatedAt?: DateTimeFilter<"Depo"> | Date | string
    chemist?: ChemistListRelationFilter
    FixedJournal?: FixedJournalListRelationFilter
    inventory?: InventoryListRelationFilter
    jobPost?: JobPostListRelationFilter
    journal?: JournalListRelationFilter
    scopes?: ScopeListRelationFilter
  }, "id" | "depoName">

  export type DepoOrderByWithAggregationInput = {
    id?: SortOrder
    depoName?: SortOrder
    location?: SortOrder
    scopeId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepoCountOrderByAggregateInput
    _avg?: DepoAvgOrderByAggregateInput
    _max?: DepoMaxOrderByAggregateInput
    _min?: DepoMinOrderByAggregateInput
    _sum?: DepoSumOrderByAggregateInput
  }

  export type DepoScalarWhereWithAggregatesInput = {
    AND?: DepoScalarWhereWithAggregatesInput | DepoScalarWhereWithAggregatesInput[]
    OR?: DepoScalarWhereWithAggregatesInput[]
    NOT?: DepoScalarWhereWithAggregatesInput | DepoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Depo"> | number
    depoName?: StringWithAggregatesFilter<"Depo"> | string
    location?: StringWithAggregatesFilter<"Depo"> | string
    scopeId?: IntNullableWithAggregatesFilter<"Depo"> | number | null
    status?: EnumStatusWithAggregatesFilter<"Depo"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"Depo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Depo"> | Date | string
  }

  export type PartyWhereInput = {
    AND?: PartyWhereInput | PartyWhereInput[]
    OR?: PartyWhereInput[]
    NOT?: PartyWhereInput | PartyWhereInput[]
    id?: IntFilter<"Party"> | number
    partyName?: StringFilter<"Party"> | string
    contactNo?: StringFilter<"Party"> | string
    address?: StringFilter<"Party"> | string
    partytype?: EnumPartyTypeFilter<"Party"> | $Enums.PartyType
    openingAmount?: FloatNullableFilter<"Party"> | number | null
    openingDate?: DateTimeFilter<"Party"> | Date | string
    isDeleted?: BoolFilter<"Party"> | boolean
    createdAt?: DateTimeFilter<"Party"> | Date | string
    updatedAt?: DateTimeFilter<"Party"> | Date | string
    transactionInfo?: TransactionInfoListRelationFilter
  }

  export type PartyOrderByWithRelationInput = {
    id?: SortOrder
    partyName?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    partytype?: SortOrder
    openingAmount?: SortOrderInput | SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionInfo?: TransactionInfoOrderByRelationAggregateInput
    _relevance?: PartyOrderByRelevanceInput
  }

  export type PartyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartyWhereInput | PartyWhereInput[]
    OR?: PartyWhereInput[]
    NOT?: PartyWhereInput | PartyWhereInput[]
    partyName?: StringFilter<"Party"> | string
    contactNo?: StringFilter<"Party"> | string
    address?: StringFilter<"Party"> | string
    partytype?: EnumPartyTypeFilter<"Party"> | $Enums.PartyType
    openingAmount?: FloatNullableFilter<"Party"> | number | null
    openingDate?: DateTimeFilter<"Party"> | Date | string
    isDeleted?: BoolFilter<"Party"> | boolean
    createdAt?: DateTimeFilter<"Party"> | Date | string
    updatedAt?: DateTimeFilter<"Party"> | Date | string
    transactionInfo?: TransactionInfoListRelationFilter
  }, "id">

  export type PartyOrderByWithAggregationInput = {
    id?: SortOrder
    partyName?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    partytype?: SortOrder
    openingAmount?: SortOrderInput | SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartyCountOrderByAggregateInput
    _avg?: PartyAvgOrderByAggregateInput
    _max?: PartyMaxOrderByAggregateInput
    _min?: PartyMinOrderByAggregateInput
    _sum?: PartySumOrderByAggregateInput
  }

  export type PartyScalarWhereWithAggregatesInput = {
    AND?: PartyScalarWhereWithAggregatesInput | PartyScalarWhereWithAggregatesInput[]
    OR?: PartyScalarWhereWithAggregatesInput[]
    NOT?: PartyScalarWhereWithAggregatesInput | PartyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Party"> | number
    partyName?: StringWithAggregatesFilter<"Party"> | string
    contactNo?: StringWithAggregatesFilter<"Party"> | string
    address?: StringWithAggregatesFilter<"Party"> | string
    partytype?: EnumPartyTypeWithAggregatesFilter<"Party"> | $Enums.PartyType
    openingAmount?: FloatNullableWithAggregatesFilter<"Party"> | number | null
    openingDate?: DateTimeWithAggregatesFilter<"Party"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Party"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Party"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Party"> | Date | string
  }

  export type StakeholderWhereInput = {
    AND?: StakeholderWhereInput | StakeholderWhereInput[]
    OR?: StakeholderWhereInput[]
    NOT?: StakeholderWhereInput | StakeholderWhereInput[]
    id?: IntFilter<"Stakeholder"> | number
    scopeId?: IntNullableFilter<"Stakeholder"> | number | null
    stakeId?: StringFilter<"Stakeholder"> | string
    name?: StringFilter<"Stakeholder"> | string
    designationId?: IntFilter<"Stakeholder"> | number
    degreeId?: IntFilter<"Stakeholder"> | number
    category?: StringFilter<"Stakeholder"> | string
    officeAddress?: StringFilter<"Stakeholder"> | string
    contactNo?: StringFilter<"Stakeholder"> | string
    honorary?: IntFilter<"Stakeholder"> | number
    paymentDate?: DateTimeFilter<"Stakeholder"> | Date | string
    rxCommitment?: IntFilter<"Stakeholder"> | number
    createdAt?: DateTimeFilter<"Stakeholder"> | Date | string
    updatedAt?: DateTimeFilter<"Stakeholder"> | Date | string
    product?: ProductListRelationFilter
    stakeholderDegree?: XOR<StakeholderDegreeScalarRelationFilter, StakeholderDegreeWhereInput>
    stakeholderDeisgnation?: XOR<StakeholderDeisgnationScalarRelationFilter, StakeholderDeisgnationWhereInput>
    scopes?: ScopeListRelationFilter
    stakeholderChember?: StakeholderChemberListRelationFilter
    stakeholderOcation?: StakeholderOcationListRelationFilter
    transactionInfo?: TransactionInfoListRelationFilter
  }

  export type StakeholderOrderByWithRelationInput = {
    id?: SortOrder
    scopeId?: SortOrderInput | SortOrder
    stakeId?: SortOrder
    name?: SortOrder
    designationId?: SortOrder
    degreeId?: SortOrder
    category?: SortOrder
    officeAddress?: SortOrder
    contactNo?: SortOrder
    honorary?: SortOrder
    paymentDate?: SortOrder
    rxCommitment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByRelationAggregateInput
    stakeholderDegree?: StakeholderDegreeOrderByWithRelationInput
    stakeholderDeisgnation?: StakeholderDeisgnationOrderByWithRelationInput
    scopes?: ScopeOrderByRelationAggregateInput
    stakeholderChember?: stakeholderChemberOrderByRelationAggregateInput
    stakeholderOcation?: StakeholderOcationOrderByRelationAggregateInput
    transactionInfo?: TransactionInfoOrderByRelationAggregateInput
    _relevance?: StakeholderOrderByRelevanceInput
  }

  export type StakeholderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stakeId?: string
    AND?: StakeholderWhereInput | StakeholderWhereInput[]
    OR?: StakeholderWhereInput[]
    NOT?: StakeholderWhereInput | StakeholderWhereInput[]
    scopeId?: IntNullableFilter<"Stakeholder"> | number | null
    name?: StringFilter<"Stakeholder"> | string
    designationId?: IntFilter<"Stakeholder"> | number
    degreeId?: IntFilter<"Stakeholder"> | number
    category?: StringFilter<"Stakeholder"> | string
    officeAddress?: StringFilter<"Stakeholder"> | string
    contactNo?: StringFilter<"Stakeholder"> | string
    honorary?: IntFilter<"Stakeholder"> | number
    paymentDate?: DateTimeFilter<"Stakeholder"> | Date | string
    rxCommitment?: IntFilter<"Stakeholder"> | number
    createdAt?: DateTimeFilter<"Stakeholder"> | Date | string
    updatedAt?: DateTimeFilter<"Stakeholder"> | Date | string
    product?: ProductListRelationFilter
    stakeholderDegree?: XOR<StakeholderDegreeScalarRelationFilter, StakeholderDegreeWhereInput>
    stakeholderDeisgnation?: XOR<StakeholderDeisgnationScalarRelationFilter, StakeholderDeisgnationWhereInput>
    scopes?: ScopeListRelationFilter
    stakeholderChember?: StakeholderChemberListRelationFilter
    stakeholderOcation?: StakeholderOcationListRelationFilter
    transactionInfo?: TransactionInfoListRelationFilter
  }, "id" | "stakeId">

  export type StakeholderOrderByWithAggregationInput = {
    id?: SortOrder
    scopeId?: SortOrderInput | SortOrder
    stakeId?: SortOrder
    name?: SortOrder
    designationId?: SortOrder
    degreeId?: SortOrder
    category?: SortOrder
    officeAddress?: SortOrder
    contactNo?: SortOrder
    honorary?: SortOrder
    paymentDate?: SortOrder
    rxCommitment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StakeholderCountOrderByAggregateInput
    _avg?: StakeholderAvgOrderByAggregateInput
    _max?: StakeholderMaxOrderByAggregateInput
    _min?: StakeholderMinOrderByAggregateInput
    _sum?: StakeholderSumOrderByAggregateInput
  }

  export type StakeholderScalarWhereWithAggregatesInput = {
    AND?: StakeholderScalarWhereWithAggregatesInput | StakeholderScalarWhereWithAggregatesInput[]
    OR?: StakeholderScalarWhereWithAggregatesInput[]
    NOT?: StakeholderScalarWhereWithAggregatesInput | StakeholderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stakeholder"> | number
    scopeId?: IntNullableWithAggregatesFilter<"Stakeholder"> | number | null
    stakeId?: StringWithAggregatesFilter<"Stakeholder"> | string
    name?: StringWithAggregatesFilter<"Stakeholder"> | string
    designationId?: IntWithAggregatesFilter<"Stakeholder"> | number
    degreeId?: IntWithAggregatesFilter<"Stakeholder"> | number
    category?: StringWithAggregatesFilter<"Stakeholder"> | string
    officeAddress?: StringWithAggregatesFilter<"Stakeholder"> | string
    contactNo?: StringWithAggregatesFilter<"Stakeholder"> | string
    honorary?: IntWithAggregatesFilter<"Stakeholder"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Stakeholder"> | Date | string
    rxCommitment?: IntWithAggregatesFilter<"Stakeholder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Stakeholder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stakeholder"> | Date | string
  }

  export type StakeholderDeisgnationWhereInput = {
    AND?: StakeholderDeisgnationWhereInput | StakeholderDeisgnationWhereInput[]
    OR?: StakeholderDeisgnationWhereInput[]
    NOT?: StakeholderDeisgnationWhereInput | StakeholderDeisgnationWhereInput[]
    id?: IntFilter<"StakeholderDeisgnation"> | number
    designation?: StringFilter<"StakeholderDeisgnation"> | string
    description?: StringNullableFilter<"StakeholderDeisgnation"> | string | null
    isDelete?: BoolFilter<"StakeholderDeisgnation"> | boolean
    createdAt?: DateTimeFilter<"StakeholderDeisgnation"> | Date | string
    updatedAt?: DateTimeFilter<"StakeholderDeisgnation"> | Date | string
    stakeholder?: StakeholderListRelationFilter
  }

  export type StakeholderDeisgnationOrderByWithRelationInput = {
    id?: SortOrder
    designation?: SortOrder
    description?: SortOrderInput | SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stakeholder?: StakeholderOrderByRelationAggregateInput
    _relevance?: StakeholderDeisgnationOrderByRelevanceInput
  }

  export type StakeholderDeisgnationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StakeholderDeisgnationWhereInput | StakeholderDeisgnationWhereInput[]
    OR?: StakeholderDeisgnationWhereInput[]
    NOT?: StakeholderDeisgnationWhereInput | StakeholderDeisgnationWhereInput[]
    designation?: StringFilter<"StakeholderDeisgnation"> | string
    description?: StringNullableFilter<"StakeholderDeisgnation"> | string | null
    isDelete?: BoolFilter<"StakeholderDeisgnation"> | boolean
    createdAt?: DateTimeFilter<"StakeholderDeisgnation"> | Date | string
    updatedAt?: DateTimeFilter<"StakeholderDeisgnation"> | Date | string
    stakeholder?: StakeholderListRelationFilter
  }, "id">

  export type StakeholderDeisgnationOrderByWithAggregationInput = {
    id?: SortOrder
    designation?: SortOrder
    description?: SortOrderInput | SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StakeholderDeisgnationCountOrderByAggregateInput
    _avg?: StakeholderDeisgnationAvgOrderByAggregateInput
    _max?: StakeholderDeisgnationMaxOrderByAggregateInput
    _min?: StakeholderDeisgnationMinOrderByAggregateInput
    _sum?: StakeholderDeisgnationSumOrderByAggregateInput
  }

  export type StakeholderDeisgnationScalarWhereWithAggregatesInput = {
    AND?: StakeholderDeisgnationScalarWhereWithAggregatesInput | StakeholderDeisgnationScalarWhereWithAggregatesInput[]
    OR?: StakeholderDeisgnationScalarWhereWithAggregatesInput[]
    NOT?: StakeholderDeisgnationScalarWhereWithAggregatesInput | StakeholderDeisgnationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StakeholderDeisgnation"> | number
    designation?: StringWithAggregatesFilter<"StakeholderDeisgnation"> | string
    description?: StringNullableWithAggregatesFilter<"StakeholderDeisgnation"> | string | null
    isDelete?: BoolWithAggregatesFilter<"StakeholderDeisgnation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StakeholderDeisgnation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StakeholderDeisgnation"> | Date | string
  }

  export type StakeholderDegreeWhereInput = {
    AND?: StakeholderDegreeWhereInput | StakeholderDegreeWhereInput[]
    OR?: StakeholderDegreeWhereInput[]
    NOT?: StakeholderDegreeWhereInput | StakeholderDegreeWhereInput[]
    id?: IntFilter<"StakeholderDegree"> | number
    degreeName?: StringFilter<"StakeholderDegree"> | string
    description?: StringNullableFilter<"StakeholderDegree"> | string | null
    isDelete?: BoolFilter<"StakeholderDegree"> | boolean
    createdAt?: DateTimeFilter<"StakeholderDegree"> | Date | string
    updatedAt?: DateTimeFilter<"StakeholderDegree"> | Date | string
    stakeholder?: StakeholderListRelationFilter
  }

  export type StakeholderDegreeOrderByWithRelationInput = {
    id?: SortOrder
    degreeName?: SortOrder
    description?: SortOrderInput | SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stakeholder?: StakeholderOrderByRelationAggregateInput
    _relevance?: StakeholderDegreeOrderByRelevanceInput
  }

  export type StakeholderDegreeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StakeholderDegreeWhereInput | StakeholderDegreeWhereInput[]
    OR?: StakeholderDegreeWhereInput[]
    NOT?: StakeholderDegreeWhereInput | StakeholderDegreeWhereInput[]
    degreeName?: StringFilter<"StakeholderDegree"> | string
    description?: StringNullableFilter<"StakeholderDegree"> | string | null
    isDelete?: BoolFilter<"StakeholderDegree"> | boolean
    createdAt?: DateTimeFilter<"StakeholderDegree"> | Date | string
    updatedAt?: DateTimeFilter<"StakeholderDegree"> | Date | string
    stakeholder?: StakeholderListRelationFilter
  }, "id">

  export type StakeholderDegreeOrderByWithAggregationInput = {
    id?: SortOrder
    degreeName?: SortOrder
    description?: SortOrderInput | SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StakeholderDegreeCountOrderByAggregateInput
    _avg?: StakeholderDegreeAvgOrderByAggregateInput
    _max?: StakeholderDegreeMaxOrderByAggregateInput
    _min?: StakeholderDegreeMinOrderByAggregateInput
    _sum?: StakeholderDegreeSumOrderByAggregateInput
  }

  export type StakeholderDegreeScalarWhereWithAggregatesInput = {
    AND?: StakeholderDegreeScalarWhereWithAggregatesInput | StakeholderDegreeScalarWhereWithAggregatesInput[]
    OR?: StakeholderDegreeScalarWhereWithAggregatesInput[]
    NOT?: StakeholderDegreeScalarWhereWithAggregatesInput | StakeholderDegreeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StakeholderDegree"> | number
    degreeName?: StringWithAggregatesFilter<"StakeholderDegree"> | string
    description?: StringNullableWithAggregatesFilter<"StakeholderDegree"> | string | null
    isDelete?: BoolWithAggregatesFilter<"StakeholderDegree"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StakeholderDegree"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StakeholderDegree"> | Date | string
  }

  export type stakeholderChemberWhereInput = {
    AND?: stakeholderChemberWhereInput | stakeholderChemberWhereInput[]
    OR?: stakeholderChemberWhereInput[]
    NOT?: stakeholderChemberWhereInput | stakeholderChemberWhereInput[]
    id?: IntFilter<"stakeholderChember"> | number
    stakeId?: StringNullableFilter<"stakeholderChember"> | string | null
    address?: StringFilter<"stakeholderChember"> | string
    chemberDay?: StringFilter<"stakeholderChember"> | string
    chemberTime?: StringFilter<"stakeholderChember"> | string
    chemberName?: StringFilter<"stakeholderChember"> | string
    location?: StringFilter<"stakeholderChember"> | string
    createdAt?: DateTimeFilter<"stakeholderChember"> | Date | string
    updatedAt?: DateTimeFilter<"stakeholderChember"> | Date | string
    stakeholder?: XOR<StakeholderNullableScalarRelationFilter, StakeholderWhereInput> | null
  }

  export type stakeholderChemberOrderByWithRelationInput = {
    id?: SortOrder
    stakeId?: SortOrderInput | SortOrder
    address?: SortOrder
    chemberDay?: SortOrder
    chemberTime?: SortOrder
    chemberName?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stakeholder?: StakeholderOrderByWithRelationInput
    _relevance?: stakeholderChemberOrderByRelevanceInput
  }

  export type stakeholderChemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: stakeholderChemberWhereInput | stakeholderChemberWhereInput[]
    OR?: stakeholderChemberWhereInput[]
    NOT?: stakeholderChemberWhereInput | stakeholderChemberWhereInput[]
    stakeId?: StringNullableFilter<"stakeholderChember"> | string | null
    address?: StringFilter<"stakeholderChember"> | string
    chemberDay?: StringFilter<"stakeholderChember"> | string
    chemberTime?: StringFilter<"stakeholderChember"> | string
    chemberName?: StringFilter<"stakeholderChember"> | string
    location?: StringFilter<"stakeholderChember"> | string
    createdAt?: DateTimeFilter<"stakeholderChember"> | Date | string
    updatedAt?: DateTimeFilter<"stakeholderChember"> | Date | string
    stakeholder?: XOR<StakeholderNullableScalarRelationFilter, StakeholderWhereInput> | null
  }, "id">

  export type stakeholderChemberOrderByWithAggregationInput = {
    id?: SortOrder
    stakeId?: SortOrderInput | SortOrder
    address?: SortOrder
    chemberDay?: SortOrder
    chemberTime?: SortOrder
    chemberName?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: stakeholderChemberCountOrderByAggregateInput
    _avg?: stakeholderChemberAvgOrderByAggregateInput
    _max?: stakeholderChemberMaxOrderByAggregateInput
    _min?: stakeholderChemberMinOrderByAggregateInput
    _sum?: stakeholderChemberSumOrderByAggregateInput
  }

  export type stakeholderChemberScalarWhereWithAggregatesInput = {
    AND?: stakeholderChemberScalarWhereWithAggregatesInput | stakeholderChemberScalarWhereWithAggregatesInput[]
    OR?: stakeholderChemberScalarWhereWithAggregatesInput[]
    NOT?: stakeholderChemberScalarWhereWithAggregatesInput | stakeholderChemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"stakeholderChember"> | number
    stakeId?: StringNullableWithAggregatesFilter<"stakeholderChember"> | string | null
    address?: StringWithAggregatesFilter<"stakeholderChember"> | string
    chemberDay?: StringWithAggregatesFilter<"stakeholderChember"> | string
    chemberTime?: StringWithAggregatesFilter<"stakeholderChember"> | string
    chemberName?: StringWithAggregatesFilter<"stakeholderChember"> | string
    location?: StringWithAggregatesFilter<"stakeholderChember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"stakeholderChember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"stakeholderChember"> | Date | string
  }

  export type StakeholderOcationWhereInput = {
    AND?: StakeholderOcationWhereInput | StakeholderOcationWhereInput[]
    OR?: StakeholderOcationWhereInput[]
    NOT?: StakeholderOcationWhereInput | StakeholderOcationWhereInput[]
    id?: IntFilter<"StakeholderOcation"> | number
    stakeId?: StringFilter<"StakeholderOcation"> | string
    ocationName?: StringFilter<"StakeholderOcation"> | string
    relation?: StringFilter<"StakeholderOcation"> | string
    personName?: StringNullableFilter<"StakeholderOcation"> | string | null
    dob?: DateTimeNullableFilter<"StakeholderOcation"> | Date | string | null
    otherInfo?: StringNullableFilter<"StakeholderOcation"> | string | null
    stakeholder?: XOR<StakeholderScalarRelationFilter, StakeholderWhereInput>
  }

  export type StakeholderOcationOrderByWithRelationInput = {
    id?: SortOrder
    stakeId?: SortOrder
    ocationName?: SortOrder
    relation?: SortOrder
    personName?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    otherInfo?: SortOrderInput | SortOrder
    stakeholder?: StakeholderOrderByWithRelationInput
    _relevance?: StakeholderOcationOrderByRelevanceInput
  }

  export type StakeholderOcationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StakeholderOcationWhereInput | StakeholderOcationWhereInput[]
    OR?: StakeholderOcationWhereInput[]
    NOT?: StakeholderOcationWhereInput | StakeholderOcationWhereInput[]
    stakeId?: StringFilter<"StakeholderOcation"> | string
    ocationName?: StringFilter<"StakeholderOcation"> | string
    relation?: StringFilter<"StakeholderOcation"> | string
    personName?: StringNullableFilter<"StakeholderOcation"> | string | null
    dob?: DateTimeNullableFilter<"StakeholderOcation"> | Date | string | null
    otherInfo?: StringNullableFilter<"StakeholderOcation"> | string | null
    stakeholder?: XOR<StakeholderScalarRelationFilter, StakeholderWhereInput>
  }, "id">

  export type StakeholderOcationOrderByWithAggregationInput = {
    id?: SortOrder
    stakeId?: SortOrder
    ocationName?: SortOrder
    relation?: SortOrder
    personName?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    otherInfo?: SortOrderInput | SortOrder
    _count?: StakeholderOcationCountOrderByAggregateInput
    _avg?: StakeholderOcationAvgOrderByAggregateInput
    _max?: StakeholderOcationMaxOrderByAggregateInput
    _min?: StakeholderOcationMinOrderByAggregateInput
    _sum?: StakeholderOcationSumOrderByAggregateInput
  }

  export type StakeholderOcationScalarWhereWithAggregatesInput = {
    AND?: StakeholderOcationScalarWhereWithAggregatesInput | StakeholderOcationScalarWhereWithAggregatesInput[]
    OR?: StakeholderOcationScalarWhereWithAggregatesInput[]
    NOT?: StakeholderOcationScalarWhereWithAggregatesInput | StakeholderOcationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StakeholderOcation"> | number
    stakeId?: StringWithAggregatesFilter<"StakeholderOcation"> | string
    ocationName?: StringWithAggregatesFilter<"StakeholderOcation"> | string
    relation?: StringWithAggregatesFilter<"StakeholderOcation"> | string
    personName?: StringNullableWithAggregatesFilter<"StakeholderOcation"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"StakeholderOcation"> | Date | string | null
    otherInfo?: StringNullableWithAggregatesFilter<"StakeholderOcation"> | string | null
  }

  export type CustomersWhereInput = {
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    id?: IntFilter<"Customers"> | number
    name?: StringNullableFilter<"Customers"> | string | null
    contactNo?: StringFilter<"Customers"> | string
    address?: StringNullableFilter<"Customers"> | string | null
    createdAt?: DateTimeFilter<"Customers"> | Date | string
    updatedAt?: DateTimeFilter<"Customers"> | Date | string
    transactionInfo?: TransactionInfoListRelationFilter
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    contactNo?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionInfo?: TransactionInfoOrderByRelationAggregateInput
    _relevance?: CustomersOrderByRelevanceInput
  }

  export type CustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    name?: StringNullableFilter<"Customers"> | string | null
    contactNo?: StringFilter<"Customers"> | string
    address?: StringNullableFilter<"Customers"> | string | null
    createdAt?: DateTimeFilter<"Customers"> | Date | string
    updatedAt?: DateTimeFilter<"Customers"> | Date | string
    transactionInfo?: TransactionInfoListRelationFilter
  }, "id">

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    contactNo?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    OR?: CustomersScalarWhereWithAggregatesInput[]
    NOT?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customers"> | number
    name?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    contactNo?: StringWithAggregatesFilter<"Customers"> | string
    address?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customers"> | Date | string
  }

  export type ScopeWhereInput = {
    AND?: ScopeWhereInput | ScopeWhereInput[]
    OR?: ScopeWhereInput[]
    NOT?: ScopeWhereInput | ScopeWhereInput[]
    id?: IntFilter<"Scope"> | number
    employeeId?: StringFilter<"Scope"> | string
    postId?: IntFilter<"Scope"> | number
    createdAt?: DateTimeFilter<"Scope"> | Date | string
    updatedAt?: DateTimeFilter<"Scope"> | Date | string
    chemist?: ChemistListRelationFilter
    depo?: DepoListRelationFilter
    stakeholder?: StakeholderListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    jobPost?: XOR<JobPostScalarRelationFilter, JobPostWhereInput>
  }

  export type ScopeOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chemist?: ChemistOrderByRelationAggregateInput
    depo?: DepoOrderByRelationAggregateInput
    stakeholder?: StakeholderOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    jobPost?: JobPostOrderByWithRelationInput
    _relevance?: ScopeOrderByRelevanceInput
  }

  export type ScopeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId?: string
    AND?: ScopeWhereInput | ScopeWhereInput[]
    OR?: ScopeWhereInput[]
    NOT?: ScopeWhereInput | ScopeWhereInput[]
    postId?: IntFilter<"Scope"> | number
    createdAt?: DateTimeFilter<"Scope"> | Date | string
    updatedAt?: DateTimeFilter<"Scope"> | Date | string
    chemist?: ChemistListRelationFilter
    depo?: DepoListRelationFilter
    stakeholder?: StakeholderListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    jobPost?: XOR<JobPostScalarRelationFilter, JobPostWhereInput>
  }, "id" | "employeeId">

  export type ScopeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScopeCountOrderByAggregateInput
    _avg?: ScopeAvgOrderByAggregateInput
    _max?: ScopeMaxOrderByAggregateInput
    _min?: ScopeMinOrderByAggregateInput
    _sum?: ScopeSumOrderByAggregateInput
  }

  export type ScopeScalarWhereWithAggregatesInput = {
    AND?: ScopeScalarWhereWithAggregatesInput | ScopeScalarWhereWithAggregatesInput[]
    OR?: ScopeScalarWhereWithAggregatesInput[]
    NOT?: ScopeScalarWhereWithAggregatesInput | ScopeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Scope"> | number
    employeeId?: StringWithAggregatesFilter<"Scope"> | string
    postId?: IntWithAggregatesFilter<"Scope"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Scope"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Scope"> | Date | string
  }

  export type MpoTargetWhereInput = {
    AND?: MpoTargetWhereInput | MpoTargetWhereInput[]
    OR?: MpoTargetWhereInput[]
    NOT?: MpoTargetWhereInput | MpoTargetWhereInput[]
    id?: IntFilter<"MpoTarget"> | number
    employeeId?: StringFilter<"MpoTarget"> | string
    month?: StringFilter<"MpoTarget"> | string
    tergatAmount?: IntFilter<"MpoTarget"> | number
    createdAt?: DateTimeFilter<"MpoTarget"> | Date | string
    updatedAt?: DateTimeFilter<"MpoTarget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MpoTargetOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    tergatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: MpoTargetOrderByRelevanceInput
  }

  export type MpoTargetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId?: string
    AND?: MpoTargetWhereInput | MpoTargetWhereInput[]
    OR?: MpoTargetWhereInput[]
    NOT?: MpoTargetWhereInput | MpoTargetWhereInput[]
    month?: StringFilter<"MpoTarget"> | string
    tergatAmount?: IntFilter<"MpoTarget"> | number
    createdAt?: DateTimeFilter<"MpoTarget"> | Date | string
    updatedAt?: DateTimeFilter<"MpoTarget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "employeeId">

  export type MpoTargetOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    tergatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MpoTargetCountOrderByAggregateInput
    _avg?: MpoTargetAvgOrderByAggregateInput
    _max?: MpoTargetMaxOrderByAggregateInput
    _min?: MpoTargetMinOrderByAggregateInput
    _sum?: MpoTargetSumOrderByAggregateInput
  }

  export type MpoTargetScalarWhereWithAggregatesInput = {
    AND?: MpoTargetScalarWhereWithAggregatesInput | MpoTargetScalarWhereWithAggregatesInput[]
    OR?: MpoTargetScalarWhereWithAggregatesInput[]
    NOT?: MpoTargetScalarWhereWithAggregatesInput | MpoTargetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MpoTarget"> | number
    employeeId?: StringWithAggregatesFilter<"MpoTarget"> | string
    month?: StringWithAggregatesFilter<"MpoTarget"> | string
    tergatAmount?: IntWithAggregatesFilter<"MpoTarget"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MpoTarget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MpoTarget"> | Date | string
  }

  export type ProductWiseTargetWhereInput = {
    AND?: ProductWiseTargetWhereInput | ProductWiseTargetWhereInput[]
    OR?: ProductWiseTargetWhereInput[]
    NOT?: ProductWiseTargetWhereInput | ProductWiseTargetWhereInput[]
    id?: IntFilter<"ProductWiseTarget"> | number
    employeeId?: StringFilter<"ProductWiseTarget"> | string
    targetStart?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    targetEnd?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    targetType?: EnumTargetTypeFilter<"ProductWiseTarget"> | $Enums.TargetType
    createdAt?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    updatedAt?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    targetProductBatch?: TargetProductBatchListRelationFilter
  }

  export type ProductWiseTargetOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    targetStart?: SortOrder
    targetEnd?: SortOrder
    targetType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    targetProductBatch?: TargetProductBatchOrderByRelationAggregateInput
    _relevance?: ProductWiseTargetOrderByRelevanceInput
  }

  export type ProductWiseTargetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId?: string
    AND?: ProductWiseTargetWhereInput | ProductWiseTargetWhereInput[]
    OR?: ProductWiseTargetWhereInput[]
    NOT?: ProductWiseTargetWhereInput | ProductWiseTargetWhereInput[]
    targetStart?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    targetEnd?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    targetType?: EnumTargetTypeFilter<"ProductWiseTarget"> | $Enums.TargetType
    createdAt?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    updatedAt?: DateTimeFilter<"ProductWiseTarget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    targetProductBatch?: TargetProductBatchListRelationFilter
  }, "id" | "employeeId">

  export type ProductWiseTargetOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    targetStart?: SortOrder
    targetEnd?: SortOrder
    targetType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductWiseTargetCountOrderByAggregateInput
    _avg?: ProductWiseTargetAvgOrderByAggregateInput
    _max?: ProductWiseTargetMaxOrderByAggregateInput
    _min?: ProductWiseTargetMinOrderByAggregateInput
    _sum?: ProductWiseTargetSumOrderByAggregateInput
  }

  export type ProductWiseTargetScalarWhereWithAggregatesInput = {
    AND?: ProductWiseTargetScalarWhereWithAggregatesInput | ProductWiseTargetScalarWhereWithAggregatesInput[]
    OR?: ProductWiseTargetScalarWhereWithAggregatesInput[]
    NOT?: ProductWiseTargetScalarWhereWithAggregatesInput | ProductWiseTargetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductWiseTarget"> | number
    employeeId?: StringWithAggregatesFilter<"ProductWiseTarget"> | string
    targetStart?: DateTimeWithAggregatesFilter<"ProductWiseTarget"> | Date | string
    targetEnd?: DateTimeWithAggregatesFilter<"ProductWiseTarget"> | Date | string
    targetType?: EnumTargetTypeWithAggregatesFilter<"ProductWiseTarget"> | $Enums.TargetType
    createdAt?: DateTimeWithAggregatesFilter<"ProductWiseTarget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductWiseTarget"> | Date | string
  }

  export type TargetProductBatchWhereInput = {
    AND?: TargetProductBatchWhereInput | TargetProductBatchWhereInput[]
    OR?: TargetProductBatchWhereInput[]
    NOT?: TargetProductBatchWhereInput | TargetProductBatchWhereInput[]
    id?: IntFilter<"TargetProductBatch"> | number
    productId?: IntFilter<"TargetProductBatch"> | number
    productTargetId?: IntFilter<"TargetProductBatch"> | number
    numberOfProduct?: IntFilter<"TargetProductBatch"> | number
    insentiveAmount?: FloatFilter<"TargetProductBatch"> | number
    createdAt?: DateTimeFilter<"TargetProductBatch"> | Date | string
    updatedAt?: DateTimeFilter<"TargetProductBatch"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    productWiseTarget?: XOR<ProductWiseTargetScalarRelationFilter, ProductWiseTargetWhereInput>
  }

  export type TargetProductBatchOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    productTargetId?: SortOrder
    numberOfProduct?: SortOrder
    insentiveAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    productWiseTarget?: ProductWiseTargetOrderByWithRelationInput
  }

  export type TargetProductBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TargetProductBatchWhereInput | TargetProductBatchWhereInput[]
    OR?: TargetProductBatchWhereInput[]
    NOT?: TargetProductBatchWhereInput | TargetProductBatchWhereInput[]
    productId?: IntFilter<"TargetProductBatch"> | number
    productTargetId?: IntFilter<"TargetProductBatch"> | number
    numberOfProduct?: IntFilter<"TargetProductBatch"> | number
    insentiveAmount?: FloatFilter<"TargetProductBatch"> | number
    createdAt?: DateTimeFilter<"TargetProductBatch"> | Date | string
    updatedAt?: DateTimeFilter<"TargetProductBatch"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    productWiseTarget?: XOR<ProductWiseTargetScalarRelationFilter, ProductWiseTargetWhereInput>
  }, "id">

  export type TargetProductBatchOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    productTargetId?: SortOrder
    numberOfProduct?: SortOrder
    insentiveAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TargetProductBatchCountOrderByAggregateInput
    _avg?: TargetProductBatchAvgOrderByAggregateInput
    _max?: TargetProductBatchMaxOrderByAggregateInput
    _min?: TargetProductBatchMinOrderByAggregateInput
    _sum?: TargetProductBatchSumOrderByAggregateInput
  }

  export type TargetProductBatchScalarWhereWithAggregatesInput = {
    AND?: TargetProductBatchScalarWhereWithAggregatesInput | TargetProductBatchScalarWhereWithAggregatesInput[]
    OR?: TargetProductBatchScalarWhereWithAggregatesInput[]
    NOT?: TargetProductBatchScalarWhereWithAggregatesInput | TargetProductBatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TargetProductBatch"> | number
    productId?: IntWithAggregatesFilter<"TargetProductBatch"> | number
    productTargetId?: IntWithAggregatesFilter<"TargetProductBatch"> | number
    numberOfProduct?: IntWithAggregatesFilter<"TargetProductBatch"> | number
    insentiveAmount?: FloatWithAggregatesFilter<"TargetProductBatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TargetProductBatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TargetProductBatch"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    categoryName?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    subCategory?: SubCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subCategory?: SubCategoryOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    categoryName?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    subCategory?: SubCategoryListRelationFilter
  }, "id" | "categoryName">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    categoryName?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type SubCategoryWhereInput = {
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    id?: IntFilter<"SubCategory"> | number
    subCategoryName?: StringFilter<"SubCategory"> | string
    categoryId?: IntFilter<"SubCategory"> | number
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
    product?: ProductListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type SubCategoryOrderByWithRelationInput = {
    id?: SortOrder
    subCategoryName?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    _relevance?: SubCategoryOrderByRelevanceInput
  }

  export type SubCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    subCategoryName?: StringFilter<"SubCategory"> | string
    categoryId?: IntFilter<"SubCategory"> | number
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
    product?: ProductListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id">

  export type SubCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    subCategoryName?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubCategoryCountOrderByAggregateInput
    _avg?: SubCategoryAvgOrderByAggregateInput
    _max?: SubCategoryMaxOrderByAggregateInput
    _min?: SubCategoryMinOrderByAggregateInput
    _sum?: SubCategorySumOrderByAggregateInput
  }

  export type SubCategoryScalarWhereWithAggregatesInput = {
    AND?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    OR?: SubCategoryScalarWhereWithAggregatesInput[]
    NOT?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubCategory"> | number
    subCategoryName?: StringWithAggregatesFilter<"SubCategory"> | string
    categoryId?: IntWithAggregatesFilter<"SubCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubCategory"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    name?: StringFilter<"Unit"> | string
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updateAt?: DateTimeFilter<"Unit"> | Date | string
    product?: ProductListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    product?: ProductOrderByRelationAggregateInput
    _relevance?: UnitOrderByRelevanceInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updateAt?: DateTimeFilter<"Unit"> | Date | string
    product?: ProductListRelationFilter
  }, "id" | "name">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    name?: StringWithAggregatesFilter<"Unit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type AccountHeadWhereInput = {
    AND?: AccountHeadWhereInput | AccountHeadWhereInput[]
    OR?: AccountHeadWhereInput[]
    NOT?: AccountHeadWhereInput | AccountHeadWhereInput[]
    id?: IntFilter<"AccountHead"> | number
    headName?: StringFilter<"AccountHead"> | string
    headCode?: StringFilter<"AccountHead"> | string
    createdAt?: DateTimeFilter<"AccountHead"> | Date | string
    updateAt?: DateTimeFilter<"AccountHead"> | Date | string
    ledgerHead?: LedgerHeadListRelationFilter
  }

  export type AccountHeadOrderByWithRelationInput = {
    id?: SortOrder
    headName?: SortOrder
    headCode?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    ledgerHead?: LedgerHeadOrderByRelationAggregateInput
    _relevance?: AccountHeadOrderByRelevanceInput
  }

  export type AccountHeadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountHeadWhereInput | AccountHeadWhereInput[]
    OR?: AccountHeadWhereInput[]
    NOT?: AccountHeadWhereInput | AccountHeadWhereInput[]
    headName?: StringFilter<"AccountHead"> | string
    headCode?: StringFilter<"AccountHead"> | string
    createdAt?: DateTimeFilter<"AccountHead"> | Date | string
    updateAt?: DateTimeFilter<"AccountHead"> | Date | string
    ledgerHead?: LedgerHeadListRelationFilter
  }, "id">

  export type AccountHeadOrderByWithAggregationInput = {
    id?: SortOrder
    headName?: SortOrder
    headCode?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: AccountHeadCountOrderByAggregateInput
    _avg?: AccountHeadAvgOrderByAggregateInput
    _max?: AccountHeadMaxOrderByAggregateInput
    _min?: AccountHeadMinOrderByAggregateInput
    _sum?: AccountHeadSumOrderByAggregateInput
  }

  export type AccountHeadScalarWhereWithAggregatesInput = {
    AND?: AccountHeadScalarWhereWithAggregatesInput | AccountHeadScalarWhereWithAggregatesInput[]
    OR?: AccountHeadScalarWhereWithAggregatesInput[]
    NOT?: AccountHeadScalarWhereWithAggregatesInput | AccountHeadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountHead"> | number
    headName?: StringWithAggregatesFilter<"AccountHead"> | string
    headCode?: StringWithAggregatesFilter<"AccountHead"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AccountHead"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"AccountHead"> | Date | string
  }

  export type LedgerHeadWhereInput = {
    AND?: LedgerHeadWhereInput | LedgerHeadWhereInput[]
    OR?: LedgerHeadWhereInput[]
    NOT?: LedgerHeadWhereInput | LedgerHeadWhereInput[]
    id?: IntFilter<"LedgerHead"> | number
    ledgerName?: StringFilter<"LedgerHead"> | string
    ledgerCode?: StringFilter<"LedgerHead"> | string
    headCodeId?: IntFilter<"LedgerHead"> | number
    createdAt?: DateTimeFilter<"LedgerHead"> | Date | string
    updatedAt?: DateTimeFilter<"LedgerHead"> | Date | string
    fixedJournal?: FixedJournalListRelationFilter
    journal?: JournalListRelationFilter
    accountHead?: XOR<AccountHeadScalarRelationFilter, AccountHeadWhereInput>
  }

  export type LedgerHeadOrderByWithRelationInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    ledgerCode?: SortOrder
    headCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fixedJournal?: FixedJournalOrderByRelationAggregateInput
    journal?: JournalOrderByRelationAggregateInput
    accountHead?: AccountHeadOrderByWithRelationInput
    _relevance?: LedgerHeadOrderByRelevanceInput
  }

  export type LedgerHeadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LedgerHeadWhereInput | LedgerHeadWhereInput[]
    OR?: LedgerHeadWhereInput[]
    NOT?: LedgerHeadWhereInput | LedgerHeadWhereInput[]
    ledgerName?: StringFilter<"LedgerHead"> | string
    ledgerCode?: StringFilter<"LedgerHead"> | string
    headCodeId?: IntFilter<"LedgerHead"> | number
    createdAt?: DateTimeFilter<"LedgerHead"> | Date | string
    updatedAt?: DateTimeFilter<"LedgerHead"> | Date | string
    fixedJournal?: FixedJournalListRelationFilter
    journal?: JournalListRelationFilter
    accountHead?: XOR<AccountHeadScalarRelationFilter, AccountHeadWhereInput>
  }, "id">

  export type LedgerHeadOrderByWithAggregationInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    ledgerCode?: SortOrder
    headCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LedgerHeadCountOrderByAggregateInput
    _avg?: LedgerHeadAvgOrderByAggregateInput
    _max?: LedgerHeadMaxOrderByAggregateInput
    _min?: LedgerHeadMinOrderByAggregateInput
    _sum?: LedgerHeadSumOrderByAggregateInput
  }

  export type LedgerHeadScalarWhereWithAggregatesInput = {
    AND?: LedgerHeadScalarWhereWithAggregatesInput | LedgerHeadScalarWhereWithAggregatesInput[]
    OR?: LedgerHeadScalarWhereWithAggregatesInput[]
    NOT?: LedgerHeadScalarWhereWithAggregatesInput | LedgerHeadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LedgerHead"> | number
    ledgerName?: StringWithAggregatesFilter<"LedgerHead"> | string
    ledgerCode?: StringWithAggregatesFilter<"LedgerHead"> | string
    headCodeId?: IntWithAggregatesFilter<"LedgerHead"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LedgerHead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LedgerHead"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    subCategoryId?: IntFilter<"Product"> | number
    stakeholderId?: IntNullableFilter<"Product"> | number | null
    size?: StringFilter<"Product"> | string
    unitId?: IntFilter<"Product"> | number
    mrp?: FloatFilter<"Product"> | number
    tp?: FloatFilter<"Product"> | number
    balance?: FloatFilter<"Product"> | number
    quantity?: FloatFilter<"Product"> | number
    unitPrice?: FloatFilter<"Product"> | number
    date?: DateTimeFilter<"Product"> | Date | string
    status?: EnumStatusFilter<"Product"> | $Enums.Status
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updateAt?: DateTimeFilter<"Product"> | Date | string
    targetProductBatch?: TargetProductBatchListRelationFilter
    inventory?: InventoryListRelationFilter
    orderItem?: OrderItemListRelationFilter
    Stakeholder?: XOR<StakeholderNullableScalarRelationFilter, StakeholderWhereInput> | null
    subCategory?: XOR<SubCategoryScalarRelationFilter, SubCategoryWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subCategoryId?: SortOrder
    stakeholderId?: SortOrderInput | SortOrder
    size?: SortOrder
    unitId?: SortOrder
    mrp?: SortOrder
    tp?: SortOrder
    balance?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    targetProductBatch?: TargetProductBatchOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    orderItem?: OrderItemOrderByRelationAggregateInput
    Stakeholder?: StakeholderOrderByWithRelationInput
    subCategory?: SubCategoryOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    subCategoryId?: IntFilter<"Product"> | number
    stakeholderId?: IntNullableFilter<"Product"> | number | null
    size?: StringFilter<"Product"> | string
    unitId?: IntFilter<"Product"> | number
    mrp?: FloatFilter<"Product"> | number
    tp?: FloatFilter<"Product"> | number
    balance?: FloatFilter<"Product"> | number
    quantity?: FloatFilter<"Product"> | number
    unitPrice?: FloatFilter<"Product"> | number
    date?: DateTimeFilter<"Product"> | Date | string
    status?: EnumStatusFilter<"Product"> | $Enums.Status
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updateAt?: DateTimeFilter<"Product"> | Date | string
    targetProductBatch?: TargetProductBatchListRelationFilter
    inventory?: InventoryListRelationFilter
    orderItem?: OrderItemListRelationFilter
    Stakeholder?: XOR<StakeholderNullableScalarRelationFilter, StakeholderWhereInput> | null
    subCategory?: XOR<SubCategoryScalarRelationFilter, SubCategoryWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subCategoryId?: SortOrder
    stakeholderId?: SortOrderInput | SortOrder
    size?: SortOrder
    unitId?: SortOrder
    mrp?: SortOrder
    tp?: SortOrder
    balance?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    subCategoryId?: IntWithAggregatesFilter<"Product"> | number
    stakeholderId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    size?: StringWithAggregatesFilter<"Product"> | string
    unitId?: IntWithAggregatesFilter<"Product"> | number
    mrp?: FloatWithAggregatesFilter<"Product"> | number
    tp?: FloatWithAggregatesFilter<"Product"> | number
    balance?: FloatWithAggregatesFilter<"Product"> | number
    quantity?: FloatWithAggregatesFilter<"Product"> | number
    unitPrice?: FloatWithAggregatesFilter<"Product"> | number
    date?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    status?: EnumStatusWithAggregatesFilter<"Product"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: IntFilter<"BankAccount"> | number
    bankName?: StringFilter<"BankAccount"> | string
    branceName?: StringNullableFilter<"BankAccount"> | string | null
    accountNumber?: StringFilter<"BankAccount"> | string
    status?: EnumStatusFilter<"BankAccount"> | $Enums.Status
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    bankTransaction?: BankTransactionListRelationFilter
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    bankName?: SortOrder
    branceName?: SortOrderInput | SortOrder
    accountNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bankTransaction?: BankTransactionOrderByRelationAggregateInput
    _relevance?: BankAccountOrderByRelevanceInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bankName_accountNumber?: BankAccountBankNameAccountNumberCompoundUniqueInput
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    bankName?: StringFilter<"BankAccount"> | string
    branceName?: StringNullableFilter<"BankAccount"> | string | null
    accountNumber?: StringFilter<"BankAccount"> | string
    status?: EnumStatusFilter<"BankAccount"> | $Enums.Status
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    bankTransaction?: BankTransactionListRelationFilter
  }, "id" | "bankName_accountNumber">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    bankName?: SortOrder
    branceName?: SortOrderInput | SortOrder
    accountNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BankAccount"> | number
    bankName?: StringWithAggregatesFilter<"BankAccount"> | string
    branceName?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    accountNumber?: StringWithAggregatesFilter<"BankAccount"> | string
    status?: EnumStatusWithAggregatesFilter<"BankAccount"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type BankTransactionWhereInput = {
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    id?: IntFilter<"BankTransaction"> | number
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccountId?: IntFilter<"BankTransaction"> | number
    debitAmount?: IntNullableFilter<"BankTransaction"> | number | null
    creditAmount?: IntNullableFilter<"BankTransaction"> | number | null
    journalId?: IntNullableFilter<"BankTransaction"> | number | null
    isClosing?: BoolFilter<"BankTransaction"> | boolean
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccount?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    journal?: XOR<JournalNullableScalarRelationFilter, JournalWhereInput> | null
  }

  export type BankTransactionOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    bankAccountId?: SortOrder
    debitAmount?: SortOrderInput | SortOrder
    creditAmount?: SortOrderInput | SortOrder
    journalId?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bankAccount?: BankAccountOrderByWithRelationInput
    journal?: JournalOrderByWithRelationInput
  }

  export type BankTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccountId?: IntFilter<"BankTransaction"> | number
    debitAmount?: IntNullableFilter<"BankTransaction"> | number | null
    creditAmount?: IntNullableFilter<"BankTransaction"> | number | null
    journalId?: IntNullableFilter<"BankTransaction"> | number | null
    isClosing?: BoolFilter<"BankTransaction"> | boolean
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccount?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    journal?: XOR<JournalNullableScalarRelationFilter, JournalWhereInput> | null
  }, "id">

  export type BankTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    bankAccountId?: SortOrder
    debitAmount?: SortOrderInput | SortOrder
    creditAmount?: SortOrderInput | SortOrder
    journalId?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankTransactionCountOrderByAggregateInput
    _avg?: BankTransactionAvgOrderByAggregateInput
    _max?: BankTransactionMaxOrderByAggregateInput
    _min?: BankTransactionMinOrderByAggregateInput
    _sum?: BankTransactionSumOrderByAggregateInput
  }

  export type BankTransactionScalarWhereWithAggregatesInput = {
    AND?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    OR?: BankTransactionScalarWhereWithAggregatesInput[]
    NOT?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BankTransaction"> | number
    date?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    bankAccountId?: IntWithAggregatesFilter<"BankTransaction"> | number
    debitAmount?: IntNullableWithAggregatesFilter<"BankTransaction"> | number | null
    creditAmount?: IntNullableWithAggregatesFilter<"BankTransaction"> | number | null
    journalId?: IntNullableWithAggregatesFilter<"BankTransaction"> | number | null
    isClosing?: BoolWithAggregatesFilter<"BankTransaction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: IntFilter<"Inventory"> | number
    date?: DateTimeFilter<"Inventory"> | Date | string
    productId?: IntFilter<"Inventory"> | number
    depoId?: IntNullableFilter<"Inventory"> | number | null
    employeeId?: StringNullableFilter<"Inventory"> | string | null
    transactionId?: IntNullableFilter<"Inventory"> | number | null
    fixedJournalId?: IntNullableFilter<"Inventory"> | number | null
    unitPrice?: FloatFilter<"Inventory"> | number
    quantityAdd?: FloatNullableFilter<"Inventory"> | number | null
    quantityLess?: FloatNullableFilter<"Inventory"> | number | null
    debitAmount?: FloatNullableFilter<"Inventory"> | number | null
    creditAmount?: FloatNullableFilter<"Inventory"> | number | null
    isClosing?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    isFixted?: BoolFilter<"Inventory"> | boolean
    depo?: XOR<DepoNullableScalarRelationFilter, DepoWhereInput> | null
    fixedJournal?: XOR<FixedJournalNullableScalarRelationFilter, FixedJournalWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    transactionInfo?: XOR<TransactionInfoNullableScalarRelationFilter, TransactionInfoWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    productId?: SortOrder
    depoId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    fixedJournalId?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    quantityAdd?: SortOrderInput | SortOrder
    quantityLess?: SortOrderInput | SortOrder
    debitAmount?: SortOrderInput | SortOrder
    creditAmount?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFixted?: SortOrder
    depo?: DepoOrderByWithRelationInput
    fixedJournal?: FixedJournalOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    transactionInfo?: TransactionInfoOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: InventoryOrderByRelevanceInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    date?: DateTimeFilter<"Inventory"> | Date | string
    productId?: IntFilter<"Inventory"> | number
    depoId?: IntNullableFilter<"Inventory"> | number | null
    employeeId?: StringNullableFilter<"Inventory"> | string | null
    transactionId?: IntNullableFilter<"Inventory"> | number | null
    fixedJournalId?: IntNullableFilter<"Inventory"> | number | null
    unitPrice?: FloatFilter<"Inventory"> | number
    quantityAdd?: FloatNullableFilter<"Inventory"> | number | null
    quantityLess?: FloatNullableFilter<"Inventory"> | number | null
    debitAmount?: FloatNullableFilter<"Inventory"> | number | null
    creditAmount?: FloatNullableFilter<"Inventory"> | number | null
    isClosing?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    isFixted?: BoolFilter<"Inventory"> | boolean
    depo?: XOR<DepoNullableScalarRelationFilter, DepoWhereInput> | null
    fixedJournal?: XOR<FixedJournalNullableScalarRelationFilter, FixedJournalWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    transactionInfo?: XOR<TransactionInfoNullableScalarRelationFilter, TransactionInfoWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    productId?: SortOrder
    depoId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    fixedJournalId?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    quantityAdd?: SortOrderInput | SortOrder
    quantityLess?: SortOrderInput | SortOrder
    debitAmount?: SortOrderInput | SortOrder
    creditAmount?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFixted?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventory"> | number
    date?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    productId?: IntWithAggregatesFilter<"Inventory"> | number
    depoId?: IntNullableWithAggregatesFilter<"Inventory"> | number | null
    employeeId?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    transactionId?: IntNullableWithAggregatesFilter<"Inventory"> | number | null
    fixedJournalId?: IntNullableWithAggregatesFilter<"Inventory"> | number | null
    unitPrice?: FloatWithAggregatesFilter<"Inventory"> | number
    quantityAdd?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    quantityLess?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    debitAmount?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    creditAmount?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    isClosing?: BoolWithAggregatesFilter<"Inventory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    isFixted?: BoolWithAggregatesFilter<"Inventory"> | boolean
  }

  export type TransactionInfoWhereInput = {
    AND?: TransactionInfoWhereInput | TransactionInfoWhereInput[]
    OR?: TransactionInfoWhereInput[]
    NOT?: TransactionInfoWhereInput | TransactionInfoWhereInput[]
    id?: IntFilter<"TransactionInfo"> | number
    date?: DateTimeFilter<"TransactionInfo"> | Date | string
    voucherNo?: StringFilter<"TransactionInfo"> | string
    invoiceNo?: StringNullableFilter<"TransactionInfo"> | string | null
    chemistId?: StringNullableFilter<"TransactionInfo"> | string | null
    customerId?: IntNullableFilter<"TransactionInfo"> | number | null
    stakeholderId?: StringNullableFilter<"TransactionInfo"> | string | null
    employeeId?: StringNullableFilter<"TransactionInfo"> | string | null
    partyId?: IntNullableFilter<"TransactionInfo"> | number | null
    voucherType?: EnumVoucherTypeFilter<"TransactionInfo"> | $Enums.VoucherType
    paymentType?: EnumPaymentTypeNullableFilter<"TransactionInfo"> | $Enums.PaymentType | null
    status?: EnumStatusFilter<"TransactionInfo"> | $Enums.Status
    createdAt?: DateTimeFilter<"TransactionInfo"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionInfo"> | Date | string
    inventory?: InventoryListRelationFilter
    journal?: JournalListRelationFilter
    chemist?: XOR<ChemistNullableScalarRelationFilter, ChemistWhereInput> | null
    customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    party?: XOR<PartyNullableScalarRelationFilter, PartyWhereInput> | null
    stakeholder?: XOR<StakeholderNullableScalarRelationFilter, StakeholderWhereInput> | null
  }

  export type TransactionInfoOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    chemistId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    stakeholderId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    partyId?: SortOrderInput | SortOrder
    voucherType?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventory?: InventoryOrderByRelationAggregateInput
    journal?: JournalOrderByRelationAggregateInput
    chemist?: ChemistOrderByWithRelationInput
    customers?: CustomersOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    party?: PartyOrderByWithRelationInput
    stakeholder?: StakeholderOrderByWithRelationInput
    _relevance?: TransactionInfoOrderByRelevanceInput
  }

  export type TransactionInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    voucherNo?: string
    AND?: TransactionInfoWhereInput | TransactionInfoWhereInput[]
    OR?: TransactionInfoWhereInput[]
    NOT?: TransactionInfoWhereInput | TransactionInfoWhereInput[]
    date?: DateTimeFilter<"TransactionInfo"> | Date | string
    invoiceNo?: StringNullableFilter<"TransactionInfo"> | string | null
    chemistId?: StringNullableFilter<"TransactionInfo"> | string | null
    customerId?: IntNullableFilter<"TransactionInfo"> | number | null
    stakeholderId?: StringNullableFilter<"TransactionInfo"> | string | null
    employeeId?: StringNullableFilter<"TransactionInfo"> | string | null
    partyId?: IntNullableFilter<"TransactionInfo"> | number | null
    voucherType?: EnumVoucherTypeFilter<"TransactionInfo"> | $Enums.VoucherType
    paymentType?: EnumPaymentTypeNullableFilter<"TransactionInfo"> | $Enums.PaymentType | null
    status?: EnumStatusFilter<"TransactionInfo"> | $Enums.Status
    createdAt?: DateTimeFilter<"TransactionInfo"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionInfo"> | Date | string
    inventory?: InventoryListRelationFilter
    journal?: JournalListRelationFilter
    chemist?: XOR<ChemistNullableScalarRelationFilter, ChemistWhereInput> | null
    customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    party?: XOR<PartyNullableScalarRelationFilter, PartyWhereInput> | null
    stakeholder?: XOR<StakeholderNullableScalarRelationFilter, StakeholderWhereInput> | null
  }, "id" | "voucherNo">

  export type TransactionInfoOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    chemistId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    stakeholderId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    partyId?: SortOrderInput | SortOrder
    voucherType?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionInfoCountOrderByAggregateInput
    _avg?: TransactionInfoAvgOrderByAggregateInput
    _max?: TransactionInfoMaxOrderByAggregateInput
    _min?: TransactionInfoMinOrderByAggregateInput
    _sum?: TransactionInfoSumOrderByAggregateInput
  }

  export type TransactionInfoScalarWhereWithAggregatesInput = {
    AND?: TransactionInfoScalarWhereWithAggregatesInput | TransactionInfoScalarWhereWithAggregatesInput[]
    OR?: TransactionInfoScalarWhereWithAggregatesInput[]
    NOT?: TransactionInfoScalarWhereWithAggregatesInput | TransactionInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransactionInfo"> | number
    date?: DateTimeWithAggregatesFilter<"TransactionInfo"> | Date | string
    voucherNo?: StringWithAggregatesFilter<"TransactionInfo"> | string
    invoiceNo?: StringNullableWithAggregatesFilter<"TransactionInfo"> | string | null
    chemistId?: StringNullableWithAggregatesFilter<"TransactionInfo"> | string | null
    customerId?: IntNullableWithAggregatesFilter<"TransactionInfo"> | number | null
    stakeholderId?: StringNullableWithAggregatesFilter<"TransactionInfo"> | string | null
    employeeId?: StringNullableWithAggregatesFilter<"TransactionInfo"> | string | null
    partyId?: IntNullableWithAggregatesFilter<"TransactionInfo"> | number | null
    voucherType?: EnumVoucherTypeWithAggregatesFilter<"TransactionInfo"> | $Enums.VoucherType
    paymentType?: EnumPaymentTypeNullableWithAggregatesFilter<"TransactionInfo"> | $Enums.PaymentType | null
    status?: EnumStatusWithAggregatesFilter<"TransactionInfo"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"TransactionInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionInfo"> | Date | string
  }

  export type JournalWhereInput = {
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    id?: IntFilter<"Journal"> | number
    transactionId?: IntNullableFilter<"Journal"> | number | null
    ledgerHeadId?: IntNullableFilter<"Journal"> | number | null
    date?: DateTimeFilter<"Journal"> | Date | string
    depoId?: IntNullableFilter<"Journal"> | number | null
    creditAmount?: FloatNullableFilter<"Journal"> | number | null
    debitAmount?: FloatNullableFilter<"Journal"> | number | null
    narration?: StringNullableFilter<"Journal"> | string | null
    isClosing?: BoolFilter<"Journal"> | boolean
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    updatedAt?: DateTimeFilter<"Journal"> | Date | string
    depo?: XOR<DepoNullableScalarRelationFilter, DepoWhereInput> | null
    ledgerHead?: XOR<LedgerHeadNullableScalarRelationFilter, LedgerHeadWhereInput> | null
    transactionInfo?: XOR<TransactionInfoNullableScalarRelationFilter, TransactionInfoWhereInput> | null
    bankTransaction?: BankTransactionListRelationFilter
  }

  export type JournalOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    ledgerHeadId?: SortOrderInput | SortOrder
    date?: SortOrder
    depoId?: SortOrderInput | SortOrder
    creditAmount?: SortOrderInput | SortOrder
    debitAmount?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    depo?: DepoOrderByWithRelationInput
    ledgerHead?: LedgerHeadOrderByWithRelationInput
    transactionInfo?: TransactionInfoOrderByWithRelationInput
    bankTransaction?: BankTransactionOrderByRelationAggregateInput
    _relevance?: JournalOrderByRelevanceInput
  }

  export type JournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    transactionId?: IntNullableFilter<"Journal"> | number | null
    ledgerHeadId?: IntNullableFilter<"Journal"> | number | null
    date?: DateTimeFilter<"Journal"> | Date | string
    depoId?: IntNullableFilter<"Journal"> | number | null
    creditAmount?: FloatNullableFilter<"Journal"> | number | null
    debitAmount?: FloatNullableFilter<"Journal"> | number | null
    narration?: StringNullableFilter<"Journal"> | string | null
    isClosing?: BoolFilter<"Journal"> | boolean
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    updatedAt?: DateTimeFilter<"Journal"> | Date | string
    depo?: XOR<DepoNullableScalarRelationFilter, DepoWhereInput> | null
    ledgerHead?: XOR<LedgerHeadNullableScalarRelationFilter, LedgerHeadWhereInput> | null
    transactionInfo?: XOR<TransactionInfoNullableScalarRelationFilter, TransactionInfoWhereInput> | null
    bankTransaction?: BankTransactionListRelationFilter
  }, "id">

  export type JournalOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    ledgerHeadId?: SortOrderInput | SortOrder
    date?: SortOrder
    depoId?: SortOrderInput | SortOrder
    creditAmount?: SortOrderInput | SortOrder
    debitAmount?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalCountOrderByAggregateInput
    _avg?: JournalAvgOrderByAggregateInput
    _max?: JournalMaxOrderByAggregateInput
    _min?: JournalMinOrderByAggregateInput
    _sum?: JournalSumOrderByAggregateInput
  }

  export type JournalScalarWhereWithAggregatesInput = {
    AND?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    OR?: JournalScalarWhereWithAggregatesInput[]
    NOT?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Journal"> | number
    transactionId?: IntNullableWithAggregatesFilter<"Journal"> | number | null
    ledgerHeadId?: IntNullableWithAggregatesFilter<"Journal"> | number | null
    date?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
    depoId?: IntNullableWithAggregatesFilter<"Journal"> | number | null
    creditAmount?: FloatNullableWithAggregatesFilter<"Journal"> | number | null
    debitAmount?: FloatNullableWithAggregatesFilter<"Journal"> | number | null
    narration?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    isClosing?: BoolWithAggregatesFilter<"Journal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
  }

  export type FixedJournalWhereInput = {
    AND?: FixedJournalWhereInput | FixedJournalWhereInput[]
    OR?: FixedJournalWhereInput[]
    NOT?: FixedJournalWhereInput | FixedJournalWhereInput[]
    id?: IntFilter<"FixedJournal"> | number
    date?: DateTimeFilter<"FixedJournal"> | Date | string
    voucherNo?: StringFilter<"FixedJournal"> | string
    chemistId?: StringFilter<"FixedJournal"> | string
    ledgerHeadId?: IntFilter<"FixedJournal"> | number
    depoId?: IntFilter<"FixedJournal"> | number
    creditAmount?: FloatNullableFilter<"FixedJournal"> | number | null
    debitAmount?: FloatNullableFilter<"FixedJournal"> | number | null
    narration?: StringNullableFilter<"FixedJournal"> | string | null
    isClosing?: BoolFilter<"FixedJournal"> | boolean
    createdAt?: DateTimeFilter<"FixedJournal"> | Date | string
    updatedAt?: DateTimeFilter<"FixedJournal"> | Date | string
    chemist?: XOR<ChemistScalarRelationFilter, ChemistWhereInput>
    depo?: XOR<DepoScalarRelationFilter, DepoWhereInput>
    ledgerHead?: XOR<LedgerHeadScalarRelationFilter, LedgerHeadWhereInput>
    inventory?: InventoryListRelationFilter
  }

  export type FixedJournalOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    chemistId?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrderInput | SortOrder
    debitAmount?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chemist?: ChemistOrderByWithRelationInput
    depo?: DepoOrderByWithRelationInput
    ledgerHead?: LedgerHeadOrderByWithRelationInput
    inventory?: InventoryOrderByRelationAggregateInput
    _relevance?: FixedJournalOrderByRelevanceInput
  }

  export type FixedJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FixedJournalWhereInput | FixedJournalWhereInput[]
    OR?: FixedJournalWhereInput[]
    NOT?: FixedJournalWhereInput | FixedJournalWhereInput[]
    date?: DateTimeFilter<"FixedJournal"> | Date | string
    voucherNo?: StringFilter<"FixedJournal"> | string
    chemistId?: StringFilter<"FixedJournal"> | string
    ledgerHeadId?: IntFilter<"FixedJournal"> | number
    depoId?: IntFilter<"FixedJournal"> | number
    creditAmount?: FloatNullableFilter<"FixedJournal"> | number | null
    debitAmount?: FloatNullableFilter<"FixedJournal"> | number | null
    narration?: StringNullableFilter<"FixedJournal"> | string | null
    isClosing?: BoolFilter<"FixedJournal"> | boolean
    createdAt?: DateTimeFilter<"FixedJournal"> | Date | string
    updatedAt?: DateTimeFilter<"FixedJournal"> | Date | string
    chemist?: XOR<ChemistScalarRelationFilter, ChemistWhereInput>
    depo?: XOR<DepoScalarRelationFilter, DepoWhereInput>
    ledgerHead?: XOR<LedgerHeadScalarRelationFilter, LedgerHeadWhereInput>
    inventory?: InventoryListRelationFilter
  }, "id">

  export type FixedJournalOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    chemistId?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrderInput | SortOrder
    debitAmount?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FixedJournalCountOrderByAggregateInput
    _avg?: FixedJournalAvgOrderByAggregateInput
    _max?: FixedJournalMaxOrderByAggregateInput
    _min?: FixedJournalMinOrderByAggregateInput
    _sum?: FixedJournalSumOrderByAggregateInput
  }

  export type FixedJournalScalarWhereWithAggregatesInput = {
    AND?: FixedJournalScalarWhereWithAggregatesInput | FixedJournalScalarWhereWithAggregatesInput[]
    OR?: FixedJournalScalarWhereWithAggregatesInput[]
    NOT?: FixedJournalScalarWhereWithAggregatesInput | FixedJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FixedJournal"> | number
    date?: DateTimeWithAggregatesFilter<"FixedJournal"> | Date | string
    voucherNo?: StringWithAggregatesFilter<"FixedJournal"> | string
    chemistId?: StringWithAggregatesFilter<"FixedJournal"> | string
    ledgerHeadId?: IntWithAggregatesFilter<"FixedJournal"> | number
    depoId?: IntWithAggregatesFilter<"FixedJournal"> | number
    creditAmount?: FloatNullableWithAggregatesFilter<"FixedJournal"> | number | null
    debitAmount?: FloatNullableWithAggregatesFilter<"FixedJournal"> | number | null
    narration?: StringNullableWithAggregatesFilter<"FixedJournal"> | string | null
    isClosing?: BoolWithAggregatesFilter<"FixedJournal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FixedJournal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FixedJournal"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    employeeId?: StringFilter<"Order"> | string
    chemistId?: StringFilter<"Order"> | string
    orderNo?: StringFilter<"Order"> | string
    date?: DateTimeFilter<"Order"> | Date | string
    discount?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderItem?: OrderItemListRelationFilter
    orderStatus?: OrderStatusListRelationFilter
    chemist?: XOR<ChemistScalarRelationFilter, ChemistWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    chemistId?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    discount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItem?: OrderItemOrderByRelationAggregateInput
    orderStatus?: OrderStatusOrderByRelationAggregateInput
    chemist?: ChemistOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: OrderOrderByRelevanceInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNo?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    employeeId?: StringFilter<"Order"> | string
    chemistId?: StringFilter<"Order"> | string
    date?: DateTimeFilter<"Order"> | Date | string
    discount?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderItem?: OrderItemListRelationFilter
    orderStatus?: OrderStatusListRelationFilter
    chemist?: XOR<ChemistScalarRelationFilter, ChemistWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orderNo">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    chemistId?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    discount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    employeeId?: StringWithAggregatesFilter<"Order"> | string
    chemistId?: StringWithAggregatesFilter<"Order"> | string
    orderNo?: StringWithAggregatesFilter<"Order"> | string
    date?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    discount?: IntNullableWithAggregatesFilter<"Order"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quintity?: IntFilter<"OrderItem"> | number
    tpRate?: IntFilter<"OrderItem"> | number
    amount?: IntFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quintity?: SortOrder
    tpRate?: SortOrder
    amount?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quintity?: IntFilter<"OrderItem"> | number
    tpRate?: IntFilter<"OrderItem"> | number
    amount?: IntFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quintity?: SortOrder
    tpRate?: SortOrder
    amount?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
    quintity?: IntWithAggregatesFilter<"OrderItem"> | number
    tpRate?: IntWithAggregatesFilter<"OrderItem"> | number
    amount?: IntWithAggregatesFilter<"OrderItem"> | number
  }

  export type OrderStatusWhereInput = {
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    id?: IntFilter<"OrderStatus"> | number
    orderNo?: StringNullableFilter<"OrderStatus"> | string | null
    status?: EnumOrdStatusFilter<"OrderStatus"> | $Enums.OrdStatus
    comments?: StringNullableFilter<"OrderStatus"> | string | null
    dateTime?: DateTimeFilter<"OrderStatus"> | Date | string
    createdAt?: DateTimeFilter<"OrderStatus"> | Date | string
    updatedAt?: DateTimeFilter<"OrderStatus"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type OrderStatusOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrderInput | SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    _relevance?: OrderStatusOrderByRelevanceInput
  }

  export type OrderStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    orderNo?: StringNullableFilter<"OrderStatus"> | string | null
    status?: EnumOrdStatusFilter<"OrderStatus"> | $Enums.OrdStatus
    comments?: StringNullableFilter<"OrderStatus"> | string | null
    dateTime?: DateTimeFilter<"OrderStatus"> | Date | string
    createdAt?: DateTimeFilter<"OrderStatus"> | Date | string
    updatedAt?: DateTimeFilter<"OrderStatus"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type OrderStatusOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrderInput | SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderStatusCountOrderByAggregateInput
    _avg?: OrderStatusAvgOrderByAggregateInput
    _max?: OrderStatusMaxOrderByAggregateInput
    _min?: OrderStatusMinOrderByAggregateInput
    _sum?: OrderStatusSumOrderByAggregateInput
  }

  export type OrderStatusScalarWhereWithAggregatesInput = {
    AND?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    OR?: OrderStatusScalarWhereWithAggregatesInput[]
    NOT?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderStatus"> | number
    orderNo?: StringNullableWithAggregatesFilter<"OrderStatus"> | string | null
    status?: EnumOrdStatusWithAggregatesFilter<"OrderStatus"> | $Enums.OrdStatus
    comments?: StringNullableWithAggregatesFilter<"OrderStatus"> | string | null
    dateTime?: DateTimeWithAggregatesFilter<"OrderStatus"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderStatus"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: IntFilter<"Attendance"> | number
    employeeId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    time?: StringFilter<"Attendance"> | string
    status?: StringFilter<"Attendance"> | string
    comments?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AttendanceOrderByRelevanceInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    employeeId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    time?: StringFilter<"Attendance"> | string
    status?: StringFilter<"Attendance"> | string
    comments?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attendance"> | number
    employeeId?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    time?: StringWithAggregatesFilter<"Attendance"> | string
    status?: StringWithAggregatesFilter<"Attendance"> | string
    comments?: StringWithAggregatesFilter<"Attendance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type OvertimeWhereInput = {
    AND?: OvertimeWhereInput | OvertimeWhereInput[]
    OR?: OvertimeWhereInput[]
    NOT?: OvertimeWhereInput | OvertimeWhereInput[]
    id?: IntFilter<"Overtime"> | number
    employeeId?: StringFilter<"Overtime"> | string
    overtimeDate?: DateTimeFilter<"Overtime"> | Date | string
    overtimeHours?: StringFilter<"Overtime"> | string
    others?: StringFilter<"Overtime"> | string
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OvertimeOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    overtimeDate?: SortOrder
    overtimeHours?: SortOrder
    others?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: OvertimeOrderByRelevanceInput
  }

  export type OvertimeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OvertimeWhereInput | OvertimeWhereInput[]
    OR?: OvertimeWhereInput[]
    NOT?: OvertimeWhereInput | OvertimeWhereInput[]
    employeeId?: StringFilter<"Overtime"> | string
    overtimeDate?: DateTimeFilter<"Overtime"> | Date | string
    overtimeHours?: StringFilter<"Overtime"> | string
    others?: StringFilter<"Overtime"> | string
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OvertimeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    overtimeDate?: SortOrder
    overtimeHours?: SortOrder
    others?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OvertimeCountOrderByAggregateInput
    _avg?: OvertimeAvgOrderByAggregateInput
    _max?: OvertimeMaxOrderByAggregateInput
    _min?: OvertimeMinOrderByAggregateInput
    _sum?: OvertimeSumOrderByAggregateInput
  }

  export type OvertimeScalarWhereWithAggregatesInput = {
    AND?: OvertimeScalarWhereWithAggregatesInput | OvertimeScalarWhereWithAggregatesInput[]
    OR?: OvertimeScalarWhereWithAggregatesInput[]
    NOT?: OvertimeScalarWhereWithAggregatesInput | OvertimeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Overtime"> | number
    employeeId?: StringWithAggregatesFilter<"Overtime"> | string
    overtimeDate?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    overtimeHours?: StringWithAggregatesFilter<"Overtime"> | string
    others?: StringWithAggregatesFilter<"Overtime"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
  }

  export type LeaveTypeWhereInput = {
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    id?: IntFilter<"LeaveType"> | number
    leaveName?: StringFilter<"LeaveType"> | string
    leves?: LevesListRelationFilter
  }

  export type LeaveTypeOrderByWithRelationInput = {
    id?: SortOrder
    leaveName?: SortOrder
    leves?: LevesOrderByRelationAggregateInput
    _relevance?: LeaveTypeOrderByRelevanceInput
  }

  export type LeaveTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    leaveName?: StringFilter<"LeaveType"> | string
    leves?: LevesListRelationFilter
  }, "id">

  export type LeaveTypeOrderByWithAggregationInput = {
    id?: SortOrder
    leaveName?: SortOrder
    _count?: LeaveTypeCountOrderByAggregateInput
    _avg?: LeaveTypeAvgOrderByAggregateInput
    _max?: LeaveTypeMaxOrderByAggregateInput
    _min?: LeaveTypeMinOrderByAggregateInput
    _sum?: LeaveTypeSumOrderByAggregateInput
  }

  export type LeaveTypeScalarWhereWithAggregatesInput = {
    AND?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    OR?: LeaveTypeScalarWhereWithAggregatesInput[]
    NOT?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaveType"> | number
    leaveName?: StringWithAggregatesFilter<"LeaveType"> | string
  }

  export type LevesWhereInput = {
    AND?: LevesWhereInput | LevesWhereInput[]
    OR?: LevesWhereInput[]
    NOT?: LevesWhereInput | LevesWhereInput[]
    id?: IntFilter<"Leves"> | number
    leaveTypeId?: IntFilter<"Leves"> | number
    employeeId?: StringFilter<"Leves"> | string
    startDate?: DateTimeFilter<"Leves"> | Date | string
    endDate?: DateTimeFilter<"Leves"> | Date | string
    leaveReason?: StringFilter<"Leves"> | string
    createdAt?: DateTimeFilter<"Leves"> | Date | string
    updatedAt?: DateTimeFilter<"Leves"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
  }

  export type LevesOrderByWithRelationInput = {
    id?: SortOrder
    leaveTypeId?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    leaveType?: LeaveTypeOrderByWithRelationInput
    _relevance?: LevesOrderByRelevanceInput
  }

  export type LevesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LevesWhereInput | LevesWhereInput[]
    OR?: LevesWhereInput[]
    NOT?: LevesWhereInput | LevesWhereInput[]
    leaveTypeId?: IntFilter<"Leves"> | number
    employeeId?: StringFilter<"Leves"> | string
    startDate?: DateTimeFilter<"Leves"> | Date | string
    endDate?: DateTimeFilter<"Leves"> | Date | string
    leaveReason?: StringFilter<"Leves"> | string
    createdAt?: DateTimeFilter<"Leves"> | Date | string
    updatedAt?: DateTimeFilter<"Leves"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
  }, "id">

  export type LevesOrderByWithAggregationInput = {
    id?: SortOrder
    leaveTypeId?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LevesCountOrderByAggregateInput
    _avg?: LevesAvgOrderByAggregateInput
    _max?: LevesMaxOrderByAggregateInput
    _min?: LevesMinOrderByAggregateInput
    _sum?: LevesSumOrderByAggregateInput
  }

  export type LevesScalarWhereWithAggregatesInput = {
    AND?: LevesScalarWhereWithAggregatesInput | LevesScalarWhereWithAggregatesInput[]
    OR?: LevesScalarWhereWithAggregatesInput[]
    NOT?: LevesScalarWhereWithAggregatesInput | LevesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leves"> | number
    leaveTypeId?: IntWithAggregatesFilter<"Leves"> | number
    employeeId?: StringWithAggregatesFilter<"Leves"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leves"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leves"> | Date | string
    leaveReason?: StringWithAggregatesFilter<"Leves"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Leves"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leves"> | Date | string
  }

  export type EmployeeBankDetailsWhereInput = {
    AND?: EmployeeBankDetailsWhereInput | EmployeeBankDetailsWhereInput[]
    OR?: EmployeeBankDetailsWhereInput[]
    NOT?: EmployeeBankDetailsWhereInput | EmployeeBankDetailsWhereInput[]
    id?: IntFilter<"EmployeeBankDetails"> | number
    bankName?: StringFilter<"EmployeeBankDetails"> | string
    bankAccountNumber?: StringFilter<"EmployeeBankDetails"> | string
    branchName?: StringFilter<"EmployeeBankDetails"> | string
    ifsscode?: StringFilter<"EmployeeBankDetails"> | string
  }

  export type EmployeeBankDetailsOrderByWithRelationInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    branchName?: SortOrder
    ifsscode?: SortOrder
    _relevance?: EmployeeBankDetailsOrderByRelevanceInput
  }

  export type EmployeeBankDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeBankDetailsWhereInput | EmployeeBankDetailsWhereInput[]
    OR?: EmployeeBankDetailsWhereInput[]
    NOT?: EmployeeBankDetailsWhereInput | EmployeeBankDetailsWhereInput[]
    bankName?: StringFilter<"EmployeeBankDetails"> | string
    bankAccountNumber?: StringFilter<"EmployeeBankDetails"> | string
    branchName?: StringFilter<"EmployeeBankDetails"> | string
    ifsscode?: StringFilter<"EmployeeBankDetails"> | string
  }, "id">

  export type EmployeeBankDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    branchName?: SortOrder
    ifsscode?: SortOrder
    _count?: EmployeeBankDetailsCountOrderByAggregateInput
    _avg?: EmployeeBankDetailsAvgOrderByAggregateInput
    _max?: EmployeeBankDetailsMaxOrderByAggregateInput
    _min?: EmployeeBankDetailsMinOrderByAggregateInput
    _sum?: EmployeeBankDetailsSumOrderByAggregateInput
  }

  export type EmployeeBankDetailsScalarWhereWithAggregatesInput = {
    AND?: EmployeeBankDetailsScalarWhereWithAggregatesInput | EmployeeBankDetailsScalarWhereWithAggregatesInput[]
    OR?: EmployeeBankDetailsScalarWhereWithAggregatesInput[]
    NOT?: EmployeeBankDetailsScalarWhereWithAggregatesInput | EmployeeBankDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeBankDetails"> | number
    bankName?: StringWithAggregatesFilter<"EmployeeBankDetails"> | string
    bankAccountNumber?: StringWithAggregatesFilter<"EmployeeBankDetails"> | string
    branchName?: StringWithAggregatesFilter<"EmployeeBankDetails"> | string
    ifsscode?: StringWithAggregatesFilter<"EmployeeBankDetails"> | string
  }

  export type SalaryInfoWhereInput = {
    AND?: SalaryInfoWhereInput | SalaryInfoWhereInput[]
    OR?: SalaryInfoWhereInput[]
    NOT?: SalaryInfoWhereInput | SalaryInfoWhereInput[]
    id?: IntFilter<"SalaryInfo"> | number
    employeeId?: StringFilter<"SalaryInfo"> | string
    basicSalary?: FloatFilter<"SalaryInfo"> | number
    houseRend?: FloatFilter<"SalaryInfo"> | number
    mobile?: FloatFilter<"SalaryInfo"> | number
    medial?: FloatFilter<"SalaryInfo"> | number
    taDa?: FloatFilter<"SalaryInfo"> | number
    insuranceAmount?: FloatFilter<"SalaryInfo"> | number
    createdAt?: DateTimeFilter<"SalaryInfo"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryInfo"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SalaryInfoOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SalaryInfoOrderByRelevanceInput
  }

  export type SalaryInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryInfoWhereInput | SalaryInfoWhereInput[]
    OR?: SalaryInfoWhereInput[]
    NOT?: SalaryInfoWhereInput | SalaryInfoWhereInput[]
    employeeId?: StringFilter<"SalaryInfo"> | string
    basicSalary?: FloatFilter<"SalaryInfo"> | number
    houseRend?: FloatFilter<"SalaryInfo"> | number
    mobile?: FloatFilter<"SalaryInfo"> | number
    medial?: FloatFilter<"SalaryInfo"> | number
    taDa?: FloatFilter<"SalaryInfo"> | number
    insuranceAmount?: FloatFilter<"SalaryInfo"> | number
    createdAt?: DateTimeFilter<"SalaryInfo"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryInfo"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SalaryInfoOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalaryInfoCountOrderByAggregateInput
    _avg?: SalaryInfoAvgOrderByAggregateInput
    _max?: SalaryInfoMaxOrderByAggregateInput
    _min?: SalaryInfoMinOrderByAggregateInput
    _sum?: SalaryInfoSumOrderByAggregateInput
  }

  export type SalaryInfoScalarWhereWithAggregatesInput = {
    AND?: SalaryInfoScalarWhereWithAggregatesInput | SalaryInfoScalarWhereWithAggregatesInput[]
    OR?: SalaryInfoScalarWhereWithAggregatesInput[]
    NOT?: SalaryInfoScalarWhereWithAggregatesInput | SalaryInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryInfo"> | number
    employeeId?: StringWithAggregatesFilter<"SalaryInfo"> | string
    basicSalary?: FloatWithAggregatesFilter<"SalaryInfo"> | number
    houseRend?: FloatWithAggregatesFilter<"SalaryInfo"> | number
    mobile?: FloatWithAggregatesFilter<"SalaryInfo"> | number
    medial?: FloatWithAggregatesFilter<"SalaryInfo"> | number
    taDa?: FloatWithAggregatesFilter<"SalaryInfo"> | number
    insuranceAmount?: FloatWithAggregatesFilter<"SalaryInfo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SalaryInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryInfo"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: IntFilter<"Payroll"> | number
    employeeId?: StringFilter<"Payroll"> | string
    payDate?: DateTimeFilter<"Payroll"> | Date | string
    basicSalary?: FloatFilter<"Payroll"> | number
    houseRend?: FloatFilter<"Payroll"> | number
    mobile?: FloatFilter<"Payroll"> | number
    medial?: FloatFilter<"Payroll"> | number
    taDa?: FloatFilter<"Payroll"> | number
    insentive?: FloatFilter<"Payroll"> | number
    eidBonus?: FloatFilter<"Payroll"> | number
    boishakhi?: FloatFilter<"Payroll"> | number
    others?: FloatFilter<"Payroll"> | number
    fp?: FloatFilter<"Payroll"> | number
    insurance?: FloatFilter<"Payroll"> | number
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    payDate?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insentive?: SortOrder
    eidBonus?: SortOrder
    boishakhi?: SortOrder
    others?: SortOrder
    fp?: SortOrder
    insurance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: PayrollOrderByRelevanceInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    employeeId?: StringFilter<"Payroll"> | string
    payDate?: DateTimeFilter<"Payroll"> | Date | string
    basicSalary?: FloatFilter<"Payroll"> | number
    houseRend?: FloatFilter<"Payroll"> | number
    mobile?: FloatFilter<"Payroll"> | number
    medial?: FloatFilter<"Payroll"> | number
    taDa?: FloatFilter<"Payroll"> | number
    insentive?: FloatFilter<"Payroll"> | number
    eidBonus?: FloatFilter<"Payroll"> | number
    boishakhi?: FloatFilter<"Payroll"> | number
    others?: FloatFilter<"Payroll"> | number
    fp?: FloatFilter<"Payroll"> | number
    insurance?: FloatFilter<"Payroll"> | number
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    payDate?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insentive?: SortOrder
    eidBonus?: SortOrder
    boishakhi?: SortOrder
    others?: SortOrder
    fp?: SortOrder
    insurance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payroll"> | number
    employeeId?: StringWithAggregatesFilter<"Payroll"> | string
    payDate?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    basicSalary?: FloatWithAggregatesFilter<"Payroll"> | number
    houseRend?: FloatWithAggregatesFilter<"Payroll"> | number
    mobile?: FloatWithAggregatesFilter<"Payroll"> | number
    medial?: FloatWithAggregatesFilter<"Payroll"> | number
    taDa?: FloatWithAggregatesFilter<"Payroll"> | number
    insentive?: FloatWithAggregatesFilter<"Payroll"> | number
    eidBonus?: FloatWithAggregatesFilter<"Payroll"> | number
    boishakhi?: FloatWithAggregatesFilter<"Payroll"> | number
    others?: FloatWithAggregatesFilter<"Payroll"> | number
    fp?: FloatWithAggregatesFilter<"Payroll"> | number
    insurance?: FloatWithAggregatesFilter<"Payroll"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type UserCreateInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateInput = {
    fatherName: string
    motherName: string
    officeContactNo?: string | null
    currentAddress?: string | null
    permanentAddress?: string | null
    nid?: string | null
    dob: Date | string
    contactNo: string
    emergencyContactNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeProfileInput
  }

  export type EmployeeProfileUncheckedCreateInput = {
    id?: number
    employeeId: string
    fatherName: string
    motherName: string
    officeContactNo?: string | null
    currentAddress?: string | null
    permanentAddress?: string | null
    nid?: string | null
    dob: Date | string
    contactNo: string
    emergencyContactNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileUpdateInput = {
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    officeContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNo?: StringFieldUpdateOperationsInput | string
    emergencyContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeProfileNestedInput
  }

  export type EmployeeProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    officeContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNo?: StringFieldUpdateOperationsInput | string
    emergencyContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateManyInput = {
    id?: number
    employeeId: string
    fatherName: string
    motherName: string
    officeContactNo?: string | null
    currentAddress?: string | null
    permanentAddress?: string | null
    nid?: string | null
    dob: Date | string
    contactNo: string
    emergencyContactNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileUpdateManyMutationInput = {
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    officeContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNo?: StringFieldUpdateOperationsInput | string
    emergencyContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    officeContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNo?: StringFieldUpdateOperationsInput | string
    emergencyContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostCreateInput = {
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutJobPostInput
    scope?: ScopeCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateInput = {
    id?: number
    depoId: number
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: ScopeUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUpdateInput = {
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutJobPostNestedInput
    scope?: ScopeUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: ScopeUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostCreateManyInput = {
    id?: number
    depoId: number
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobPostUpdateManyMutationInput = {
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemistCreateInput = {
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutChemistInput
    scopes?: ScopeCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutChemistInput
    order?: OrderCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutChemistInput
  }

  export type ChemistUncheckedCreateInput = {
    id?: number
    chemistId: string
    depoId: number
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ScopeUncheckedCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutChemistInput
    order?: OrderUncheckedCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutChemistInput
  }

  export type ChemistUpdateInput = {
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutChemistNestedInput
    scopes?: ScopeUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutChemistNestedInput
    order?: OrderUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ScopeUncheckedUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutChemistNestedInput
    order?: OrderUncheckedUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutChemistNestedInput
  }

  export type ChemistCreateManyInput = {
    id?: number
    chemistId: string
    depoId: number
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChemistUpdateManyMutationInput = {
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepoCreateInput = {
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutDepoInput
    inventory?: InventoryCreateNestedManyWithoutDepoInput
    jobPost?: JobPostCreateNestedManyWithoutDepoInput
    journal?: JournalCreateNestedManyWithoutDepoInput
    scopes?: ScopeCreateNestedManyWithoutDepoInput
  }

  export type DepoUncheckedCreateInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutDepoInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutDepoInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutDepoInput
    journal?: JournalUncheckedCreateNestedManyWithoutDepoInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutDepoInput
  }

  export type DepoUpdateInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUpdateManyWithoutDepoNestedInput
    journal?: JournalUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutDepoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutDepoNestedInput
  }

  export type DepoCreateManyInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepoUpdateManyMutationInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartyCreateInput = {
    partyName: string
    contactNo: string
    address: string
    partytype: $Enums.PartyType
    openingAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionInfo?: TransactionInfoCreateNestedManyWithoutPartyInput
  }

  export type PartyUncheckedCreateInput = {
    id?: number
    partyName: string
    contactNo: string
    address: string
    partytype: $Enums.PartyType
    openingAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutPartyInput
  }

  export type PartyUpdateInput = {
    partyName?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    partytype?: EnumPartyTypeFieldUpdateOperationsInput | $Enums.PartyType
    openingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionInfo?: TransactionInfoUpdateManyWithoutPartyNestedInput
  }

  export type PartyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partyName?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    partytype?: EnumPartyTypeFieldUpdateOperationsInput | $Enums.PartyType
    openingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutPartyNestedInput
  }

  export type PartyCreateManyInput = {
    id?: number
    partyName: string
    contactNo: string
    address: string
    partytype: $Enums.PartyType
    openingAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartyUpdateManyMutationInput = {
    partyName?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    partytype?: EnumPartyTypeFieldUpdateOperationsInput | $Enums.PartyType
    openingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partyName?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    partytype?: EnumPartyTypeFieldUpdateOperationsInput | $Enums.PartyType
    openingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderCreateInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutStakeholderInput
    stakeholderDegree: StakeholderDegreeCreateNestedOneWithoutStakeholderInput
    stakeholderDeisgnation: StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput
    scopes?: ScopeCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutStakeholderInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUpdateInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutStakeholderNestedInput
    stakeholderDegree?: StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput
    stakeholderDeisgnation?: StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput
    scopes?: ScopeUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutStakeholderNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderCreateManyInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderUpdateManyMutationInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderDeisgnationCreateInput = {
    designation: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakeholder?: StakeholderCreateNestedManyWithoutStakeholderDeisgnationInput
  }

  export type StakeholderDeisgnationUncheckedCreateInput = {
    id?: number
    designation: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakeholder?: StakeholderUncheckedCreateNestedManyWithoutStakeholderDeisgnationInput
  }

  export type StakeholderDeisgnationUpdateInput = {
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakeholder?: StakeholderUpdateManyWithoutStakeholderDeisgnationNestedInput
  }

  export type StakeholderDeisgnationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakeholder?: StakeholderUncheckedUpdateManyWithoutStakeholderDeisgnationNestedInput
  }

  export type StakeholderDeisgnationCreateManyInput = {
    id?: number
    designation: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderDeisgnationUpdateManyMutationInput = {
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderDeisgnationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderDegreeCreateInput = {
    degreeName: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakeholder?: StakeholderCreateNestedManyWithoutStakeholderDegreeInput
  }

  export type StakeholderDegreeUncheckedCreateInput = {
    id?: number
    degreeName: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stakeholder?: StakeholderUncheckedCreateNestedManyWithoutStakeholderDegreeInput
  }

  export type StakeholderDegreeUpdateInput = {
    degreeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakeholder?: StakeholderUpdateManyWithoutStakeholderDegreeNestedInput
  }

  export type StakeholderDegreeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    degreeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakeholder?: StakeholderUncheckedUpdateManyWithoutStakeholderDegreeNestedInput
  }

  export type StakeholderDegreeCreateManyInput = {
    id?: number
    degreeName: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderDegreeUpdateManyMutationInput = {
    degreeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderDegreeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    degreeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stakeholderChemberCreateInput = {
    address: string
    chemberDay: string
    chemberTime: string
    chemberName: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stakeholder?: StakeholderCreateNestedOneWithoutStakeholderChemberInput
  }

  export type stakeholderChemberUncheckedCreateInput = {
    id?: number
    stakeId?: string | null
    address: string
    chemberDay: string
    chemberTime: string
    chemberName: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type stakeholderChemberUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    chemberDay?: StringFieldUpdateOperationsInput | string
    chemberTime?: StringFieldUpdateOperationsInput | string
    chemberName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakeholder?: StakeholderUpdateOneWithoutStakeholderChemberNestedInput
  }

  export type stakeholderChemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stakeId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    chemberDay?: StringFieldUpdateOperationsInput | string
    chemberTime?: StringFieldUpdateOperationsInput | string
    chemberName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stakeholderChemberCreateManyInput = {
    id?: number
    stakeId?: string | null
    address: string
    chemberDay: string
    chemberTime: string
    chemberName: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type stakeholderChemberUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    chemberDay?: StringFieldUpdateOperationsInput | string
    chemberTime?: StringFieldUpdateOperationsInput | string
    chemberName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stakeholderChemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stakeId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    chemberDay?: StringFieldUpdateOperationsInput | string
    chemberTime?: StringFieldUpdateOperationsInput | string
    chemberName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderOcationCreateInput = {
    ocationName: string
    relation: string
    personName?: string | null
    dob?: Date | string | null
    otherInfo?: string | null
    stakeholder: StakeholderCreateNestedOneWithoutStakeholderOcationInput
  }

  export type StakeholderOcationUncheckedCreateInput = {
    id?: number
    stakeId: string
    ocationName: string
    relation: string
    personName?: string | null
    dob?: Date | string | null
    otherInfo?: string | null
  }

  export type StakeholderOcationUpdateInput = {
    ocationName?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholder?: StakeholderUpdateOneRequiredWithoutStakeholderOcationNestedInput
  }

  export type StakeholderOcationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stakeId?: StringFieldUpdateOperationsInput | string
    ocationName?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StakeholderOcationCreateManyInput = {
    id?: number
    stakeId: string
    ocationName: string
    relation: string
    personName?: string | null
    dob?: Date | string | null
    otherInfo?: string | null
  }

  export type StakeholderOcationUpdateManyMutationInput = {
    ocationName?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StakeholderOcationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stakeId?: StringFieldUpdateOperationsInput | string
    ocationName?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomersCreateInput = {
    name?: string | null
    contactNo: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionInfo?: TransactionInfoCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    name?: string | null
    contactNo: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionInfo?: TransactionInfoUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersCreateManyInput = {
    id?: number
    name?: string | null
    contactNo: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutScopesInput
    depo?: DepoCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderCreateNestedManyWithoutScopesInput
    user: UserCreateNestedOneWithoutScopeInput
    jobPost: JobPostCreateNestedOneWithoutScopeInput
  }

  export type ScopeUncheckedCreateInput = {
    id?: number
    employeeId: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutScopesInput
    depo?: DepoUncheckedCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderUncheckedCreateNestedManyWithoutScopesInput
  }

  export type ScopeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutScopesNestedInput
    depo?: DepoUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUpdateManyWithoutScopesNestedInput
    user?: UserUpdateOneRequiredWithoutScopeNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutScopeNestedInput
  }

  export type ScopeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutScopesNestedInput
    depo?: DepoUncheckedUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUncheckedUpdateManyWithoutScopesNestedInput
  }

  export type ScopeCreateManyInput = {
    id?: number
    employeeId: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScopeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpoTargetCreateInput = {
    month: string
    tergatAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMpoTargetInput
  }

  export type MpoTargetUncheckedCreateInput = {
    id?: number
    employeeId: string
    month: string
    tergatAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MpoTargetUpdateInput = {
    month?: StringFieldUpdateOperationsInput | string
    tergatAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMpoTargetNestedInput
  }

  export type MpoTargetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    tergatAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpoTargetCreateManyInput = {
    id?: number
    employeeId: string
    month: string
    tergatAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MpoTargetUpdateManyMutationInput = {
    month?: StringFieldUpdateOperationsInput | string
    tergatAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpoTargetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    tergatAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductWiseTargetCreateInput = {
    targetStart: Date | string
    targetEnd: Date | string
    targetType: $Enums.TargetType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductWiseTargetInput
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductWiseTargetInput
  }

  export type ProductWiseTargetUncheckedCreateInput = {
    id?: number
    employeeId: string
    targetStart: Date | string
    targetEnd: Date | string
    targetType: $Enums.TargetType
    createdAt?: Date | string
    updatedAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductWiseTargetInput
  }

  export type ProductWiseTargetUpdateInput = {
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductWiseTargetNestedInput
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductWiseTargetNestedInput
  }

  export type ProductWiseTargetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductWiseTargetNestedInput
  }

  export type ProductWiseTargetCreateManyInput = {
    id?: number
    employeeId: string
    targetStart: Date | string
    targetEnd: Date | string
    targetType: $Enums.TargetType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductWiseTargetUpdateManyMutationInput = {
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductWiseTargetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchCreateInput = {
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTargetProductBatchInput
    productWiseTarget: ProductWiseTargetCreateNestedOneWithoutTargetProductBatchInput
  }

  export type TargetProductBatchUncheckedCreateInput = {
    id?: number
    productId: number
    productTargetId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TargetProductBatchUpdateInput = {
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTargetProductBatchNestedInput
    productWiseTarget?: ProductWiseTargetUpdateOneRequiredWithoutTargetProductBatchNestedInput
  }

  export type TargetProductBatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    productTargetId?: IntFieldUpdateOperationsInput | number
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchCreateManyInput = {
    id?: number
    productId: number
    productTargetId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TargetProductBatchUpdateManyMutationInput = {
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    productTargetId?: IntFieldUpdateOperationsInput | number
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    categoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subCategory?: SubCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    categoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subCategory?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategory?: SubCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategory?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    categoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryCreateInput = {
    subCategoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutSubCategoryInput
    category: CategoryCreateNestedOneWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateInput = {
    id?: number
    subCategoryName: string
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUpdateInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutSubCategoryNestedInput
    category?: CategoryUpdateOneRequiredWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryCreateManyInput = {
    id?: number
    subCategoryName: string
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubCategoryUpdateManyMutationInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    product?: ProductCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountHeadCreateInput = {
    headName: string
    headCode: string
    createdAt?: Date | string
    updateAt?: Date | string
    ledgerHead?: LedgerHeadCreateNestedManyWithoutAccountHeadInput
  }

  export type AccountHeadUncheckedCreateInput = {
    id?: number
    headName: string
    headCode: string
    createdAt?: Date | string
    updateAt?: Date | string
    ledgerHead?: LedgerHeadUncheckedCreateNestedManyWithoutAccountHeadInput
  }

  export type AccountHeadUpdateInput = {
    headName?: StringFieldUpdateOperationsInput | string
    headCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerHead?: LedgerHeadUpdateManyWithoutAccountHeadNestedInput
  }

  export type AccountHeadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    headName?: StringFieldUpdateOperationsInput | string
    headCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerHead?: LedgerHeadUncheckedUpdateManyWithoutAccountHeadNestedInput
  }

  export type AccountHeadCreateManyInput = {
    id?: number
    headName: string
    headCode: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type AccountHeadUpdateManyMutationInput = {
    headName?: StringFieldUpdateOperationsInput | string
    headCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountHeadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    headName?: StringFieldUpdateOperationsInput | string
    headCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerHeadCreateInput = {
    ledgerName: string
    ledgerCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedJournal?: FixedJournalCreateNestedManyWithoutLedgerHeadInput
    journal?: JournalCreateNestedManyWithoutLedgerHeadInput
    accountHead: AccountHeadCreateNestedOneWithoutLedgerHeadInput
  }

  export type LedgerHeadUncheckedCreateInput = {
    id?: number
    ledgerName: string
    ledgerCode: string
    headCodeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutLedgerHeadInput
    journal?: JournalUncheckedCreateNestedManyWithoutLedgerHeadInput
  }

  export type LedgerHeadUpdateInput = {
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedJournal?: FixedJournalUpdateManyWithoutLedgerHeadNestedInput
    journal?: JournalUpdateManyWithoutLedgerHeadNestedInput
    accountHead?: AccountHeadUpdateOneRequiredWithoutLedgerHeadNestedInput
  }

  export type LedgerHeadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    headCodeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedJournal?: FixedJournalUncheckedUpdateManyWithoutLedgerHeadNestedInput
    journal?: JournalUncheckedUpdateManyWithoutLedgerHeadNestedInput
  }

  export type LedgerHeadCreateManyInput = {
    id?: number
    ledgerName: string
    ledgerCode: string
    headCodeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerHeadUpdateManyMutationInput = {
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerHeadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    headCodeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    name: string
    description: string
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    orderItem?: OrderItemCreateNestedManyWithoutProductInput
    Stakeholder?: StakeholderCreateNestedOneWithoutProductInput
    subCategory: SubCategoryCreateNestedOneWithoutProductInput
    unit: UnitCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId?: number | null
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUpdateManyWithoutProductNestedInput
    Stakeholder?: StakeholderUpdateOneWithoutProductNestedInput
    subCategory?: SubCategoryUpdateOneRequiredWithoutProductNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId?: number | null
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    bankName: string
    branceName?: string | null
    accountNumber: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransaction?: BankTransactionCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: number
    bankName: string
    branceName?: string | null
    accountNumber: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransaction?: BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUpdateInput = {
    bankName?: StringFieldUpdateOperationsInput | string
    branceName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransaction?: BankTransactionUpdateManyWithoutBankAccountNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankName?: StringFieldUpdateOperationsInput | string
    branceName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransaction?: BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput
  }

  export type BankAccountCreateManyInput = {
    id?: number
    bankName: string
    branceName?: string | null
    accountNumber: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    bankName?: StringFieldUpdateOperationsInput | string
    branceName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankName?: StringFieldUpdateOperationsInput | string
    branceName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateInput = {
    date: Date | string
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccount: BankAccountCreateNestedOneWithoutBankTransactionInput
    journal?: JournalCreateNestedOneWithoutBankTransactionInput
  }

  export type BankTransactionUncheckedCreateInput = {
    id?: number
    date: Date | string
    bankAccountId: number
    debitAmount?: number | null
    creditAmount?: number | null
    journalId?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: BankAccountUpdateOneRequiredWithoutBankTransactionNestedInput
    journal?: JournalUpdateOneWithoutBankTransactionNestedInput
  }

  export type BankTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountId?: IntFieldUpdateOperationsInput | number
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    journalId?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyInput = {
    id?: number
    date: Date | string
    bankAccountId: number
    debitAmount?: number | null
    creditAmount?: number | null
    journalId?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountId?: IntFieldUpdateOperationsInput | number
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    journalId?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    date: Date | string
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
    depo?: DepoCreateNestedOneWithoutInventoryInput
    fixedJournal?: FixedJournalCreateNestedOneWithoutInventoryInput
    product: ProductCreateNestedOneWithoutInventoryInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutInventoryInput
    user?: UserCreateNestedOneWithoutInventoriesInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    employeeId?: string | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
    depo?: DepoUpdateOneWithoutInventoryNestedInput
    fixedJournal?: FixedJournalUpdateOneWithoutInventoryNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutInventoryNestedInput
    user?: UserUpdateOneWithoutInventoriesNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryCreateManyInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    employeeId?: string | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionInfoCreateInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalCreateNestedManyWithoutTransactionInfoInput
    chemist?: ChemistCreateNestedOneWithoutTransactionInfoInput
    customers?: CustomersCreateNestedOneWithoutTransactionInfoInput
    user?: UserCreateNestedOneWithoutTransactionInfoInput
    party?: PartyCreateNestedOneWithoutTransactionInfoInput
    stakeholder?: StakeholderCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUpdateManyWithoutTransactionInfoNestedInput
    chemist?: ChemistUpdateOneWithoutTransactionInfoNestedInput
    customers?: CustomersUpdateOneWithoutTransactionInfoNestedInput
    user?: UserUpdateOneWithoutTransactionInfoNestedInput
    party?: PartyUpdateOneWithoutTransactionInfoNestedInput
    stakeholder?: StakeholderUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoCreateManyInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionInfoUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCreateInput = {
    date: Date | string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo?: DepoCreateNestedOneWithoutJournalInput
    ledgerHead?: LedgerHeadCreateNestedOneWithoutJournalInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutJournalInput
    bankTransaction?: BankTransactionCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateInput = {
    id?: number
    transactionId?: number | null
    ledgerHeadId?: number | null
    date: Date | string
    depoId?: number | null
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransaction?: BankTransactionUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneWithoutJournalNestedInput
    ledgerHead?: LedgerHeadUpdateOneWithoutJournalNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutJournalNestedInput
    bankTransaction?: BankTransactionUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransaction?: BankTransactionUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalCreateManyInput = {
    id?: number
    transactionId?: number | null
    ledgerHeadId?: number | null
    date: Date | string
    depoId?: number | null
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedJournalCreateInput = {
    date: Date | string
    voucherNo: string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist: ChemistCreateNestedOneWithoutFixedJournalInput
    depo: DepoCreateNestedOneWithoutFixedJournalInput
    ledgerHead: LedgerHeadCreateNestedOneWithoutFixedJournalInput
    inventory?: InventoryCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalUncheckedCreateInput = {
    id?: number
    date: Date | string
    voucherNo: string
    chemistId: string
    ledgerHeadId: number
    depoId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateOneRequiredWithoutFixedJournalNestedInput
    depo?: DepoUpdateOneRequiredWithoutFixedJournalNestedInput
    ledgerHead?: LedgerHeadUpdateOneRequiredWithoutFixedJournalNestedInput
    inventory?: InventoryUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    ledgerHeadId?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalCreateManyInput = {
    id?: number
    date: Date | string
    voucherNo: string
    chemistId: string
    ledgerHeadId: number
    depoId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedJournalUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    ledgerHeadId?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemCreateNestedManyWithoutOrderInput
    orderStatus?: OrderStatusCreateNestedManyWithoutOrderInput
    chemist: ChemistCreateNestedOneWithoutOrderInput
    user: UserCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    employeeId: string
    chemistId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    orderStatus?: OrderStatusUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateManyWithoutOrderNestedInput
    orderStatus?: OrderStatusUpdateManyWithoutOrderNestedInput
    chemist?: ChemistUpdateOneRequiredWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    orderStatus?: OrderStatusUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    employeeId: string
    chemistId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    quintity: number
    tpRate: number
    amount: number
    order: OrderCreateNestedOneWithoutOrderItemInput
    product: ProductCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    productId: number
    quintity: number
    tpRate: number
    amount: number
  }

  export type OrderItemUpdateInput = {
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    productId: number
    quintity: number
    tpRate: number
    amount: number
  }

  export type OrderItemUpdateManyMutationInput = {
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderStatusCreateInput = {
    status?: $Enums.OrdStatus
    comments?: string | null
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutOrderStatusInput
  }

  export type OrderStatusUncheckedCreateInput = {
    id?: number
    orderNo?: string | null
    status?: $Enums.OrdStatus
    comments?: string | null
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderStatusUpdateInput = {
    status?: EnumOrdStatusFieldUpdateOperationsInput | $Enums.OrdStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutOrderStatusNestedInput
  }

  export type OrderStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrdStatusFieldUpdateOperationsInput | $Enums.OrdStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusCreateManyInput = {
    id?: number
    orderNo?: string | null
    status?: $Enums.OrdStatus
    comments?: string | null
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderStatusUpdateManyMutationInput = {
    status?: EnumOrdStatusFieldUpdateOperationsInput | $Enums.OrdStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrdStatusFieldUpdateOperationsInput | $Enums.OrdStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    date: Date | string
    time: string
    status: string
    comments: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: number
    employeeId: string
    date: Date | string
    time: string
    status: string
    comments: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: number
    employeeId: string
    date: Date | string
    time: string
    status: string
    comments: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeCreateInput = {
    overtimeDate: Date | string
    overtimeHours: string
    others: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeUncheckedCreateInput = {
    id?: number
    employeeId: string
    overtimeDate: Date | string
    overtimeHours: string
    others: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeUpdateInput = {
    overtimeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimeHours?: StringFieldUpdateOperationsInput | string
    others?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    overtimeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimeHours?: StringFieldUpdateOperationsInput | string
    others?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeCreateManyInput = {
    id?: number
    employeeId: string
    overtimeDate: Date | string
    overtimeHours: string
    others: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeUpdateManyMutationInput = {
    overtimeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimeHours?: StringFieldUpdateOperationsInput | string
    others?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    overtimeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimeHours?: StringFieldUpdateOperationsInput | string
    others?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeCreateInput = {
    leaveName: string
    leves?: LevesCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateInput = {
    id?: number
    leaveName: string
    leves?: LevesUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUpdateInput = {
    leaveName?: StringFieldUpdateOperationsInput | string
    leves?: LevesUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveName?: StringFieldUpdateOperationsInput | string
    leves?: LevesUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeCreateManyInput = {
    id?: number
    leaveName: string
  }

  export type LeaveTypeUpdateManyMutationInput = {
    leaveName?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveName?: StringFieldUpdateOperationsInput | string
  }

  export type LevesCreateInput = {
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLevesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLevesInput
  }

  export type LevesUncheckedCreateInput = {
    id?: number
    leaveTypeId: number
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevesUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLevesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLevesNestedInput
  }

  export type LevesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveTypeId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevesCreateManyInput = {
    id?: number
    leaveTypeId: number
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevesUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveTypeId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBankDetailsCreateInput = {
    bankName: string
    bankAccountNumber: string
    branchName: string
    ifsscode: string
  }

  export type EmployeeBankDetailsUncheckedCreateInput = {
    id?: number
    bankName: string
    bankAccountNumber: string
    branchName: string
    ifsscode: string
  }

  export type EmployeeBankDetailsUpdateInput = {
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    ifsscode?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeBankDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    ifsscode?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeBankDetailsCreateManyInput = {
    id?: number
    bankName: string
    bankAccountNumber: string
    branchName: string
    ifsscode: string
  }

  export type EmployeeBankDetailsUpdateManyMutationInput = {
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    ifsscode?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeBankDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    ifsscode?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryInfoCreateInput = {
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalaryInfoInput
  }

  export type SalaryInfoUncheckedCreateInput = {
    id?: number
    employeeId: string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryInfoUpdateInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insuranceAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalaryInfoNestedInput
  }

  export type SalaryInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insuranceAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryInfoCreateManyInput = {
    id?: number
    employeeId: string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryInfoUpdateManyMutationInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insuranceAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insuranceAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    payDate: Date | string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPayrollInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: number
    employeeId: string
    payDate: Date | string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateInput = {
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insentive?: FloatFieldUpdateOperationsInput | number
    eidBonus?: FloatFieldUpdateOperationsInput | number
    boishakhi?: FloatFieldUpdateOperationsInput | number
    others?: FloatFieldUpdateOperationsInput | number
    fp?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insentive?: FloatFieldUpdateOperationsInput | number
    eidBonus?: FloatFieldUpdateOperationsInput | number
    boishakhi?: FloatFieldUpdateOperationsInput | number
    others?: FloatFieldUpdateOperationsInput | number
    fp?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateManyInput = {
    id?: number
    employeeId: string
    payDate: Date | string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insentive?: FloatFieldUpdateOperationsInput | number
    eidBonus?: FloatFieldUpdateOperationsInput | number
    boishakhi?: FloatFieldUpdateOperationsInput | number
    others?: FloatFieldUpdateOperationsInput | number
    fp?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insentive?: FloatFieldUpdateOperationsInput | number
    eidBonus?: FloatFieldUpdateOperationsInput | number
    boishakhi?: FloatFieldUpdateOperationsInput | number
    others?: FloatFieldUpdateOperationsInput | number
    fp?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductWiseTargetNullableScalarRelationFilter = {
    is?: ProductWiseTargetWhereInput | null
    isNot?: ProductWiseTargetWhereInput | null
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type EmployeeProfileNullableScalarRelationFilter = {
    is?: EmployeeProfileWhereInput | null
    isNot?: EmployeeProfileWhereInput | null
  }

  export type LevesListRelationFilter = {
    every?: LevesWhereInput
    some?: LevesWhereInput
    none?: LevesWhereInput
  }

  export type MpoTargetNullableScalarRelationFilter = {
    is?: MpoTargetWhereInput | null
    isNot?: MpoTargetWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OvertimeListRelationFilter = {
    every?: OvertimeWhereInput
    some?: OvertimeWhereInput
    none?: OvertimeWhereInput
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type SalaryInfoListRelationFilter = {
    every?: SalaryInfoWhereInput
    some?: SalaryInfoWhereInput
    none?: SalaryInfoWhereInput
  }

  export type ScopeNullableScalarRelationFilter = {
    is?: ScopeWhereInput | null
    isNot?: ScopeWhereInput | null
  }

  export type TransactionInfoListRelationFilter = {
    every?: TransactionInfoWhereInput
    some?: TransactionInfoWhereInput
    none?: TransactionInfoWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OvertimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    photo?: SortOrder
    roles?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeProfileOrderByRelevanceInput = {
    fields: EmployeeProfileOrderByRelevanceFieldEnum | EmployeeProfileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeProfileCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    officeContactNo?: SortOrder
    currentAddress?: SortOrder
    permanentAddress?: SortOrder
    nid?: SortOrder
    dob?: SortOrder
    contactNo?: SortOrder
    emergencyContactNo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeProfileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    officeContactNo?: SortOrder
    currentAddress?: SortOrder
    permanentAddress?: SortOrder
    nid?: SortOrder
    dob?: SortOrder
    contactNo?: SortOrder
    emergencyContactNo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeProfileMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    officeContactNo?: SortOrder
    currentAddress?: SortOrder
    permanentAddress?: SortOrder
    nid?: SortOrder
    dob?: SortOrder
    contactNo?: SortOrder
    emergencyContactNo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeProfileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DepoScalarRelationFilter = {
    is?: DepoWhereInput
    isNot?: DepoWhereInput
  }

  export type ScopeListRelationFilter = {
    every?: ScopeWhereInput
    some?: ScopeWhereInput
    none?: ScopeWhereInput
  }

  export type ScopeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostOrderByRelevanceInput = {
    fields: JobPostOrderByRelevanceFieldEnum | JobPostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobPostCountOrderByAggregateInput = {
    id?: SortOrder
    depoId?: SortOrder
    postName?: SortOrder
    qualification?: SortOrder
    responsibility?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobPostAvgOrderByAggregateInput = {
    id?: SortOrder
    depoId?: SortOrder
  }

  export type JobPostMaxOrderByAggregateInput = {
    id?: SortOrder
    depoId?: SortOrder
    postName?: SortOrder
    qualification?: SortOrder
    responsibility?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobPostMinOrderByAggregateInput = {
    id?: SortOrder
    depoId?: SortOrder
    postName?: SortOrder
    qualification?: SortOrder
    responsibility?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobPostSumOrderByAggregateInput = {
    id?: SortOrder
    depoId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FixedJournalListRelationFilter = {
    every?: FixedJournalWhereInput
    some?: FixedJournalWhereInput
    none?: FixedJournalWhereInput
  }

  export type FixedJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChemistOrderByRelevanceInput = {
    fields: ChemistOrderByRelevanceFieldEnum | ChemistOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChemistCountOrderByAggregateInput = {
    id?: SortOrder
    chemistId?: SortOrder
    depoId?: SortOrder
    pharmacyName?: SortOrder
    contactPerson?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    discountRate?: SortOrder
    openingDueAmount?: SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChemistAvgOrderByAggregateInput = {
    id?: SortOrder
    depoId?: SortOrder
    discountRate?: SortOrder
    openingDueAmount?: SortOrder
  }

  export type ChemistMaxOrderByAggregateInput = {
    id?: SortOrder
    chemistId?: SortOrder
    depoId?: SortOrder
    pharmacyName?: SortOrder
    contactPerson?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    discountRate?: SortOrder
    openingDueAmount?: SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChemistMinOrderByAggregateInput = {
    id?: SortOrder
    chemistId?: SortOrder
    depoId?: SortOrder
    pharmacyName?: SortOrder
    contactPerson?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    discountRate?: SortOrder
    openingDueAmount?: SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChemistSumOrderByAggregateInput = {
    id?: SortOrder
    depoId?: SortOrder
    discountRate?: SortOrder
    openingDueAmount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type ChemistListRelationFilter = {
    every?: ChemistWhereInput
    some?: ChemistWhereInput
    none?: ChemistWhereInput
  }

  export type JobPostListRelationFilter = {
    every?: JobPostWhereInput
    some?: JobPostWhereInput
    none?: JobPostWhereInput
  }

  export type JournalListRelationFilter = {
    every?: JournalWhereInput
    some?: JournalWhereInput
    none?: JournalWhereInput
  }

  export type ChemistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepoOrderByRelevanceInput = {
    fields: DepoOrderByRelevanceFieldEnum | DepoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DepoCountOrderByAggregateInput = {
    id?: SortOrder
    depoName?: SortOrder
    location?: SortOrder
    scopeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepoAvgOrderByAggregateInput = {
    id?: SortOrder
    scopeId?: SortOrder
  }

  export type DepoMaxOrderByAggregateInput = {
    id?: SortOrder
    depoName?: SortOrder
    location?: SortOrder
    scopeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepoMinOrderByAggregateInput = {
    id?: SortOrder
    depoName?: SortOrder
    location?: SortOrder
    scopeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepoSumOrderByAggregateInput = {
    id?: SortOrder
    scopeId?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumPartyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartyType | EnumPartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartyType[]
    notIn?: $Enums.PartyType[]
    not?: NestedEnumPartyTypeFilter<$PrismaModel> | $Enums.PartyType
  }

  export type PartyOrderByRelevanceInput = {
    fields: PartyOrderByRelevanceFieldEnum | PartyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PartyCountOrderByAggregateInput = {
    id?: SortOrder
    partyName?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    partytype?: SortOrder
    openingAmount?: SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartyAvgOrderByAggregateInput = {
    id?: SortOrder
    openingAmount?: SortOrder
  }

  export type PartyMaxOrderByAggregateInput = {
    id?: SortOrder
    partyName?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    partytype?: SortOrder
    openingAmount?: SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartyMinOrderByAggregateInput = {
    id?: SortOrder
    partyName?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    partytype?: SortOrder
    openingAmount?: SortOrder
    openingDate?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartySumOrderByAggregateInput = {
    id?: SortOrder
    openingAmount?: SortOrder
  }

  export type EnumPartyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartyType | EnumPartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartyType[]
    notIn?: $Enums.PartyType[]
    not?: NestedEnumPartyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartyTypeFilter<$PrismaModel>
    _max?: NestedEnumPartyTypeFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type StakeholderDegreeScalarRelationFilter = {
    is?: StakeholderDegreeWhereInput
    isNot?: StakeholderDegreeWhereInput
  }

  export type StakeholderDeisgnationScalarRelationFilter = {
    is?: StakeholderDeisgnationWhereInput
    isNot?: StakeholderDeisgnationWhereInput
  }

  export type StakeholderChemberListRelationFilter = {
    every?: stakeholderChemberWhereInput
    some?: stakeholderChemberWhereInput
    none?: stakeholderChemberWhereInput
  }

  export type StakeholderOcationListRelationFilter = {
    every?: StakeholderOcationWhereInput
    some?: StakeholderOcationWhereInput
    none?: StakeholderOcationWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type stakeholderChemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StakeholderOcationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StakeholderOrderByRelevanceInput = {
    fields: StakeholderOrderByRelevanceFieldEnum | StakeholderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StakeholderCountOrderByAggregateInput = {
    id?: SortOrder
    scopeId?: SortOrder
    stakeId?: SortOrder
    name?: SortOrder
    designationId?: SortOrder
    degreeId?: SortOrder
    category?: SortOrder
    officeAddress?: SortOrder
    contactNo?: SortOrder
    honorary?: SortOrder
    paymentDate?: SortOrder
    rxCommitment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderAvgOrderByAggregateInput = {
    id?: SortOrder
    scopeId?: SortOrder
    designationId?: SortOrder
    degreeId?: SortOrder
    honorary?: SortOrder
    rxCommitment?: SortOrder
  }

  export type StakeholderMaxOrderByAggregateInput = {
    id?: SortOrder
    scopeId?: SortOrder
    stakeId?: SortOrder
    name?: SortOrder
    designationId?: SortOrder
    degreeId?: SortOrder
    category?: SortOrder
    officeAddress?: SortOrder
    contactNo?: SortOrder
    honorary?: SortOrder
    paymentDate?: SortOrder
    rxCommitment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderMinOrderByAggregateInput = {
    id?: SortOrder
    scopeId?: SortOrder
    stakeId?: SortOrder
    name?: SortOrder
    designationId?: SortOrder
    degreeId?: SortOrder
    category?: SortOrder
    officeAddress?: SortOrder
    contactNo?: SortOrder
    honorary?: SortOrder
    paymentDate?: SortOrder
    rxCommitment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderSumOrderByAggregateInput = {
    id?: SortOrder
    scopeId?: SortOrder
    designationId?: SortOrder
    degreeId?: SortOrder
    honorary?: SortOrder
    rxCommitment?: SortOrder
  }

  export type StakeholderListRelationFilter = {
    every?: StakeholderWhereInput
    some?: StakeholderWhereInput
    none?: StakeholderWhereInput
  }

  export type StakeholderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StakeholderDeisgnationOrderByRelevanceInput = {
    fields: StakeholderDeisgnationOrderByRelevanceFieldEnum | StakeholderDeisgnationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StakeholderDeisgnationCountOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    description?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderDeisgnationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StakeholderDeisgnationMaxOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    description?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderDeisgnationMinOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    description?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderDeisgnationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StakeholderDegreeOrderByRelevanceInput = {
    fields: StakeholderDegreeOrderByRelevanceFieldEnum | StakeholderDegreeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StakeholderDegreeCountOrderByAggregateInput = {
    id?: SortOrder
    degreeName?: SortOrder
    description?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderDegreeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StakeholderDegreeMaxOrderByAggregateInput = {
    id?: SortOrder
    degreeName?: SortOrder
    description?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderDegreeMinOrderByAggregateInput = {
    id?: SortOrder
    degreeName?: SortOrder
    description?: SortOrder
    isDelete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StakeholderDegreeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StakeholderNullableScalarRelationFilter = {
    is?: StakeholderWhereInput | null
    isNot?: StakeholderWhereInput | null
  }

  export type stakeholderChemberOrderByRelevanceInput = {
    fields: stakeholderChemberOrderByRelevanceFieldEnum | stakeholderChemberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type stakeholderChemberCountOrderByAggregateInput = {
    id?: SortOrder
    stakeId?: SortOrder
    address?: SortOrder
    chemberDay?: SortOrder
    chemberTime?: SortOrder
    chemberName?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type stakeholderChemberAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type stakeholderChemberMaxOrderByAggregateInput = {
    id?: SortOrder
    stakeId?: SortOrder
    address?: SortOrder
    chemberDay?: SortOrder
    chemberTime?: SortOrder
    chemberName?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type stakeholderChemberMinOrderByAggregateInput = {
    id?: SortOrder
    stakeId?: SortOrder
    address?: SortOrder
    chemberDay?: SortOrder
    chemberTime?: SortOrder
    chemberName?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type stakeholderChemberSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StakeholderScalarRelationFilter = {
    is?: StakeholderWhereInput
    isNot?: StakeholderWhereInput
  }

  export type StakeholderOcationOrderByRelevanceInput = {
    fields: StakeholderOcationOrderByRelevanceFieldEnum | StakeholderOcationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StakeholderOcationCountOrderByAggregateInput = {
    id?: SortOrder
    stakeId?: SortOrder
    ocationName?: SortOrder
    relation?: SortOrder
    personName?: SortOrder
    dob?: SortOrder
    otherInfo?: SortOrder
  }

  export type StakeholderOcationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StakeholderOcationMaxOrderByAggregateInput = {
    id?: SortOrder
    stakeId?: SortOrder
    ocationName?: SortOrder
    relation?: SortOrder
    personName?: SortOrder
    dob?: SortOrder
    otherInfo?: SortOrder
  }

  export type StakeholderOcationMinOrderByAggregateInput = {
    id?: SortOrder
    stakeId?: SortOrder
    ocationName?: SortOrder
    relation?: SortOrder
    personName?: SortOrder
    dob?: SortOrder
    otherInfo?: SortOrder
  }

  export type StakeholderOcationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CustomersOrderByRelevanceInput = {
    fields: CustomersOrderByRelevanceFieldEnum | CustomersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactNo?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepoListRelationFilter = {
    every?: DepoWhereInput
    some?: DepoWhereInput
    none?: DepoWhereInput
  }

  export type JobPostScalarRelationFilter = {
    is?: JobPostWhereInput
    isNot?: JobPostWhereInput
  }

  export type DepoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScopeOrderByRelevanceInput = {
    fields: ScopeOrderByRelevanceFieldEnum | ScopeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScopeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScopeAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type ScopeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScopeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScopeSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type MpoTargetOrderByRelevanceInput = {
    fields: MpoTargetOrderByRelevanceFieldEnum | MpoTargetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MpoTargetCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    tergatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MpoTargetAvgOrderByAggregateInput = {
    id?: SortOrder
    tergatAmount?: SortOrder
  }

  export type MpoTargetMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    tergatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MpoTargetMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    tergatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MpoTargetSumOrderByAggregateInput = {
    id?: SortOrder
    tergatAmount?: SortOrder
  }

  export type EnumTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[]
    notIn?: $Enums.TargetType[]
    not?: NestedEnumTargetTypeFilter<$PrismaModel> | $Enums.TargetType
  }

  export type TargetProductBatchListRelationFilter = {
    every?: TargetProductBatchWhereInput
    some?: TargetProductBatchWhereInput
    none?: TargetProductBatchWhereInput
  }

  export type TargetProductBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductWiseTargetOrderByRelevanceInput = {
    fields: ProductWiseTargetOrderByRelevanceFieldEnum | ProductWiseTargetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductWiseTargetCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    targetStart?: SortOrder
    targetEnd?: SortOrder
    targetType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductWiseTargetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductWiseTargetMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    targetStart?: SortOrder
    targetEnd?: SortOrder
    targetType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductWiseTargetMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    targetStart?: SortOrder
    targetEnd?: SortOrder
    targetType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductWiseTargetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[]
    notIn?: $Enums.TargetType[]
    not?: NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumTargetTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductWiseTargetScalarRelationFilter = {
    is?: ProductWiseTargetWhereInput
    isNot?: ProductWiseTargetWhereInput
  }

  export type TargetProductBatchCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productTargetId?: SortOrder
    numberOfProduct?: SortOrder
    insentiveAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TargetProductBatchAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productTargetId?: SortOrder
    numberOfProduct?: SortOrder
    insentiveAmount?: SortOrder
  }

  export type TargetProductBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productTargetId?: SortOrder
    numberOfProduct?: SortOrder
    insentiveAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TargetProductBatchMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productTargetId?: SortOrder
    numberOfProduct?: SortOrder
    insentiveAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TargetProductBatchSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productTargetId?: SortOrder
    numberOfProduct?: SortOrder
    insentiveAmount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SubCategoryListRelationFilter = {
    every?: SubCategoryWhereInput
    some?: SubCategoryWhereInput
    none?: SubCategoryWhereInput
  }

  export type SubCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelevanceInput = {
    fields: CategoryOrderByRelevanceFieldEnum | CategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SubCategoryOrderByRelevanceInput = {
    fields: SubCategoryOrderByRelevanceFieldEnum | SubCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    subCategoryName?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type SubCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    subCategoryName?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    subCategoryName?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategorySumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type UnitOrderByRelevanceInput = {
    fields: UnitOrderByRelevanceFieldEnum | UnitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LedgerHeadListRelationFilter = {
    every?: LedgerHeadWhereInput
    some?: LedgerHeadWhereInput
    none?: LedgerHeadWhereInput
  }

  export type LedgerHeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountHeadOrderByRelevanceInput = {
    fields: AccountHeadOrderByRelevanceFieldEnum | AccountHeadOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountHeadCountOrderByAggregateInput = {
    id?: SortOrder
    headName?: SortOrder
    headCode?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type AccountHeadAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountHeadMaxOrderByAggregateInput = {
    id?: SortOrder
    headName?: SortOrder
    headCode?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type AccountHeadMinOrderByAggregateInput = {
    id?: SortOrder
    headName?: SortOrder
    headCode?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type AccountHeadSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountHeadScalarRelationFilter = {
    is?: AccountHeadWhereInput
    isNot?: AccountHeadWhereInput
  }

  export type LedgerHeadOrderByRelevanceInput = {
    fields: LedgerHeadOrderByRelevanceFieldEnum | LedgerHeadOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LedgerHeadCountOrderByAggregateInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    ledgerCode?: SortOrder
    headCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerHeadAvgOrderByAggregateInput = {
    id?: SortOrder
    headCodeId?: SortOrder
  }

  export type LedgerHeadMaxOrderByAggregateInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    ledgerCode?: SortOrder
    headCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerHeadMinOrderByAggregateInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    ledgerCode?: SortOrder
    headCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerHeadSumOrderByAggregateInput = {
    id?: SortOrder
    headCodeId?: SortOrder
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type SubCategoryScalarRelationFilter = {
    is?: SubCategoryWhereInput
    isNot?: SubCategoryWhereInput
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subCategoryId?: SortOrder
    stakeholderId?: SortOrder
    size?: SortOrder
    unitId?: SortOrder
    mrp?: SortOrder
    tp?: SortOrder
    balance?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    subCategoryId?: SortOrder
    stakeholderId?: SortOrder
    unitId?: SortOrder
    mrp?: SortOrder
    tp?: SortOrder
    balance?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subCategoryId?: SortOrder
    stakeholderId?: SortOrder
    size?: SortOrder
    unitId?: SortOrder
    mrp?: SortOrder
    tp?: SortOrder
    balance?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subCategoryId?: SortOrder
    stakeholderId?: SortOrder
    size?: SortOrder
    unitId?: SortOrder
    mrp?: SortOrder
    tp?: SortOrder
    balance?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    subCategoryId?: SortOrder
    stakeholderId?: SortOrder
    unitId?: SortOrder
    mrp?: SortOrder
    tp?: SortOrder
    balance?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type BankTransactionListRelationFilter = {
    every?: BankTransactionWhereInput
    some?: BankTransactionWhereInput
    none?: BankTransactionWhereInput
  }

  export type BankTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountOrderByRelevanceInput = {
    fields: BankAccountOrderByRelevanceFieldEnum | BankAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BankAccountBankNameAccountNumberCompoundUniqueInput = {
    bankName: string
    accountNumber: string
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    branceName?: SortOrder
    accountNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    branceName?: SortOrder
    accountNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    branceName?: SortOrder
    accountNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BankAccountScalarRelationFilter = {
    is?: BankAccountWhereInput
    isNot?: BankAccountWhereInput
  }

  export type JournalNullableScalarRelationFilter = {
    is?: JournalWhereInput | null
    isNot?: JournalWhereInput | null
  }

  export type BankTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    bankAccountId?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    journalId?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    journalId?: SortOrder
  }

  export type BankTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    bankAccountId?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    journalId?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    bankAccountId?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    journalId?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    journalId?: SortOrder
  }

  export type DepoNullableScalarRelationFilter = {
    is?: DepoWhereInput | null
    isNot?: DepoWhereInput | null
  }

  export type FixedJournalNullableScalarRelationFilter = {
    is?: FixedJournalWhereInput | null
    isNot?: FixedJournalWhereInput | null
  }

  export type TransactionInfoNullableScalarRelationFilter = {
    is?: TransactionInfoWhereInput | null
    isNot?: TransactionInfoWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InventoryOrderByRelevanceInput = {
    fields: InventoryOrderByRelevanceFieldEnum | InventoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    productId?: SortOrder
    depoId?: SortOrder
    employeeId?: SortOrder
    transactionId?: SortOrder
    fixedJournalId?: SortOrder
    unitPrice?: SortOrder
    quantityAdd?: SortOrder
    quantityLess?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFixted?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    depoId?: SortOrder
    transactionId?: SortOrder
    fixedJournalId?: SortOrder
    unitPrice?: SortOrder
    quantityAdd?: SortOrder
    quantityLess?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    productId?: SortOrder
    depoId?: SortOrder
    employeeId?: SortOrder
    transactionId?: SortOrder
    fixedJournalId?: SortOrder
    unitPrice?: SortOrder
    quantityAdd?: SortOrder
    quantityLess?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFixted?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    productId?: SortOrder
    depoId?: SortOrder
    employeeId?: SortOrder
    transactionId?: SortOrder
    fixedJournalId?: SortOrder
    unitPrice?: SortOrder
    quantityAdd?: SortOrder
    quantityLess?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFixted?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    depoId?: SortOrder
    transactionId?: SortOrder
    fixedJournalId?: SortOrder
    unitPrice?: SortOrder
    quantityAdd?: SortOrder
    quantityLess?: SortOrder
    debitAmount?: SortOrder
    creditAmount?: SortOrder
  }

  export type EnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[]
    notIn?: $Enums.VoucherType[]
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type EnumPaymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | null
    notIn?: $Enums.PaymentType[] | null
    not?: NestedEnumPaymentTypeNullableFilter<$PrismaModel> | $Enums.PaymentType | null
  }

  export type ChemistNullableScalarRelationFilter = {
    is?: ChemistWhereInput | null
    isNot?: ChemistWhereInput | null
  }

  export type CustomersNullableScalarRelationFilter = {
    is?: CustomersWhereInput | null
    isNot?: CustomersWhereInput | null
  }

  export type PartyNullableScalarRelationFilter = {
    is?: PartyWhereInput | null
    isNot?: PartyWhereInput | null
  }

  export type TransactionInfoOrderByRelevanceInput = {
    fields: TransactionInfoOrderByRelevanceFieldEnum | TransactionInfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionInfoCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    invoiceNo?: SortOrder
    chemistId?: SortOrder
    customerId?: SortOrder
    stakeholderId?: SortOrder
    employeeId?: SortOrder
    partyId?: SortOrder
    voucherType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    partyId?: SortOrder
  }

  export type TransactionInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    invoiceNo?: SortOrder
    chemistId?: SortOrder
    customerId?: SortOrder
    stakeholderId?: SortOrder
    employeeId?: SortOrder
    partyId?: SortOrder
    voucherType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionInfoMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    invoiceNo?: SortOrder
    chemistId?: SortOrder
    customerId?: SortOrder
    stakeholderId?: SortOrder
    employeeId?: SortOrder
    partyId?: SortOrder
    voucherType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionInfoSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    partyId?: SortOrder
  }

  export type EnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[]
    notIn?: $Enums.VoucherType[]
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type EnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | null
    notIn?: $Enums.PaymentType[] | null
    not?: NestedEnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
  }

  export type LedgerHeadNullableScalarRelationFilter = {
    is?: LedgerHeadWhereInput | null
    isNot?: LedgerHeadWhereInput | null
  }

  export type JournalOrderByRelevanceInput = {
    fields: JournalOrderByRelevanceFieldEnum | JournalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JournalCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    ledgerHeadId?: SortOrder
    date?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
    narration?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
  }

  export type JournalMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    ledgerHeadId?: SortOrder
    date?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
    narration?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    ledgerHeadId?: SortOrder
    date?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
    narration?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
  }

  export type ChemistScalarRelationFilter = {
    is?: ChemistWhereInput
    isNot?: ChemistWhereInput
  }

  export type LedgerHeadScalarRelationFilter = {
    is?: LedgerHeadWhereInput
    isNot?: LedgerHeadWhereInput
  }

  export type FixedJournalOrderByRelevanceInput = {
    fields: FixedJournalOrderByRelevanceFieldEnum | FixedJournalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FixedJournalCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    chemistId?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
    narration?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixedJournalAvgOrderByAggregateInput = {
    id?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
  }

  export type FixedJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    chemistId?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
    narration?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixedJournalMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    voucherNo?: SortOrder
    chemistId?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
    narration?: SortOrder
    isClosing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixedJournalSumOrderByAggregateInput = {
    id?: SortOrder
    ledgerHeadId?: SortOrder
    depoId?: SortOrder
    creditAmount?: SortOrder
    debitAmount?: SortOrder
  }

  export type OrderStatusListRelationFilter = {
    every?: OrderStatusWhereInput
    some?: OrderStatusWhereInput
    none?: OrderStatusWhereInput
  }

  export type OrderStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelevanceInput = {
    fields: OrderOrderByRelevanceFieldEnum | OrderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    chemistId?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    chemistId?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    chemistId?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quintity?: SortOrder
    tpRate?: SortOrder
    amount?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quintity?: SortOrder
    tpRate?: SortOrder
    amount?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quintity?: SortOrder
    tpRate?: SortOrder
    amount?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quintity?: SortOrder
    tpRate?: SortOrder
    amount?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quintity?: SortOrder
    tpRate?: SortOrder
    amount?: SortOrder
  }

  export type EnumOrdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrdStatus | EnumOrdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrdStatus[]
    notIn?: $Enums.OrdStatus[]
    not?: NestedEnumOrdStatusFilter<$PrismaModel> | $Enums.OrdStatus
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type OrderStatusOrderByRelevanceInput = {
    fields: OrderStatusOrderByRelevanceFieldEnum | OrderStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderStatusCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderStatusMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumOrdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrdStatus | EnumOrdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrdStatus[]
    notIn?: $Enums.OrdStatus[]
    not?: NestedEnumOrdStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrdStatusFilter<$PrismaModel>
    _max?: NestedEnumOrdStatusFilter<$PrismaModel>
  }

  export type AttendanceOrderByRelevanceInput = {
    fields: AttendanceOrderByRelevanceFieldEnum | AttendanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OvertimeOrderByRelevanceInput = {
    fields: OvertimeOrderByRelevanceFieldEnum | OvertimeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OvertimeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    overtimeDate?: SortOrder
    overtimeHours?: SortOrder
    others?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OvertimeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    overtimeDate?: SortOrder
    overtimeHours?: SortOrder
    others?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    overtimeDate?: SortOrder
    overtimeHours?: SortOrder
    others?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveTypeOrderByRelevanceInput = {
    fields: LeaveTypeOrderByRelevanceFieldEnum | LeaveTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LeaveTypeCountOrderByAggregateInput = {
    id?: SortOrder
    leaveName?: SortOrder
  }

  export type LeaveTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    leaveName?: SortOrder
  }

  export type LeaveTypeMinOrderByAggregateInput = {
    id?: SortOrder
    leaveName?: SortOrder
  }

  export type LeaveTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveTypeScalarRelationFilter = {
    is?: LeaveTypeWhereInput
    isNot?: LeaveTypeWhereInput
  }

  export type LevesOrderByRelevanceInput = {
    fields: LevesOrderByRelevanceFieldEnum | LevesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LevesCountOrderByAggregateInput = {
    id?: SortOrder
    leaveTypeId?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevesAvgOrderByAggregateInput = {
    id?: SortOrder
    leaveTypeId?: SortOrder
  }

  export type LevesMaxOrderByAggregateInput = {
    id?: SortOrder
    leaveTypeId?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevesMinOrderByAggregateInput = {
    id?: SortOrder
    leaveTypeId?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevesSumOrderByAggregateInput = {
    id?: SortOrder
    leaveTypeId?: SortOrder
  }

  export type EmployeeBankDetailsOrderByRelevanceInput = {
    fields: EmployeeBankDetailsOrderByRelevanceFieldEnum | EmployeeBankDetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeBankDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    branchName?: SortOrder
    ifsscode?: SortOrder
  }

  export type EmployeeBankDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeBankDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    branchName?: SortOrder
    ifsscode?: SortOrder
  }

  export type EmployeeBankDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    branchName?: SortOrder
    ifsscode?: SortOrder
  }

  export type EmployeeBankDetailsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalaryInfoOrderByRelevanceInput = {
    fields: SalaryInfoOrderByRelevanceFieldEnum | SalaryInfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SalaryInfoCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insuranceAmount?: SortOrder
  }

  export type SalaryInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryInfoMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryInfoSumOrderByAggregateInput = {
    id?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insuranceAmount?: SortOrder
  }

  export type PayrollOrderByRelevanceInput = {
    fields: PayrollOrderByRelevanceFieldEnum | PayrollOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    payDate?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insentive?: SortOrder
    eidBonus?: SortOrder
    boishakhi?: SortOrder
    others?: SortOrder
    fp?: SortOrder
    insurance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    id?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insentive?: SortOrder
    eidBonus?: SortOrder
    boishakhi?: SortOrder
    others?: SortOrder
    fp?: SortOrder
    insurance?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    payDate?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insentive?: SortOrder
    eidBonus?: SortOrder
    boishakhi?: SortOrder
    others?: SortOrder
    fp?: SortOrder
    insurance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    payDate?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insentive?: SortOrder
    eidBonus?: SortOrder
    boishakhi?: SortOrder
    others?: SortOrder
    fp?: SortOrder
    insurance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    id?: SortOrder
    basicSalary?: SortOrder
    houseRend?: SortOrder
    mobile?: SortOrder
    medial?: SortOrder
    taDa?: SortOrder
    insentive?: SortOrder
    eidBonus?: SortOrder
    boishakhi?: SortOrder
    others?: SortOrder
    fp?: SortOrder
    insurance?: SortOrder
  }

  export type ProductWiseTargetCreateNestedOneWithoutUserInput = {
    create?: XOR<ProductWiseTargetCreateWithoutUserInput, ProductWiseTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductWiseTargetCreateOrConnectWithoutUserInput
    connect?: ProductWiseTargetWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EmployeeProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type LevesCreateNestedManyWithoutUserInput = {
    create?: XOR<LevesCreateWithoutUserInput, LevesUncheckedCreateWithoutUserInput> | LevesCreateWithoutUserInput[] | LevesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutUserInput | LevesCreateOrConnectWithoutUserInput[]
    createMany?: LevesCreateManyUserInputEnvelope
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
  }

  export type MpoTargetCreateNestedOneWithoutUserInput = {
    create?: XOR<MpoTargetCreateWithoutUserInput, MpoTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: MpoTargetCreateOrConnectWithoutUserInput
    connect?: MpoTargetWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OvertimeCreateNestedManyWithoutUserInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutUserInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type SalaryInfoCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryInfoCreateWithoutUserInput, SalaryInfoUncheckedCreateWithoutUserInput> | SalaryInfoCreateWithoutUserInput[] | SalaryInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryInfoCreateOrConnectWithoutUserInput | SalaryInfoCreateOrConnectWithoutUserInput[]
    createMany?: SalaryInfoCreateManyUserInputEnvelope
    connect?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
  }

  export type ScopeCreateNestedOneWithoutUserInput = {
    create?: XOR<ScopeCreateWithoutUserInput, ScopeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ScopeCreateOrConnectWithoutUserInput
    connect?: ScopeWhereUniqueInput
  }

  export type TransactionInfoCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionInfoCreateWithoutUserInput, TransactionInfoUncheckedCreateWithoutUserInput> | TransactionInfoCreateWithoutUserInput[] | TransactionInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutUserInput | TransactionInfoCreateOrConnectWithoutUserInput[]
    createMany?: TransactionInfoCreateManyUserInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryCreateWithoutUserInput, InventoryUncheckedCreateWithoutUserInput> | InventoryCreateWithoutUserInput[] | InventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutUserInput | InventoryCreateOrConnectWithoutUserInput[]
    createMany?: InventoryCreateManyUserInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProductWiseTargetCreateWithoutUserInput, ProductWiseTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductWiseTargetCreateOrConnectWithoutUserInput
    connect?: ProductWiseTargetWhereUniqueInput
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EmployeeProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type LevesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LevesCreateWithoutUserInput, LevesUncheckedCreateWithoutUserInput> | LevesCreateWithoutUserInput[] | LevesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutUserInput | LevesCreateOrConnectWithoutUserInput[]
    createMany?: LevesCreateManyUserInputEnvelope
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
  }

  export type MpoTargetUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MpoTargetCreateWithoutUserInput, MpoTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: MpoTargetCreateOrConnectWithoutUserInput
    connect?: MpoTargetWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OvertimeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type SalaryInfoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryInfoCreateWithoutUserInput, SalaryInfoUncheckedCreateWithoutUserInput> | SalaryInfoCreateWithoutUserInput[] | SalaryInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryInfoCreateOrConnectWithoutUserInput | SalaryInfoCreateOrConnectWithoutUserInput[]
    createMany?: SalaryInfoCreateManyUserInputEnvelope
    connect?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
  }

  export type ScopeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ScopeCreateWithoutUserInput, ScopeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ScopeCreateOrConnectWithoutUserInput
    connect?: ScopeWhereUniqueInput
  }

  export type TransactionInfoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionInfoCreateWithoutUserInput, TransactionInfoUncheckedCreateWithoutUserInput> | TransactionInfoCreateWithoutUserInput[] | TransactionInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutUserInput | TransactionInfoCreateOrConnectWithoutUserInput[]
    createMany?: TransactionInfoCreateManyUserInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryCreateWithoutUserInput, InventoryUncheckedCreateWithoutUserInput> | InventoryCreateWithoutUserInput[] | InventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutUserInput | InventoryCreateOrConnectWithoutUserInput[]
    createMany?: InventoryCreateManyUserInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductWiseTargetUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProductWiseTargetCreateWithoutUserInput, ProductWiseTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductWiseTargetCreateOrConnectWithoutUserInput
    upsert?: ProductWiseTargetUpsertWithoutUserInput
    disconnect?: ProductWiseTargetWhereInput | boolean
    delete?: ProductWiseTargetWhereInput | boolean
    connect?: ProductWiseTargetWhereUniqueInput
    update?: XOR<XOR<ProductWiseTargetUpdateToOneWithWhereWithoutUserInput, ProductWiseTargetUpdateWithoutUserInput>, ProductWiseTargetUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EmployeeProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type LevesUpdateManyWithoutUserNestedInput = {
    create?: XOR<LevesCreateWithoutUserInput, LevesUncheckedCreateWithoutUserInput> | LevesCreateWithoutUserInput[] | LevesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutUserInput | LevesCreateOrConnectWithoutUserInput[]
    upsert?: LevesUpsertWithWhereUniqueWithoutUserInput | LevesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LevesCreateManyUserInputEnvelope
    set?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    disconnect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    delete?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    update?: LevesUpdateWithWhereUniqueWithoutUserInput | LevesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LevesUpdateManyWithWhereWithoutUserInput | LevesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LevesScalarWhereInput | LevesScalarWhereInput[]
  }

  export type MpoTargetUpdateOneWithoutUserNestedInput = {
    create?: XOR<MpoTargetCreateWithoutUserInput, MpoTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: MpoTargetCreateOrConnectWithoutUserInput
    upsert?: MpoTargetUpsertWithoutUserInput
    disconnect?: MpoTargetWhereInput | boolean
    delete?: MpoTargetWhereInput | boolean
    connect?: MpoTargetWhereUniqueInput
    update?: XOR<XOR<MpoTargetUpdateToOneWithWhereWithoutUserInput, MpoTargetUpdateWithoutUserInput>, MpoTargetUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OvertimeUpdateManyWithoutUserNestedInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutUserInput | OvertimeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutUserInput | OvertimeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutUserInput | OvertimeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutUserNestedInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutUserInput | PayrollUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutUserInput | PayrollUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutUserInput | PayrollUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type SalaryInfoUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryInfoCreateWithoutUserInput, SalaryInfoUncheckedCreateWithoutUserInput> | SalaryInfoCreateWithoutUserInput[] | SalaryInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryInfoCreateOrConnectWithoutUserInput | SalaryInfoCreateOrConnectWithoutUserInput[]
    upsert?: SalaryInfoUpsertWithWhereUniqueWithoutUserInput | SalaryInfoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryInfoCreateManyUserInputEnvelope
    set?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    disconnect?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    delete?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    connect?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    update?: SalaryInfoUpdateWithWhereUniqueWithoutUserInput | SalaryInfoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryInfoUpdateManyWithWhereWithoutUserInput | SalaryInfoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryInfoScalarWhereInput | SalaryInfoScalarWhereInput[]
  }

  export type ScopeUpdateOneWithoutUserNestedInput = {
    create?: XOR<ScopeCreateWithoutUserInput, ScopeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ScopeCreateOrConnectWithoutUserInput
    upsert?: ScopeUpsertWithoutUserInput
    disconnect?: ScopeWhereInput | boolean
    delete?: ScopeWhereInput | boolean
    connect?: ScopeWhereUniqueInput
    update?: XOR<XOR<ScopeUpdateToOneWithWhereWithoutUserInput, ScopeUpdateWithoutUserInput>, ScopeUncheckedUpdateWithoutUserInput>
  }

  export type TransactionInfoUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutUserInput, TransactionInfoUncheckedCreateWithoutUserInput> | TransactionInfoCreateWithoutUserInput[] | TransactionInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutUserInput | TransactionInfoCreateOrConnectWithoutUserInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutUserInput | TransactionInfoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionInfoCreateManyUserInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutUserInput | TransactionInfoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutUserInput | TransactionInfoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryCreateWithoutUserInput, InventoryUncheckedCreateWithoutUserInput> | InventoryCreateWithoutUserInput[] | InventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutUserInput | InventoryCreateOrConnectWithoutUserInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutUserInput | InventoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryCreateManyUserInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutUserInput | InventoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutUserInput | InventoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProductWiseTargetCreateWithoutUserInput, ProductWiseTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductWiseTargetCreateOrConnectWithoutUserInput
    upsert?: ProductWiseTargetUpsertWithoutUserInput
    disconnect?: ProductWiseTargetWhereInput | boolean
    delete?: ProductWiseTargetWhereInput | boolean
    connect?: ProductWiseTargetWhereUniqueInput
    update?: XOR<XOR<ProductWiseTargetUpdateToOneWithWhereWithoutUserInput, ProductWiseTargetUpdateWithoutUserInput>, ProductWiseTargetUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type LevesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LevesCreateWithoutUserInput, LevesUncheckedCreateWithoutUserInput> | LevesCreateWithoutUserInput[] | LevesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutUserInput | LevesCreateOrConnectWithoutUserInput[]
    upsert?: LevesUpsertWithWhereUniqueWithoutUserInput | LevesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LevesCreateManyUserInputEnvelope
    set?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    disconnect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    delete?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    update?: LevesUpdateWithWhereUniqueWithoutUserInput | LevesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LevesUpdateManyWithWhereWithoutUserInput | LevesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LevesScalarWhereInput | LevesScalarWhereInput[]
  }

  export type MpoTargetUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MpoTargetCreateWithoutUserInput, MpoTargetUncheckedCreateWithoutUserInput>
    connectOrCreate?: MpoTargetCreateOrConnectWithoutUserInput
    upsert?: MpoTargetUpsertWithoutUserInput
    disconnect?: MpoTargetWhereInput | boolean
    delete?: MpoTargetWhereInput | boolean
    connect?: MpoTargetWhereUniqueInput
    update?: XOR<XOR<MpoTargetUpdateToOneWithWhereWithoutUserInput, MpoTargetUpdateWithoutUserInput>, MpoTargetUncheckedUpdateWithoutUserInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OvertimeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutUserInput | OvertimeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutUserInput | OvertimeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutUserInput | OvertimeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput> | PayrollCreateWithoutUserInput[] | PayrollUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutUserInput | PayrollCreateOrConnectWithoutUserInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutUserInput | PayrollUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PayrollCreateManyUserInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutUserInput | PayrollUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutUserInput | PayrollUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type SalaryInfoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryInfoCreateWithoutUserInput, SalaryInfoUncheckedCreateWithoutUserInput> | SalaryInfoCreateWithoutUserInput[] | SalaryInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryInfoCreateOrConnectWithoutUserInput | SalaryInfoCreateOrConnectWithoutUserInput[]
    upsert?: SalaryInfoUpsertWithWhereUniqueWithoutUserInput | SalaryInfoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryInfoCreateManyUserInputEnvelope
    set?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    disconnect?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    delete?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    connect?: SalaryInfoWhereUniqueInput | SalaryInfoWhereUniqueInput[]
    update?: SalaryInfoUpdateWithWhereUniqueWithoutUserInput | SalaryInfoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryInfoUpdateManyWithWhereWithoutUserInput | SalaryInfoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryInfoScalarWhereInput | SalaryInfoScalarWhereInput[]
  }

  export type ScopeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ScopeCreateWithoutUserInput, ScopeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ScopeCreateOrConnectWithoutUserInput
    upsert?: ScopeUpsertWithoutUserInput
    disconnect?: ScopeWhereInput | boolean
    delete?: ScopeWhereInput | boolean
    connect?: ScopeWhereUniqueInput
    update?: XOR<XOR<ScopeUpdateToOneWithWhereWithoutUserInput, ScopeUpdateWithoutUserInput>, ScopeUncheckedUpdateWithoutUserInput>
  }

  export type TransactionInfoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutUserInput, TransactionInfoUncheckedCreateWithoutUserInput> | TransactionInfoCreateWithoutUserInput[] | TransactionInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutUserInput | TransactionInfoCreateOrConnectWithoutUserInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutUserInput | TransactionInfoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionInfoCreateManyUserInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutUserInput | TransactionInfoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutUserInput | TransactionInfoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryCreateWithoutUserInput, InventoryUncheckedCreateWithoutUserInput> | InventoryCreateWithoutUserInput[] | InventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutUserInput | InventoryCreateOrConnectWithoutUserInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutUserInput | InventoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryCreateManyUserInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutUserInput | InventoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutUserInput | InventoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeProfileInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmployeeProfileNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    upsert?: UserUpsertWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeProfileInput, UserUpdateWithoutEmployeeProfileInput>, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type DepoCreateNestedOneWithoutJobPostInput = {
    create?: XOR<DepoCreateWithoutJobPostInput, DepoUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: DepoCreateOrConnectWithoutJobPostInput
    connect?: DepoWhereUniqueInput
  }

  export type ScopeCreateNestedManyWithoutJobPostInput = {
    create?: XOR<ScopeCreateWithoutJobPostInput, ScopeUncheckedCreateWithoutJobPostInput> | ScopeCreateWithoutJobPostInput[] | ScopeUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutJobPostInput | ScopeCreateOrConnectWithoutJobPostInput[]
    createMany?: ScopeCreateManyJobPostInputEnvelope
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type ScopeUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<ScopeCreateWithoutJobPostInput, ScopeUncheckedCreateWithoutJobPostInput> | ScopeCreateWithoutJobPostInput[] | ScopeUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutJobPostInput | ScopeCreateOrConnectWithoutJobPostInput[]
    createMany?: ScopeCreateManyJobPostInputEnvelope
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DepoUpdateOneRequiredWithoutJobPostNestedInput = {
    create?: XOR<DepoCreateWithoutJobPostInput, DepoUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: DepoCreateOrConnectWithoutJobPostInput
    upsert?: DepoUpsertWithoutJobPostInput
    connect?: DepoWhereUniqueInput
    update?: XOR<XOR<DepoUpdateToOneWithWhereWithoutJobPostInput, DepoUpdateWithoutJobPostInput>, DepoUncheckedUpdateWithoutJobPostInput>
  }

  export type ScopeUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<ScopeCreateWithoutJobPostInput, ScopeUncheckedCreateWithoutJobPostInput> | ScopeCreateWithoutJobPostInput[] | ScopeUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutJobPostInput | ScopeCreateOrConnectWithoutJobPostInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutJobPostInput | ScopeUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: ScopeCreateManyJobPostInputEnvelope
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutJobPostInput | ScopeUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutJobPostInput | ScopeUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type ScopeUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<ScopeCreateWithoutJobPostInput, ScopeUncheckedCreateWithoutJobPostInput> | ScopeCreateWithoutJobPostInput[] | ScopeUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutJobPostInput | ScopeCreateOrConnectWithoutJobPostInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutJobPostInput | ScopeUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: ScopeCreateManyJobPostInputEnvelope
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutJobPostInput | ScopeUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutJobPostInput | ScopeUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type DepoCreateNestedOneWithoutChemistInput = {
    create?: XOR<DepoCreateWithoutChemistInput, DepoUncheckedCreateWithoutChemistInput>
    connectOrCreate?: DepoCreateOrConnectWithoutChemistInput
    connect?: DepoWhereUniqueInput
  }

  export type ScopeCreateNestedManyWithoutChemistInput = {
    create?: XOR<ScopeCreateWithoutChemistInput, ScopeUncheckedCreateWithoutChemistInput> | ScopeCreateWithoutChemistInput[] | ScopeUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutChemistInput | ScopeCreateOrConnectWithoutChemistInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type FixedJournalCreateNestedManyWithoutChemistInput = {
    create?: XOR<FixedJournalCreateWithoutChemistInput, FixedJournalUncheckedCreateWithoutChemistInput> | FixedJournalCreateWithoutChemistInput[] | FixedJournalUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutChemistInput | FixedJournalCreateOrConnectWithoutChemistInput[]
    createMany?: FixedJournalCreateManyChemistInputEnvelope
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutChemistInput = {
    create?: XOR<OrderCreateWithoutChemistInput, OrderUncheckedCreateWithoutChemistInput> | OrderCreateWithoutChemistInput[] | OrderUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutChemistInput | OrderCreateOrConnectWithoutChemistInput[]
    createMany?: OrderCreateManyChemistInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TransactionInfoCreateNestedManyWithoutChemistInput = {
    create?: XOR<TransactionInfoCreateWithoutChemistInput, TransactionInfoUncheckedCreateWithoutChemistInput> | TransactionInfoCreateWithoutChemistInput[] | TransactionInfoUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutChemistInput | TransactionInfoCreateOrConnectWithoutChemistInput[]
    createMany?: TransactionInfoCreateManyChemistInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type ScopeUncheckedCreateNestedManyWithoutChemistInput = {
    create?: XOR<ScopeCreateWithoutChemistInput, ScopeUncheckedCreateWithoutChemistInput> | ScopeCreateWithoutChemistInput[] | ScopeUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutChemistInput | ScopeCreateOrConnectWithoutChemistInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type FixedJournalUncheckedCreateNestedManyWithoutChemistInput = {
    create?: XOR<FixedJournalCreateWithoutChemistInput, FixedJournalUncheckedCreateWithoutChemistInput> | FixedJournalCreateWithoutChemistInput[] | FixedJournalUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutChemistInput | FixedJournalCreateOrConnectWithoutChemistInput[]
    createMany?: FixedJournalCreateManyChemistInputEnvelope
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutChemistInput = {
    create?: XOR<OrderCreateWithoutChemistInput, OrderUncheckedCreateWithoutChemistInput> | OrderCreateWithoutChemistInput[] | OrderUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutChemistInput | OrderCreateOrConnectWithoutChemistInput[]
    createMany?: OrderCreateManyChemistInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TransactionInfoUncheckedCreateNestedManyWithoutChemistInput = {
    create?: XOR<TransactionInfoCreateWithoutChemistInput, TransactionInfoUncheckedCreateWithoutChemistInput> | TransactionInfoCreateWithoutChemistInput[] | TransactionInfoUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutChemistInput | TransactionInfoCreateOrConnectWithoutChemistInput[]
    createMany?: TransactionInfoCreateManyChemistInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepoUpdateOneRequiredWithoutChemistNestedInput = {
    create?: XOR<DepoCreateWithoutChemistInput, DepoUncheckedCreateWithoutChemistInput>
    connectOrCreate?: DepoCreateOrConnectWithoutChemistInput
    upsert?: DepoUpsertWithoutChemistInput
    connect?: DepoWhereUniqueInput
    update?: XOR<XOR<DepoUpdateToOneWithWhereWithoutChemistInput, DepoUpdateWithoutChemistInput>, DepoUncheckedUpdateWithoutChemistInput>
  }

  export type ScopeUpdateManyWithoutChemistNestedInput = {
    create?: XOR<ScopeCreateWithoutChemistInput, ScopeUncheckedCreateWithoutChemistInput> | ScopeCreateWithoutChemistInput[] | ScopeUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutChemistInput | ScopeCreateOrConnectWithoutChemistInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutChemistInput | ScopeUpsertWithWhereUniqueWithoutChemistInput[]
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutChemistInput | ScopeUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutChemistInput | ScopeUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type FixedJournalUpdateManyWithoutChemistNestedInput = {
    create?: XOR<FixedJournalCreateWithoutChemistInput, FixedJournalUncheckedCreateWithoutChemistInput> | FixedJournalCreateWithoutChemistInput[] | FixedJournalUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutChemistInput | FixedJournalCreateOrConnectWithoutChemistInput[]
    upsert?: FixedJournalUpsertWithWhereUniqueWithoutChemistInput | FixedJournalUpsertWithWhereUniqueWithoutChemistInput[]
    createMany?: FixedJournalCreateManyChemistInputEnvelope
    set?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    disconnect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    delete?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    update?: FixedJournalUpdateWithWhereUniqueWithoutChemistInput | FixedJournalUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: FixedJournalUpdateManyWithWhereWithoutChemistInput | FixedJournalUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutChemistNestedInput = {
    create?: XOR<OrderCreateWithoutChemistInput, OrderUncheckedCreateWithoutChemistInput> | OrderCreateWithoutChemistInput[] | OrderUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutChemistInput | OrderCreateOrConnectWithoutChemistInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutChemistInput | OrderUpsertWithWhereUniqueWithoutChemistInput[]
    createMany?: OrderCreateManyChemistInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutChemistInput | OrderUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutChemistInput | OrderUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TransactionInfoUpdateManyWithoutChemistNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutChemistInput, TransactionInfoUncheckedCreateWithoutChemistInput> | TransactionInfoCreateWithoutChemistInput[] | TransactionInfoUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutChemistInput | TransactionInfoCreateOrConnectWithoutChemistInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutChemistInput | TransactionInfoUpsertWithWhereUniqueWithoutChemistInput[]
    createMany?: TransactionInfoCreateManyChemistInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutChemistInput | TransactionInfoUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutChemistInput | TransactionInfoUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type ScopeUncheckedUpdateManyWithoutChemistNestedInput = {
    create?: XOR<ScopeCreateWithoutChemistInput, ScopeUncheckedCreateWithoutChemistInput> | ScopeCreateWithoutChemistInput[] | ScopeUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutChemistInput | ScopeCreateOrConnectWithoutChemistInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutChemistInput | ScopeUpsertWithWhereUniqueWithoutChemistInput[]
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutChemistInput | ScopeUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutChemistInput | ScopeUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type FixedJournalUncheckedUpdateManyWithoutChemistNestedInput = {
    create?: XOR<FixedJournalCreateWithoutChemistInput, FixedJournalUncheckedCreateWithoutChemistInput> | FixedJournalCreateWithoutChemistInput[] | FixedJournalUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutChemistInput | FixedJournalCreateOrConnectWithoutChemistInput[]
    upsert?: FixedJournalUpsertWithWhereUniqueWithoutChemistInput | FixedJournalUpsertWithWhereUniqueWithoutChemistInput[]
    createMany?: FixedJournalCreateManyChemistInputEnvelope
    set?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    disconnect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    delete?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    update?: FixedJournalUpdateWithWhereUniqueWithoutChemistInput | FixedJournalUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: FixedJournalUpdateManyWithWhereWithoutChemistInput | FixedJournalUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutChemistNestedInput = {
    create?: XOR<OrderCreateWithoutChemistInput, OrderUncheckedCreateWithoutChemistInput> | OrderCreateWithoutChemistInput[] | OrderUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutChemistInput | OrderCreateOrConnectWithoutChemistInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutChemistInput | OrderUpsertWithWhereUniqueWithoutChemistInput[]
    createMany?: OrderCreateManyChemistInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutChemistInput | OrderUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutChemistInput | OrderUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TransactionInfoUncheckedUpdateManyWithoutChemistNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutChemistInput, TransactionInfoUncheckedCreateWithoutChemistInput> | TransactionInfoCreateWithoutChemistInput[] | TransactionInfoUncheckedCreateWithoutChemistInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutChemistInput | TransactionInfoCreateOrConnectWithoutChemistInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutChemistInput | TransactionInfoUpsertWithWhereUniqueWithoutChemistInput[]
    createMany?: TransactionInfoCreateManyChemistInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutChemistInput | TransactionInfoUpdateWithWhereUniqueWithoutChemistInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutChemistInput | TransactionInfoUpdateManyWithWhereWithoutChemistInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type ChemistCreateNestedManyWithoutDepoInput = {
    create?: XOR<ChemistCreateWithoutDepoInput, ChemistUncheckedCreateWithoutDepoInput> | ChemistCreateWithoutDepoInput[] | ChemistUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutDepoInput | ChemistCreateOrConnectWithoutDepoInput[]
    createMany?: ChemistCreateManyDepoInputEnvelope
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
  }

  export type FixedJournalCreateNestedManyWithoutDepoInput = {
    create?: XOR<FixedJournalCreateWithoutDepoInput, FixedJournalUncheckedCreateWithoutDepoInput> | FixedJournalCreateWithoutDepoInput[] | FixedJournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutDepoInput | FixedJournalCreateOrConnectWithoutDepoInput[]
    createMany?: FixedJournalCreateManyDepoInputEnvelope
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutDepoInput = {
    create?: XOR<InventoryCreateWithoutDepoInput, InventoryUncheckedCreateWithoutDepoInput> | InventoryCreateWithoutDepoInput[] | InventoryUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutDepoInput | InventoryCreateOrConnectWithoutDepoInput[]
    createMany?: InventoryCreateManyDepoInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type JobPostCreateNestedManyWithoutDepoInput = {
    create?: XOR<JobPostCreateWithoutDepoInput, JobPostUncheckedCreateWithoutDepoInput> | JobPostCreateWithoutDepoInput[] | JobPostUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepoInput | JobPostCreateOrConnectWithoutDepoInput[]
    createMany?: JobPostCreateManyDepoInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type JournalCreateNestedManyWithoutDepoInput = {
    create?: XOR<JournalCreateWithoutDepoInput, JournalUncheckedCreateWithoutDepoInput> | JournalCreateWithoutDepoInput[] | JournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutDepoInput | JournalCreateOrConnectWithoutDepoInput[]
    createMany?: JournalCreateManyDepoInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type ScopeCreateNestedManyWithoutDepoInput = {
    create?: XOR<ScopeCreateWithoutDepoInput, ScopeUncheckedCreateWithoutDepoInput> | ScopeCreateWithoutDepoInput[] | ScopeUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutDepoInput | ScopeCreateOrConnectWithoutDepoInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type ChemistUncheckedCreateNestedManyWithoutDepoInput = {
    create?: XOR<ChemistCreateWithoutDepoInput, ChemistUncheckedCreateWithoutDepoInput> | ChemistCreateWithoutDepoInput[] | ChemistUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutDepoInput | ChemistCreateOrConnectWithoutDepoInput[]
    createMany?: ChemistCreateManyDepoInputEnvelope
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
  }

  export type FixedJournalUncheckedCreateNestedManyWithoutDepoInput = {
    create?: XOR<FixedJournalCreateWithoutDepoInput, FixedJournalUncheckedCreateWithoutDepoInput> | FixedJournalCreateWithoutDepoInput[] | FixedJournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutDepoInput | FixedJournalCreateOrConnectWithoutDepoInput[]
    createMany?: FixedJournalCreateManyDepoInputEnvelope
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutDepoInput = {
    create?: XOR<InventoryCreateWithoutDepoInput, InventoryUncheckedCreateWithoutDepoInput> | InventoryCreateWithoutDepoInput[] | InventoryUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutDepoInput | InventoryCreateOrConnectWithoutDepoInput[]
    createMany?: InventoryCreateManyDepoInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type JobPostUncheckedCreateNestedManyWithoutDepoInput = {
    create?: XOR<JobPostCreateWithoutDepoInput, JobPostUncheckedCreateWithoutDepoInput> | JobPostCreateWithoutDepoInput[] | JobPostUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepoInput | JobPostCreateOrConnectWithoutDepoInput[]
    createMany?: JobPostCreateManyDepoInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type JournalUncheckedCreateNestedManyWithoutDepoInput = {
    create?: XOR<JournalCreateWithoutDepoInput, JournalUncheckedCreateWithoutDepoInput> | JournalCreateWithoutDepoInput[] | JournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutDepoInput | JournalCreateOrConnectWithoutDepoInput[]
    createMany?: JournalCreateManyDepoInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type ScopeUncheckedCreateNestedManyWithoutDepoInput = {
    create?: XOR<ScopeCreateWithoutDepoInput, ScopeUncheckedCreateWithoutDepoInput> | ScopeCreateWithoutDepoInput[] | ScopeUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutDepoInput | ScopeCreateOrConnectWithoutDepoInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type ChemistUpdateManyWithoutDepoNestedInput = {
    create?: XOR<ChemistCreateWithoutDepoInput, ChemistUncheckedCreateWithoutDepoInput> | ChemistCreateWithoutDepoInput[] | ChemistUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutDepoInput | ChemistCreateOrConnectWithoutDepoInput[]
    upsert?: ChemistUpsertWithWhereUniqueWithoutDepoInput | ChemistUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: ChemistCreateManyDepoInputEnvelope
    set?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    disconnect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    delete?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    update?: ChemistUpdateWithWhereUniqueWithoutDepoInput | ChemistUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: ChemistUpdateManyWithWhereWithoutDepoInput | ChemistUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: ChemistScalarWhereInput | ChemistScalarWhereInput[]
  }

  export type FixedJournalUpdateManyWithoutDepoNestedInput = {
    create?: XOR<FixedJournalCreateWithoutDepoInput, FixedJournalUncheckedCreateWithoutDepoInput> | FixedJournalCreateWithoutDepoInput[] | FixedJournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutDepoInput | FixedJournalCreateOrConnectWithoutDepoInput[]
    upsert?: FixedJournalUpsertWithWhereUniqueWithoutDepoInput | FixedJournalUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: FixedJournalCreateManyDepoInputEnvelope
    set?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    disconnect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    delete?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    update?: FixedJournalUpdateWithWhereUniqueWithoutDepoInput | FixedJournalUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: FixedJournalUpdateManyWithWhereWithoutDepoInput | FixedJournalUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutDepoNestedInput = {
    create?: XOR<InventoryCreateWithoutDepoInput, InventoryUncheckedCreateWithoutDepoInput> | InventoryCreateWithoutDepoInput[] | InventoryUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutDepoInput | InventoryCreateOrConnectWithoutDepoInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutDepoInput | InventoryUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: InventoryCreateManyDepoInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutDepoInput | InventoryUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutDepoInput | InventoryUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type JobPostUpdateManyWithoutDepoNestedInput = {
    create?: XOR<JobPostCreateWithoutDepoInput, JobPostUncheckedCreateWithoutDepoInput> | JobPostCreateWithoutDepoInput[] | JobPostUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepoInput | JobPostCreateOrConnectWithoutDepoInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutDepoInput | JobPostUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: JobPostCreateManyDepoInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutDepoInput | JobPostUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutDepoInput | JobPostUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type JournalUpdateManyWithoutDepoNestedInput = {
    create?: XOR<JournalCreateWithoutDepoInput, JournalUncheckedCreateWithoutDepoInput> | JournalCreateWithoutDepoInput[] | JournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutDepoInput | JournalCreateOrConnectWithoutDepoInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutDepoInput | JournalUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: JournalCreateManyDepoInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutDepoInput | JournalUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutDepoInput | JournalUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type ScopeUpdateManyWithoutDepoNestedInput = {
    create?: XOR<ScopeCreateWithoutDepoInput, ScopeUncheckedCreateWithoutDepoInput> | ScopeCreateWithoutDepoInput[] | ScopeUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutDepoInput | ScopeCreateOrConnectWithoutDepoInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutDepoInput | ScopeUpsertWithWhereUniqueWithoutDepoInput[]
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutDepoInput | ScopeUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutDepoInput | ScopeUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type ChemistUncheckedUpdateManyWithoutDepoNestedInput = {
    create?: XOR<ChemistCreateWithoutDepoInput, ChemistUncheckedCreateWithoutDepoInput> | ChemistCreateWithoutDepoInput[] | ChemistUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutDepoInput | ChemistCreateOrConnectWithoutDepoInput[]
    upsert?: ChemistUpsertWithWhereUniqueWithoutDepoInput | ChemistUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: ChemistCreateManyDepoInputEnvelope
    set?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    disconnect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    delete?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    update?: ChemistUpdateWithWhereUniqueWithoutDepoInput | ChemistUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: ChemistUpdateManyWithWhereWithoutDepoInput | ChemistUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: ChemistScalarWhereInput | ChemistScalarWhereInput[]
  }

  export type FixedJournalUncheckedUpdateManyWithoutDepoNestedInput = {
    create?: XOR<FixedJournalCreateWithoutDepoInput, FixedJournalUncheckedCreateWithoutDepoInput> | FixedJournalCreateWithoutDepoInput[] | FixedJournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutDepoInput | FixedJournalCreateOrConnectWithoutDepoInput[]
    upsert?: FixedJournalUpsertWithWhereUniqueWithoutDepoInput | FixedJournalUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: FixedJournalCreateManyDepoInputEnvelope
    set?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    disconnect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    delete?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    update?: FixedJournalUpdateWithWhereUniqueWithoutDepoInput | FixedJournalUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: FixedJournalUpdateManyWithWhereWithoutDepoInput | FixedJournalUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutDepoNestedInput = {
    create?: XOR<InventoryCreateWithoutDepoInput, InventoryUncheckedCreateWithoutDepoInput> | InventoryCreateWithoutDepoInput[] | InventoryUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutDepoInput | InventoryCreateOrConnectWithoutDepoInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutDepoInput | InventoryUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: InventoryCreateManyDepoInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutDepoInput | InventoryUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutDepoInput | InventoryUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type JobPostUncheckedUpdateManyWithoutDepoNestedInput = {
    create?: XOR<JobPostCreateWithoutDepoInput, JobPostUncheckedCreateWithoutDepoInput> | JobPostCreateWithoutDepoInput[] | JobPostUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutDepoInput | JobPostCreateOrConnectWithoutDepoInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutDepoInput | JobPostUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: JobPostCreateManyDepoInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutDepoInput | JobPostUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutDepoInput | JobPostUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type JournalUncheckedUpdateManyWithoutDepoNestedInput = {
    create?: XOR<JournalCreateWithoutDepoInput, JournalUncheckedCreateWithoutDepoInput> | JournalCreateWithoutDepoInput[] | JournalUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutDepoInput | JournalCreateOrConnectWithoutDepoInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutDepoInput | JournalUpsertWithWhereUniqueWithoutDepoInput[]
    createMany?: JournalCreateManyDepoInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutDepoInput | JournalUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutDepoInput | JournalUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type ScopeUncheckedUpdateManyWithoutDepoNestedInput = {
    create?: XOR<ScopeCreateWithoutDepoInput, ScopeUncheckedCreateWithoutDepoInput> | ScopeCreateWithoutDepoInput[] | ScopeUncheckedCreateWithoutDepoInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutDepoInput | ScopeCreateOrConnectWithoutDepoInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutDepoInput | ScopeUpsertWithWhereUniqueWithoutDepoInput[]
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutDepoInput | ScopeUpdateWithWhereUniqueWithoutDepoInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutDepoInput | ScopeUpdateManyWithWhereWithoutDepoInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type TransactionInfoCreateNestedManyWithoutPartyInput = {
    create?: XOR<TransactionInfoCreateWithoutPartyInput, TransactionInfoUncheckedCreateWithoutPartyInput> | TransactionInfoCreateWithoutPartyInput[] | TransactionInfoUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutPartyInput | TransactionInfoCreateOrConnectWithoutPartyInput[]
    createMany?: TransactionInfoCreateManyPartyInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type TransactionInfoUncheckedCreateNestedManyWithoutPartyInput = {
    create?: XOR<TransactionInfoCreateWithoutPartyInput, TransactionInfoUncheckedCreateWithoutPartyInput> | TransactionInfoCreateWithoutPartyInput[] | TransactionInfoUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutPartyInput | TransactionInfoCreateOrConnectWithoutPartyInput[]
    createMany?: TransactionInfoCreateManyPartyInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type EnumPartyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PartyType
  }

  export type TransactionInfoUpdateManyWithoutPartyNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutPartyInput, TransactionInfoUncheckedCreateWithoutPartyInput> | TransactionInfoCreateWithoutPartyInput[] | TransactionInfoUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutPartyInput | TransactionInfoCreateOrConnectWithoutPartyInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutPartyInput | TransactionInfoUpsertWithWhereUniqueWithoutPartyInput[]
    createMany?: TransactionInfoCreateManyPartyInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutPartyInput | TransactionInfoUpdateWithWhereUniqueWithoutPartyInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutPartyInput | TransactionInfoUpdateManyWithWhereWithoutPartyInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type TransactionInfoUncheckedUpdateManyWithoutPartyNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutPartyInput, TransactionInfoUncheckedCreateWithoutPartyInput> | TransactionInfoCreateWithoutPartyInput[] | TransactionInfoUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutPartyInput | TransactionInfoCreateOrConnectWithoutPartyInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutPartyInput | TransactionInfoUpsertWithWhereUniqueWithoutPartyInput[]
    createMany?: TransactionInfoCreateManyPartyInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutPartyInput | TransactionInfoUpdateWithWhereUniqueWithoutPartyInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutPartyInput | TransactionInfoUpdateManyWithWhereWithoutPartyInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<ProductCreateWithoutStakeholderInput, ProductUncheckedCreateWithoutStakeholderInput> | ProductCreateWithoutStakeholderInput[] | ProductUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStakeholderInput | ProductCreateOrConnectWithoutStakeholderInput[]
    createMany?: ProductCreateManyStakeholderInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type StakeholderDegreeCreateNestedOneWithoutStakeholderInput = {
    create?: XOR<StakeholderDegreeCreateWithoutStakeholderInput, StakeholderDegreeUncheckedCreateWithoutStakeholderInput>
    connectOrCreate?: StakeholderDegreeCreateOrConnectWithoutStakeholderInput
    connect?: StakeholderDegreeWhereUniqueInput
  }

  export type StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput = {
    create?: XOR<StakeholderDeisgnationCreateWithoutStakeholderInput, StakeholderDeisgnationUncheckedCreateWithoutStakeholderInput>
    connectOrCreate?: StakeholderDeisgnationCreateOrConnectWithoutStakeholderInput
    connect?: StakeholderDeisgnationWhereUniqueInput
  }

  export type ScopeCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<ScopeCreateWithoutStakeholderInput, ScopeUncheckedCreateWithoutStakeholderInput> | ScopeCreateWithoutStakeholderInput[] | ScopeUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutStakeholderInput | ScopeCreateOrConnectWithoutStakeholderInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type stakeholderChemberCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<stakeholderChemberCreateWithoutStakeholderInput, stakeholderChemberUncheckedCreateWithoutStakeholderInput> | stakeholderChemberCreateWithoutStakeholderInput[] | stakeholderChemberUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: stakeholderChemberCreateOrConnectWithoutStakeholderInput | stakeholderChemberCreateOrConnectWithoutStakeholderInput[]
    createMany?: stakeholderChemberCreateManyStakeholderInputEnvelope
    connect?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
  }

  export type StakeholderOcationCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<StakeholderOcationCreateWithoutStakeholderInput, StakeholderOcationUncheckedCreateWithoutStakeholderInput> | StakeholderOcationCreateWithoutStakeholderInput[] | StakeholderOcationUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: StakeholderOcationCreateOrConnectWithoutStakeholderInput | StakeholderOcationCreateOrConnectWithoutStakeholderInput[]
    createMany?: StakeholderOcationCreateManyStakeholderInputEnvelope
    connect?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
  }

  export type TransactionInfoCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<TransactionInfoCreateWithoutStakeholderInput, TransactionInfoUncheckedCreateWithoutStakeholderInput> | TransactionInfoCreateWithoutStakeholderInput[] | TransactionInfoUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutStakeholderInput | TransactionInfoCreateOrConnectWithoutStakeholderInput[]
    createMany?: TransactionInfoCreateManyStakeholderInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<ProductCreateWithoutStakeholderInput, ProductUncheckedCreateWithoutStakeholderInput> | ProductCreateWithoutStakeholderInput[] | ProductUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStakeholderInput | ProductCreateOrConnectWithoutStakeholderInput[]
    createMany?: ProductCreateManyStakeholderInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ScopeUncheckedCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<ScopeCreateWithoutStakeholderInput, ScopeUncheckedCreateWithoutStakeholderInput> | ScopeCreateWithoutStakeholderInput[] | ScopeUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutStakeholderInput | ScopeCreateOrConnectWithoutStakeholderInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
  }

  export type stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<stakeholderChemberCreateWithoutStakeholderInput, stakeholderChemberUncheckedCreateWithoutStakeholderInput> | stakeholderChemberCreateWithoutStakeholderInput[] | stakeholderChemberUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: stakeholderChemberCreateOrConnectWithoutStakeholderInput | stakeholderChemberCreateOrConnectWithoutStakeholderInput[]
    createMany?: stakeholderChemberCreateManyStakeholderInputEnvelope
    connect?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
  }

  export type StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<StakeholderOcationCreateWithoutStakeholderInput, StakeholderOcationUncheckedCreateWithoutStakeholderInput> | StakeholderOcationCreateWithoutStakeholderInput[] | StakeholderOcationUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: StakeholderOcationCreateOrConnectWithoutStakeholderInput | StakeholderOcationCreateOrConnectWithoutStakeholderInput[]
    createMany?: StakeholderOcationCreateManyStakeholderInputEnvelope
    connect?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
  }

  export type TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput = {
    create?: XOR<TransactionInfoCreateWithoutStakeholderInput, TransactionInfoUncheckedCreateWithoutStakeholderInput> | TransactionInfoCreateWithoutStakeholderInput[] | TransactionInfoUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutStakeholderInput | TransactionInfoCreateOrConnectWithoutStakeholderInput[]
    createMany?: TransactionInfoCreateManyStakeholderInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<ProductCreateWithoutStakeholderInput, ProductUncheckedCreateWithoutStakeholderInput> | ProductCreateWithoutStakeholderInput[] | ProductUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStakeholderInput | ProductCreateOrConnectWithoutStakeholderInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStakeholderInput | ProductUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: ProductCreateManyStakeholderInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStakeholderInput | ProductUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStakeholderInput | ProductUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput = {
    create?: XOR<StakeholderDegreeCreateWithoutStakeholderInput, StakeholderDegreeUncheckedCreateWithoutStakeholderInput>
    connectOrCreate?: StakeholderDegreeCreateOrConnectWithoutStakeholderInput
    upsert?: StakeholderDegreeUpsertWithoutStakeholderInput
    connect?: StakeholderDegreeWhereUniqueInput
    update?: XOR<XOR<StakeholderDegreeUpdateToOneWithWhereWithoutStakeholderInput, StakeholderDegreeUpdateWithoutStakeholderInput>, StakeholderDegreeUncheckedUpdateWithoutStakeholderInput>
  }

  export type StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput = {
    create?: XOR<StakeholderDeisgnationCreateWithoutStakeholderInput, StakeholderDeisgnationUncheckedCreateWithoutStakeholderInput>
    connectOrCreate?: StakeholderDeisgnationCreateOrConnectWithoutStakeholderInput
    upsert?: StakeholderDeisgnationUpsertWithoutStakeholderInput
    connect?: StakeholderDeisgnationWhereUniqueInput
    update?: XOR<XOR<StakeholderDeisgnationUpdateToOneWithWhereWithoutStakeholderInput, StakeholderDeisgnationUpdateWithoutStakeholderInput>, StakeholderDeisgnationUncheckedUpdateWithoutStakeholderInput>
  }

  export type ScopeUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<ScopeCreateWithoutStakeholderInput, ScopeUncheckedCreateWithoutStakeholderInput> | ScopeCreateWithoutStakeholderInput[] | ScopeUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutStakeholderInput | ScopeCreateOrConnectWithoutStakeholderInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutStakeholderInput | ScopeUpsertWithWhereUniqueWithoutStakeholderInput[]
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutStakeholderInput | ScopeUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutStakeholderInput | ScopeUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type stakeholderChemberUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<stakeholderChemberCreateWithoutStakeholderInput, stakeholderChemberUncheckedCreateWithoutStakeholderInput> | stakeholderChemberCreateWithoutStakeholderInput[] | stakeholderChemberUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: stakeholderChemberCreateOrConnectWithoutStakeholderInput | stakeholderChemberCreateOrConnectWithoutStakeholderInput[]
    upsert?: stakeholderChemberUpsertWithWhereUniqueWithoutStakeholderInput | stakeholderChemberUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: stakeholderChemberCreateManyStakeholderInputEnvelope
    set?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    disconnect?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    delete?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    connect?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    update?: stakeholderChemberUpdateWithWhereUniqueWithoutStakeholderInput | stakeholderChemberUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: stakeholderChemberUpdateManyWithWhereWithoutStakeholderInput | stakeholderChemberUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: stakeholderChemberScalarWhereInput | stakeholderChemberScalarWhereInput[]
  }

  export type StakeholderOcationUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<StakeholderOcationCreateWithoutStakeholderInput, StakeholderOcationUncheckedCreateWithoutStakeholderInput> | StakeholderOcationCreateWithoutStakeholderInput[] | StakeholderOcationUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: StakeholderOcationCreateOrConnectWithoutStakeholderInput | StakeholderOcationCreateOrConnectWithoutStakeholderInput[]
    upsert?: StakeholderOcationUpsertWithWhereUniqueWithoutStakeholderInput | StakeholderOcationUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: StakeholderOcationCreateManyStakeholderInputEnvelope
    set?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    disconnect?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    delete?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    connect?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    update?: StakeholderOcationUpdateWithWhereUniqueWithoutStakeholderInput | StakeholderOcationUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: StakeholderOcationUpdateManyWithWhereWithoutStakeholderInput | StakeholderOcationUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: StakeholderOcationScalarWhereInput | StakeholderOcationScalarWhereInput[]
  }

  export type TransactionInfoUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutStakeholderInput, TransactionInfoUncheckedCreateWithoutStakeholderInput> | TransactionInfoCreateWithoutStakeholderInput[] | TransactionInfoUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutStakeholderInput | TransactionInfoCreateOrConnectWithoutStakeholderInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutStakeholderInput | TransactionInfoUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: TransactionInfoCreateManyStakeholderInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutStakeholderInput | TransactionInfoUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutStakeholderInput | TransactionInfoUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<ProductCreateWithoutStakeholderInput, ProductUncheckedCreateWithoutStakeholderInput> | ProductCreateWithoutStakeholderInput[] | ProductUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStakeholderInput | ProductCreateOrConnectWithoutStakeholderInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStakeholderInput | ProductUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: ProductCreateManyStakeholderInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStakeholderInput | ProductUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStakeholderInput | ProductUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ScopeUncheckedUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<ScopeCreateWithoutStakeholderInput, ScopeUncheckedCreateWithoutStakeholderInput> | ScopeCreateWithoutStakeholderInput[] | ScopeUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: ScopeCreateOrConnectWithoutStakeholderInput | ScopeCreateOrConnectWithoutStakeholderInput[]
    upsert?: ScopeUpsertWithWhereUniqueWithoutStakeholderInput | ScopeUpsertWithWhereUniqueWithoutStakeholderInput[]
    set?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    disconnect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    delete?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    connect?: ScopeWhereUniqueInput | ScopeWhereUniqueInput[]
    update?: ScopeUpdateWithWhereUniqueWithoutStakeholderInput | ScopeUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: ScopeUpdateManyWithWhereWithoutStakeholderInput | ScopeUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
  }

  export type stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<stakeholderChemberCreateWithoutStakeholderInput, stakeholderChemberUncheckedCreateWithoutStakeholderInput> | stakeholderChemberCreateWithoutStakeholderInput[] | stakeholderChemberUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: stakeholderChemberCreateOrConnectWithoutStakeholderInput | stakeholderChemberCreateOrConnectWithoutStakeholderInput[]
    upsert?: stakeholderChemberUpsertWithWhereUniqueWithoutStakeholderInput | stakeholderChemberUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: stakeholderChemberCreateManyStakeholderInputEnvelope
    set?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    disconnect?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    delete?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    connect?: stakeholderChemberWhereUniqueInput | stakeholderChemberWhereUniqueInput[]
    update?: stakeholderChemberUpdateWithWhereUniqueWithoutStakeholderInput | stakeholderChemberUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: stakeholderChemberUpdateManyWithWhereWithoutStakeholderInput | stakeholderChemberUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: stakeholderChemberScalarWhereInput | stakeholderChemberScalarWhereInput[]
  }

  export type StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<StakeholderOcationCreateWithoutStakeholderInput, StakeholderOcationUncheckedCreateWithoutStakeholderInput> | StakeholderOcationCreateWithoutStakeholderInput[] | StakeholderOcationUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: StakeholderOcationCreateOrConnectWithoutStakeholderInput | StakeholderOcationCreateOrConnectWithoutStakeholderInput[]
    upsert?: StakeholderOcationUpsertWithWhereUniqueWithoutStakeholderInput | StakeholderOcationUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: StakeholderOcationCreateManyStakeholderInputEnvelope
    set?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    disconnect?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    delete?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    connect?: StakeholderOcationWhereUniqueInput | StakeholderOcationWhereUniqueInput[]
    update?: StakeholderOcationUpdateWithWhereUniqueWithoutStakeholderInput | StakeholderOcationUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: StakeholderOcationUpdateManyWithWhereWithoutStakeholderInput | StakeholderOcationUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: StakeholderOcationScalarWhereInput | StakeholderOcationScalarWhereInput[]
  }

  export type TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutStakeholderInput, TransactionInfoUncheckedCreateWithoutStakeholderInput> | TransactionInfoCreateWithoutStakeholderInput[] | TransactionInfoUncheckedCreateWithoutStakeholderInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutStakeholderInput | TransactionInfoCreateOrConnectWithoutStakeholderInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutStakeholderInput | TransactionInfoUpsertWithWhereUniqueWithoutStakeholderInput[]
    createMany?: TransactionInfoCreateManyStakeholderInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutStakeholderInput | TransactionInfoUpdateWithWhereUniqueWithoutStakeholderInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutStakeholderInput | TransactionInfoUpdateManyWithWhereWithoutStakeholderInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type StakeholderCreateNestedManyWithoutStakeholderDeisgnationInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDeisgnationInput, StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput> | StakeholderCreateWithoutStakeholderDeisgnationInput[] | StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput | StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput[]
    createMany?: StakeholderCreateManyStakeholderDeisgnationInputEnvelope
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
  }

  export type StakeholderUncheckedCreateNestedManyWithoutStakeholderDeisgnationInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDeisgnationInput, StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput> | StakeholderCreateWithoutStakeholderDeisgnationInput[] | StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput | StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput[]
    createMany?: StakeholderCreateManyStakeholderDeisgnationInputEnvelope
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
  }

  export type StakeholderUpdateManyWithoutStakeholderDeisgnationNestedInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDeisgnationInput, StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput> | StakeholderCreateWithoutStakeholderDeisgnationInput[] | StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput | StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput[]
    upsert?: StakeholderUpsertWithWhereUniqueWithoutStakeholderDeisgnationInput | StakeholderUpsertWithWhereUniqueWithoutStakeholderDeisgnationInput[]
    createMany?: StakeholderCreateManyStakeholderDeisgnationInputEnvelope
    set?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    disconnect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    delete?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    update?: StakeholderUpdateWithWhereUniqueWithoutStakeholderDeisgnationInput | StakeholderUpdateWithWhereUniqueWithoutStakeholderDeisgnationInput[]
    updateMany?: StakeholderUpdateManyWithWhereWithoutStakeholderDeisgnationInput | StakeholderUpdateManyWithWhereWithoutStakeholderDeisgnationInput[]
    deleteMany?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
  }

  export type StakeholderUncheckedUpdateManyWithoutStakeholderDeisgnationNestedInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDeisgnationInput, StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput> | StakeholderCreateWithoutStakeholderDeisgnationInput[] | StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput | StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput[]
    upsert?: StakeholderUpsertWithWhereUniqueWithoutStakeholderDeisgnationInput | StakeholderUpsertWithWhereUniqueWithoutStakeholderDeisgnationInput[]
    createMany?: StakeholderCreateManyStakeholderDeisgnationInputEnvelope
    set?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    disconnect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    delete?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    update?: StakeholderUpdateWithWhereUniqueWithoutStakeholderDeisgnationInput | StakeholderUpdateWithWhereUniqueWithoutStakeholderDeisgnationInput[]
    updateMany?: StakeholderUpdateManyWithWhereWithoutStakeholderDeisgnationInput | StakeholderUpdateManyWithWhereWithoutStakeholderDeisgnationInput[]
    deleteMany?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
  }

  export type StakeholderCreateNestedManyWithoutStakeholderDegreeInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDegreeInput, StakeholderUncheckedCreateWithoutStakeholderDegreeInput> | StakeholderCreateWithoutStakeholderDegreeInput[] | StakeholderUncheckedCreateWithoutStakeholderDegreeInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDegreeInput | StakeholderCreateOrConnectWithoutStakeholderDegreeInput[]
    createMany?: StakeholderCreateManyStakeholderDegreeInputEnvelope
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
  }

  export type StakeholderUncheckedCreateNestedManyWithoutStakeholderDegreeInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDegreeInput, StakeholderUncheckedCreateWithoutStakeholderDegreeInput> | StakeholderCreateWithoutStakeholderDegreeInput[] | StakeholderUncheckedCreateWithoutStakeholderDegreeInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDegreeInput | StakeholderCreateOrConnectWithoutStakeholderDegreeInput[]
    createMany?: StakeholderCreateManyStakeholderDegreeInputEnvelope
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
  }

  export type StakeholderUpdateManyWithoutStakeholderDegreeNestedInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDegreeInput, StakeholderUncheckedCreateWithoutStakeholderDegreeInput> | StakeholderCreateWithoutStakeholderDegreeInput[] | StakeholderUncheckedCreateWithoutStakeholderDegreeInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDegreeInput | StakeholderCreateOrConnectWithoutStakeholderDegreeInput[]
    upsert?: StakeholderUpsertWithWhereUniqueWithoutStakeholderDegreeInput | StakeholderUpsertWithWhereUniqueWithoutStakeholderDegreeInput[]
    createMany?: StakeholderCreateManyStakeholderDegreeInputEnvelope
    set?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    disconnect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    delete?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    update?: StakeholderUpdateWithWhereUniqueWithoutStakeholderDegreeInput | StakeholderUpdateWithWhereUniqueWithoutStakeholderDegreeInput[]
    updateMany?: StakeholderUpdateManyWithWhereWithoutStakeholderDegreeInput | StakeholderUpdateManyWithWhereWithoutStakeholderDegreeInput[]
    deleteMany?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
  }

  export type StakeholderUncheckedUpdateManyWithoutStakeholderDegreeNestedInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderDegreeInput, StakeholderUncheckedCreateWithoutStakeholderDegreeInput> | StakeholderCreateWithoutStakeholderDegreeInput[] | StakeholderUncheckedCreateWithoutStakeholderDegreeInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderDegreeInput | StakeholderCreateOrConnectWithoutStakeholderDegreeInput[]
    upsert?: StakeholderUpsertWithWhereUniqueWithoutStakeholderDegreeInput | StakeholderUpsertWithWhereUniqueWithoutStakeholderDegreeInput[]
    createMany?: StakeholderCreateManyStakeholderDegreeInputEnvelope
    set?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    disconnect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    delete?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    update?: StakeholderUpdateWithWhereUniqueWithoutStakeholderDegreeInput | StakeholderUpdateWithWhereUniqueWithoutStakeholderDegreeInput[]
    updateMany?: StakeholderUpdateManyWithWhereWithoutStakeholderDegreeInput | StakeholderUpdateManyWithWhereWithoutStakeholderDegreeInput[]
    deleteMany?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
  }

  export type StakeholderCreateNestedOneWithoutStakeholderChemberInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderChemberInput, StakeholderUncheckedCreateWithoutStakeholderChemberInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderChemberInput
    connect?: StakeholderWhereUniqueInput
  }

  export type StakeholderUpdateOneWithoutStakeholderChemberNestedInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderChemberInput, StakeholderUncheckedCreateWithoutStakeholderChemberInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderChemberInput
    upsert?: StakeholderUpsertWithoutStakeholderChemberInput
    disconnect?: StakeholderWhereInput | boolean
    delete?: StakeholderWhereInput | boolean
    connect?: StakeholderWhereUniqueInput
    update?: XOR<XOR<StakeholderUpdateToOneWithWhereWithoutStakeholderChemberInput, StakeholderUpdateWithoutStakeholderChemberInput>, StakeholderUncheckedUpdateWithoutStakeholderChemberInput>
  }

  export type StakeholderCreateNestedOneWithoutStakeholderOcationInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderOcationInput, StakeholderUncheckedCreateWithoutStakeholderOcationInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderOcationInput
    connect?: StakeholderWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StakeholderUpdateOneRequiredWithoutStakeholderOcationNestedInput = {
    create?: XOR<StakeholderCreateWithoutStakeholderOcationInput, StakeholderUncheckedCreateWithoutStakeholderOcationInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutStakeholderOcationInput
    upsert?: StakeholderUpsertWithoutStakeholderOcationInput
    connect?: StakeholderWhereUniqueInput
    update?: XOR<XOR<StakeholderUpdateToOneWithWhereWithoutStakeholderOcationInput, StakeholderUpdateWithoutStakeholderOcationInput>, StakeholderUncheckedUpdateWithoutStakeholderOcationInput>
  }

  export type TransactionInfoCreateNestedManyWithoutCustomersInput = {
    create?: XOR<TransactionInfoCreateWithoutCustomersInput, TransactionInfoUncheckedCreateWithoutCustomersInput> | TransactionInfoCreateWithoutCustomersInput[] | TransactionInfoUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutCustomersInput | TransactionInfoCreateOrConnectWithoutCustomersInput[]
    createMany?: TransactionInfoCreateManyCustomersInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type TransactionInfoUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<TransactionInfoCreateWithoutCustomersInput, TransactionInfoUncheckedCreateWithoutCustomersInput> | TransactionInfoCreateWithoutCustomersInput[] | TransactionInfoUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutCustomersInput | TransactionInfoCreateOrConnectWithoutCustomersInput[]
    createMany?: TransactionInfoCreateManyCustomersInputEnvelope
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
  }

  export type TransactionInfoUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutCustomersInput, TransactionInfoUncheckedCreateWithoutCustomersInput> | TransactionInfoCreateWithoutCustomersInput[] | TransactionInfoUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutCustomersInput | TransactionInfoCreateOrConnectWithoutCustomersInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutCustomersInput | TransactionInfoUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: TransactionInfoCreateManyCustomersInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutCustomersInput | TransactionInfoUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutCustomersInput | TransactionInfoUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type TransactionInfoUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutCustomersInput, TransactionInfoUncheckedCreateWithoutCustomersInput> | TransactionInfoCreateWithoutCustomersInput[] | TransactionInfoUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutCustomersInput | TransactionInfoCreateOrConnectWithoutCustomersInput[]
    upsert?: TransactionInfoUpsertWithWhereUniqueWithoutCustomersInput | TransactionInfoUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: TransactionInfoCreateManyCustomersInputEnvelope
    set?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    disconnect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    delete?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    connect?: TransactionInfoWhereUniqueInput | TransactionInfoWhereUniqueInput[]
    update?: TransactionInfoUpdateWithWhereUniqueWithoutCustomersInput | TransactionInfoUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: TransactionInfoUpdateManyWithWhereWithoutCustomersInput | TransactionInfoUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
  }

  export type ChemistCreateNestedManyWithoutScopesInput = {
    create?: XOR<ChemistCreateWithoutScopesInput, ChemistUncheckedCreateWithoutScopesInput> | ChemistCreateWithoutScopesInput[] | ChemistUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutScopesInput | ChemistCreateOrConnectWithoutScopesInput[]
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
  }

  export type DepoCreateNestedManyWithoutScopesInput = {
    create?: XOR<DepoCreateWithoutScopesInput, DepoUncheckedCreateWithoutScopesInput> | DepoCreateWithoutScopesInput[] | DepoUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: DepoCreateOrConnectWithoutScopesInput | DepoCreateOrConnectWithoutScopesInput[]
    connect?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
  }

  export type StakeholderCreateNestedManyWithoutScopesInput = {
    create?: XOR<StakeholderCreateWithoutScopesInput, StakeholderUncheckedCreateWithoutScopesInput> | StakeholderCreateWithoutScopesInput[] | StakeholderUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutScopesInput | StakeholderCreateOrConnectWithoutScopesInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutScopeInput = {
    create?: XOR<UserCreateWithoutScopeInput, UserUncheckedCreateWithoutScopeInput>
    connectOrCreate?: UserCreateOrConnectWithoutScopeInput
    connect?: UserWhereUniqueInput
  }

  export type JobPostCreateNestedOneWithoutScopeInput = {
    create?: XOR<JobPostCreateWithoutScopeInput, JobPostUncheckedCreateWithoutScopeInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutScopeInput
    connect?: JobPostWhereUniqueInput
  }

  export type ChemistUncheckedCreateNestedManyWithoutScopesInput = {
    create?: XOR<ChemistCreateWithoutScopesInput, ChemistUncheckedCreateWithoutScopesInput> | ChemistCreateWithoutScopesInput[] | ChemistUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutScopesInput | ChemistCreateOrConnectWithoutScopesInput[]
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
  }

  export type DepoUncheckedCreateNestedManyWithoutScopesInput = {
    create?: XOR<DepoCreateWithoutScopesInput, DepoUncheckedCreateWithoutScopesInput> | DepoCreateWithoutScopesInput[] | DepoUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: DepoCreateOrConnectWithoutScopesInput | DepoCreateOrConnectWithoutScopesInput[]
    connect?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
  }

  export type StakeholderUncheckedCreateNestedManyWithoutScopesInput = {
    create?: XOR<StakeholderCreateWithoutScopesInput, StakeholderUncheckedCreateWithoutScopesInput> | StakeholderCreateWithoutScopesInput[] | StakeholderUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutScopesInput | StakeholderCreateOrConnectWithoutScopesInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
  }

  export type ChemistUpdateManyWithoutScopesNestedInput = {
    create?: XOR<ChemistCreateWithoutScopesInput, ChemistUncheckedCreateWithoutScopesInput> | ChemistCreateWithoutScopesInput[] | ChemistUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutScopesInput | ChemistCreateOrConnectWithoutScopesInput[]
    upsert?: ChemistUpsertWithWhereUniqueWithoutScopesInput | ChemistUpsertWithWhereUniqueWithoutScopesInput[]
    set?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    disconnect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    delete?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    update?: ChemistUpdateWithWhereUniqueWithoutScopesInput | ChemistUpdateWithWhereUniqueWithoutScopesInput[]
    updateMany?: ChemistUpdateManyWithWhereWithoutScopesInput | ChemistUpdateManyWithWhereWithoutScopesInput[]
    deleteMany?: ChemistScalarWhereInput | ChemistScalarWhereInput[]
  }

  export type DepoUpdateManyWithoutScopesNestedInput = {
    create?: XOR<DepoCreateWithoutScopesInput, DepoUncheckedCreateWithoutScopesInput> | DepoCreateWithoutScopesInput[] | DepoUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: DepoCreateOrConnectWithoutScopesInput | DepoCreateOrConnectWithoutScopesInput[]
    upsert?: DepoUpsertWithWhereUniqueWithoutScopesInput | DepoUpsertWithWhereUniqueWithoutScopesInput[]
    set?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    disconnect?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    delete?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    connect?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    update?: DepoUpdateWithWhereUniqueWithoutScopesInput | DepoUpdateWithWhereUniqueWithoutScopesInput[]
    updateMany?: DepoUpdateManyWithWhereWithoutScopesInput | DepoUpdateManyWithWhereWithoutScopesInput[]
    deleteMany?: DepoScalarWhereInput | DepoScalarWhereInput[]
  }

  export type StakeholderUpdateManyWithoutScopesNestedInput = {
    create?: XOR<StakeholderCreateWithoutScopesInput, StakeholderUncheckedCreateWithoutScopesInput> | StakeholderCreateWithoutScopesInput[] | StakeholderUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutScopesInput | StakeholderCreateOrConnectWithoutScopesInput[]
    upsert?: StakeholderUpsertWithWhereUniqueWithoutScopesInput | StakeholderUpsertWithWhereUniqueWithoutScopesInput[]
    set?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    disconnect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    delete?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    update?: StakeholderUpdateWithWhereUniqueWithoutScopesInput | StakeholderUpdateWithWhereUniqueWithoutScopesInput[]
    updateMany?: StakeholderUpdateManyWithWhereWithoutScopesInput | StakeholderUpdateManyWithWhereWithoutScopesInput[]
    deleteMany?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutScopeNestedInput = {
    create?: XOR<UserCreateWithoutScopeInput, UserUncheckedCreateWithoutScopeInput>
    connectOrCreate?: UserCreateOrConnectWithoutScopeInput
    upsert?: UserUpsertWithoutScopeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScopeInput, UserUpdateWithoutScopeInput>, UserUncheckedUpdateWithoutScopeInput>
  }

  export type JobPostUpdateOneRequiredWithoutScopeNestedInput = {
    create?: XOR<JobPostCreateWithoutScopeInput, JobPostUncheckedCreateWithoutScopeInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutScopeInput
    upsert?: JobPostUpsertWithoutScopeInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutScopeInput, JobPostUpdateWithoutScopeInput>, JobPostUncheckedUpdateWithoutScopeInput>
  }

  export type ChemistUncheckedUpdateManyWithoutScopesNestedInput = {
    create?: XOR<ChemistCreateWithoutScopesInput, ChemistUncheckedCreateWithoutScopesInput> | ChemistCreateWithoutScopesInput[] | ChemistUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: ChemistCreateOrConnectWithoutScopesInput | ChemistCreateOrConnectWithoutScopesInput[]
    upsert?: ChemistUpsertWithWhereUniqueWithoutScopesInput | ChemistUpsertWithWhereUniqueWithoutScopesInput[]
    set?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    disconnect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    delete?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    connect?: ChemistWhereUniqueInput | ChemistWhereUniqueInput[]
    update?: ChemistUpdateWithWhereUniqueWithoutScopesInput | ChemistUpdateWithWhereUniqueWithoutScopesInput[]
    updateMany?: ChemistUpdateManyWithWhereWithoutScopesInput | ChemistUpdateManyWithWhereWithoutScopesInput[]
    deleteMany?: ChemistScalarWhereInput | ChemistScalarWhereInput[]
  }

  export type DepoUncheckedUpdateManyWithoutScopesNestedInput = {
    create?: XOR<DepoCreateWithoutScopesInput, DepoUncheckedCreateWithoutScopesInput> | DepoCreateWithoutScopesInput[] | DepoUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: DepoCreateOrConnectWithoutScopesInput | DepoCreateOrConnectWithoutScopesInput[]
    upsert?: DepoUpsertWithWhereUniqueWithoutScopesInput | DepoUpsertWithWhereUniqueWithoutScopesInput[]
    set?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    disconnect?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    delete?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    connect?: DepoWhereUniqueInput | DepoWhereUniqueInput[]
    update?: DepoUpdateWithWhereUniqueWithoutScopesInput | DepoUpdateWithWhereUniqueWithoutScopesInput[]
    updateMany?: DepoUpdateManyWithWhereWithoutScopesInput | DepoUpdateManyWithWhereWithoutScopesInput[]
    deleteMany?: DepoScalarWhereInput | DepoScalarWhereInput[]
  }

  export type StakeholderUncheckedUpdateManyWithoutScopesNestedInput = {
    create?: XOR<StakeholderCreateWithoutScopesInput, StakeholderUncheckedCreateWithoutScopesInput> | StakeholderCreateWithoutScopesInput[] | StakeholderUncheckedCreateWithoutScopesInput[]
    connectOrCreate?: StakeholderCreateOrConnectWithoutScopesInput | StakeholderCreateOrConnectWithoutScopesInput[]
    upsert?: StakeholderUpsertWithWhereUniqueWithoutScopesInput | StakeholderUpsertWithWhereUniqueWithoutScopesInput[]
    set?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    disconnect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    delete?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    connect?: StakeholderWhereUniqueInput | StakeholderWhereUniqueInput[]
    update?: StakeholderUpdateWithWhereUniqueWithoutScopesInput | StakeholderUpdateWithWhereUniqueWithoutScopesInput[]
    updateMany?: StakeholderUpdateManyWithWhereWithoutScopesInput | StakeholderUpdateManyWithWhereWithoutScopesInput[]
    deleteMany?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMpoTargetInput = {
    create?: XOR<UserCreateWithoutMpoTargetInput, UserUncheckedCreateWithoutMpoTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutMpoTargetInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMpoTargetNestedInput = {
    create?: XOR<UserCreateWithoutMpoTargetInput, UserUncheckedCreateWithoutMpoTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutMpoTargetInput
    upsert?: UserUpsertWithoutMpoTargetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMpoTargetInput, UserUpdateWithoutMpoTargetInput>, UserUncheckedUpdateWithoutMpoTargetInput>
  }

  export type UserCreateNestedOneWithoutProductWiseTargetInput = {
    create?: XOR<UserCreateWithoutProductWiseTargetInput, UserUncheckedCreateWithoutProductWiseTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductWiseTargetInput
    connect?: UserWhereUniqueInput
  }

  export type TargetProductBatchCreateNestedManyWithoutProductWiseTargetInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductWiseTargetInput, TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput> | TargetProductBatchCreateWithoutProductWiseTargetInput[] | TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput | TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput[]
    createMany?: TargetProductBatchCreateManyProductWiseTargetInputEnvelope
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
  }

  export type TargetProductBatchUncheckedCreateNestedManyWithoutProductWiseTargetInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductWiseTargetInput, TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput> | TargetProductBatchCreateWithoutProductWiseTargetInput[] | TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput | TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput[]
    createMany?: TargetProductBatchCreateManyProductWiseTargetInputEnvelope
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
  }

  export type EnumTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.TargetType
  }

  export type UserUpdateOneRequiredWithoutProductWiseTargetNestedInput = {
    create?: XOR<UserCreateWithoutProductWiseTargetInput, UserUncheckedCreateWithoutProductWiseTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductWiseTargetInput
    upsert?: UserUpsertWithoutProductWiseTargetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductWiseTargetInput, UserUpdateWithoutProductWiseTargetInput>, UserUncheckedUpdateWithoutProductWiseTargetInput>
  }

  export type TargetProductBatchUpdateManyWithoutProductWiseTargetNestedInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductWiseTargetInput, TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput> | TargetProductBatchCreateWithoutProductWiseTargetInput[] | TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput | TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput[]
    upsert?: TargetProductBatchUpsertWithWhereUniqueWithoutProductWiseTargetInput | TargetProductBatchUpsertWithWhereUniqueWithoutProductWiseTargetInput[]
    createMany?: TargetProductBatchCreateManyProductWiseTargetInputEnvelope
    set?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    disconnect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    delete?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    update?: TargetProductBatchUpdateWithWhereUniqueWithoutProductWiseTargetInput | TargetProductBatchUpdateWithWhereUniqueWithoutProductWiseTargetInput[]
    updateMany?: TargetProductBatchUpdateManyWithWhereWithoutProductWiseTargetInput | TargetProductBatchUpdateManyWithWhereWithoutProductWiseTargetInput[]
    deleteMany?: TargetProductBatchScalarWhereInput | TargetProductBatchScalarWhereInput[]
  }

  export type TargetProductBatchUncheckedUpdateManyWithoutProductWiseTargetNestedInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductWiseTargetInput, TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput> | TargetProductBatchCreateWithoutProductWiseTargetInput[] | TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput | TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput[]
    upsert?: TargetProductBatchUpsertWithWhereUniqueWithoutProductWiseTargetInput | TargetProductBatchUpsertWithWhereUniqueWithoutProductWiseTargetInput[]
    createMany?: TargetProductBatchCreateManyProductWiseTargetInputEnvelope
    set?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    disconnect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    delete?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    update?: TargetProductBatchUpdateWithWhereUniqueWithoutProductWiseTargetInput | TargetProductBatchUpdateWithWhereUniqueWithoutProductWiseTargetInput[]
    updateMany?: TargetProductBatchUpdateManyWithWhereWithoutProductWiseTargetInput | TargetProductBatchUpdateManyWithWhereWithoutProductWiseTargetInput[]
    deleteMany?: TargetProductBatchScalarWhereInput | TargetProductBatchScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutTargetProductBatchInput = {
    create?: XOR<ProductCreateWithoutTargetProductBatchInput, ProductUncheckedCreateWithoutTargetProductBatchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTargetProductBatchInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductWiseTargetCreateNestedOneWithoutTargetProductBatchInput = {
    create?: XOR<ProductWiseTargetCreateWithoutTargetProductBatchInput, ProductWiseTargetUncheckedCreateWithoutTargetProductBatchInput>
    connectOrCreate?: ProductWiseTargetCreateOrConnectWithoutTargetProductBatchInput
    connect?: ProductWiseTargetWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutTargetProductBatchNestedInput = {
    create?: XOR<ProductCreateWithoutTargetProductBatchInput, ProductUncheckedCreateWithoutTargetProductBatchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTargetProductBatchInput
    upsert?: ProductUpsertWithoutTargetProductBatchInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTargetProductBatchInput, ProductUpdateWithoutTargetProductBatchInput>, ProductUncheckedUpdateWithoutTargetProductBatchInput>
  }

  export type ProductWiseTargetUpdateOneRequiredWithoutTargetProductBatchNestedInput = {
    create?: XOR<ProductWiseTargetCreateWithoutTargetProductBatchInput, ProductWiseTargetUncheckedCreateWithoutTargetProductBatchInput>
    connectOrCreate?: ProductWiseTargetCreateOrConnectWithoutTargetProductBatchInput
    upsert?: ProductWiseTargetUpsertWithoutTargetProductBatchInput
    connect?: ProductWiseTargetWhereUniqueInput
    update?: XOR<XOR<ProductWiseTargetUpdateToOneWithWhereWithoutTargetProductBatchInput, ProductWiseTargetUpdateWithoutTargetProductBatchInput>, ProductWiseTargetUncheckedUpdateWithoutTargetProductBatchInput>
  }

  export type SubCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type SubCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type SubCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutSubCategoryInput = {
    create?: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoryInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutSubCategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoryInput
    upsert?: CategoryUpsertWithoutSubCategoryInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubCategoryInput, CategoryUpdateWithoutSubCategoryInput>, CategoryUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitInput | ProductUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitInput | ProductUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitInput | ProductUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitInput | ProductUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitInput | ProductUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitInput | ProductUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type LedgerHeadCreateNestedManyWithoutAccountHeadInput = {
    create?: XOR<LedgerHeadCreateWithoutAccountHeadInput, LedgerHeadUncheckedCreateWithoutAccountHeadInput> | LedgerHeadCreateWithoutAccountHeadInput[] | LedgerHeadUncheckedCreateWithoutAccountHeadInput[]
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutAccountHeadInput | LedgerHeadCreateOrConnectWithoutAccountHeadInput[]
    createMany?: LedgerHeadCreateManyAccountHeadInputEnvelope
    connect?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
  }

  export type LedgerHeadUncheckedCreateNestedManyWithoutAccountHeadInput = {
    create?: XOR<LedgerHeadCreateWithoutAccountHeadInput, LedgerHeadUncheckedCreateWithoutAccountHeadInput> | LedgerHeadCreateWithoutAccountHeadInput[] | LedgerHeadUncheckedCreateWithoutAccountHeadInput[]
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutAccountHeadInput | LedgerHeadCreateOrConnectWithoutAccountHeadInput[]
    createMany?: LedgerHeadCreateManyAccountHeadInputEnvelope
    connect?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
  }

  export type LedgerHeadUpdateManyWithoutAccountHeadNestedInput = {
    create?: XOR<LedgerHeadCreateWithoutAccountHeadInput, LedgerHeadUncheckedCreateWithoutAccountHeadInput> | LedgerHeadCreateWithoutAccountHeadInput[] | LedgerHeadUncheckedCreateWithoutAccountHeadInput[]
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutAccountHeadInput | LedgerHeadCreateOrConnectWithoutAccountHeadInput[]
    upsert?: LedgerHeadUpsertWithWhereUniqueWithoutAccountHeadInput | LedgerHeadUpsertWithWhereUniqueWithoutAccountHeadInput[]
    createMany?: LedgerHeadCreateManyAccountHeadInputEnvelope
    set?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    disconnect?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    delete?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    connect?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    update?: LedgerHeadUpdateWithWhereUniqueWithoutAccountHeadInput | LedgerHeadUpdateWithWhereUniqueWithoutAccountHeadInput[]
    updateMany?: LedgerHeadUpdateManyWithWhereWithoutAccountHeadInput | LedgerHeadUpdateManyWithWhereWithoutAccountHeadInput[]
    deleteMany?: LedgerHeadScalarWhereInput | LedgerHeadScalarWhereInput[]
  }

  export type LedgerHeadUncheckedUpdateManyWithoutAccountHeadNestedInput = {
    create?: XOR<LedgerHeadCreateWithoutAccountHeadInput, LedgerHeadUncheckedCreateWithoutAccountHeadInput> | LedgerHeadCreateWithoutAccountHeadInput[] | LedgerHeadUncheckedCreateWithoutAccountHeadInput[]
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutAccountHeadInput | LedgerHeadCreateOrConnectWithoutAccountHeadInput[]
    upsert?: LedgerHeadUpsertWithWhereUniqueWithoutAccountHeadInput | LedgerHeadUpsertWithWhereUniqueWithoutAccountHeadInput[]
    createMany?: LedgerHeadCreateManyAccountHeadInputEnvelope
    set?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    disconnect?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    delete?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    connect?: LedgerHeadWhereUniqueInput | LedgerHeadWhereUniqueInput[]
    update?: LedgerHeadUpdateWithWhereUniqueWithoutAccountHeadInput | LedgerHeadUpdateWithWhereUniqueWithoutAccountHeadInput[]
    updateMany?: LedgerHeadUpdateManyWithWhereWithoutAccountHeadInput | LedgerHeadUpdateManyWithWhereWithoutAccountHeadInput[]
    deleteMany?: LedgerHeadScalarWhereInput | LedgerHeadScalarWhereInput[]
  }

  export type FixedJournalCreateNestedManyWithoutLedgerHeadInput = {
    create?: XOR<FixedJournalCreateWithoutLedgerHeadInput, FixedJournalUncheckedCreateWithoutLedgerHeadInput> | FixedJournalCreateWithoutLedgerHeadInput[] | FixedJournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutLedgerHeadInput | FixedJournalCreateOrConnectWithoutLedgerHeadInput[]
    createMany?: FixedJournalCreateManyLedgerHeadInputEnvelope
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
  }

  export type JournalCreateNestedManyWithoutLedgerHeadInput = {
    create?: XOR<JournalCreateWithoutLedgerHeadInput, JournalUncheckedCreateWithoutLedgerHeadInput> | JournalCreateWithoutLedgerHeadInput[] | JournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutLedgerHeadInput | JournalCreateOrConnectWithoutLedgerHeadInput[]
    createMany?: JournalCreateManyLedgerHeadInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type AccountHeadCreateNestedOneWithoutLedgerHeadInput = {
    create?: XOR<AccountHeadCreateWithoutLedgerHeadInput, AccountHeadUncheckedCreateWithoutLedgerHeadInput>
    connectOrCreate?: AccountHeadCreateOrConnectWithoutLedgerHeadInput
    connect?: AccountHeadWhereUniqueInput
  }

  export type FixedJournalUncheckedCreateNestedManyWithoutLedgerHeadInput = {
    create?: XOR<FixedJournalCreateWithoutLedgerHeadInput, FixedJournalUncheckedCreateWithoutLedgerHeadInput> | FixedJournalCreateWithoutLedgerHeadInput[] | FixedJournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutLedgerHeadInput | FixedJournalCreateOrConnectWithoutLedgerHeadInput[]
    createMany?: FixedJournalCreateManyLedgerHeadInputEnvelope
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
  }

  export type JournalUncheckedCreateNestedManyWithoutLedgerHeadInput = {
    create?: XOR<JournalCreateWithoutLedgerHeadInput, JournalUncheckedCreateWithoutLedgerHeadInput> | JournalCreateWithoutLedgerHeadInput[] | JournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutLedgerHeadInput | JournalCreateOrConnectWithoutLedgerHeadInput[]
    createMany?: JournalCreateManyLedgerHeadInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type FixedJournalUpdateManyWithoutLedgerHeadNestedInput = {
    create?: XOR<FixedJournalCreateWithoutLedgerHeadInput, FixedJournalUncheckedCreateWithoutLedgerHeadInput> | FixedJournalCreateWithoutLedgerHeadInput[] | FixedJournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutLedgerHeadInput | FixedJournalCreateOrConnectWithoutLedgerHeadInput[]
    upsert?: FixedJournalUpsertWithWhereUniqueWithoutLedgerHeadInput | FixedJournalUpsertWithWhereUniqueWithoutLedgerHeadInput[]
    createMany?: FixedJournalCreateManyLedgerHeadInputEnvelope
    set?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    disconnect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    delete?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    update?: FixedJournalUpdateWithWhereUniqueWithoutLedgerHeadInput | FixedJournalUpdateWithWhereUniqueWithoutLedgerHeadInput[]
    updateMany?: FixedJournalUpdateManyWithWhereWithoutLedgerHeadInput | FixedJournalUpdateManyWithWhereWithoutLedgerHeadInput[]
    deleteMany?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
  }

  export type JournalUpdateManyWithoutLedgerHeadNestedInput = {
    create?: XOR<JournalCreateWithoutLedgerHeadInput, JournalUncheckedCreateWithoutLedgerHeadInput> | JournalCreateWithoutLedgerHeadInput[] | JournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutLedgerHeadInput | JournalCreateOrConnectWithoutLedgerHeadInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutLedgerHeadInput | JournalUpsertWithWhereUniqueWithoutLedgerHeadInput[]
    createMany?: JournalCreateManyLedgerHeadInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutLedgerHeadInput | JournalUpdateWithWhereUniqueWithoutLedgerHeadInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutLedgerHeadInput | JournalUpdateManyWithWhereWithoutLedgerHeadInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type AccountHeadUpdateOneRequiredWithoutLedgerHeadNestedInput = {
    create?: XOR<AccountHeadCreateWithoutLedgerHeadInput, AccountHeadUncheckedCreateWithoutLedgerHeadInput>
    connectOrCreate?: AccountHeadCreateOrConnectWithoutLedgerHeadInput
    upsert?: AccountHeadUpsertWithoutLedgerHeadInput
    connect?: AccountHeadWhereUniqueInput
    update?: XOR<XOR<AccountHeadUpdateToOneWithWhereWithoutLedgerHeadInput, AccountHeadUpdateWithoutLedgerHeadInput>, AccountHeadUncheckedUpdateWithoutLedgerHeadInput>
  }

  export type FixedJournalUncheckedUpdateManyWithoutLedgerHeadNestedInput = {
    create?: XOR<FixedJournalCreateWithoutLedgerHeadInput, FixedJournalUncheckedCreateWithoutLedgerHeadInput> | FixedJournalCreateWithoutLedgerHeadInput[] | FixedJournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: FixedJournalCreateOrConnectWithoutLedgerHeadInput | FixedJournalCreateOrConnectWithoutLedgerHeadInput[]
    upsert?: FixedJournalUpsertWithWhereUniqueWithoutLedgerHeadInput | FixedJournalUpsertWithWhereUniqueWithoutLedgerHeadInput[]
    createMany?: FixedJournalCreateManyLedgerHeadInputEnvelope
    set?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    disconnect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    delete?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    connect?: FixedJournalWhereUniqueInput | FixedJournalWhereUniqueInput[]
    update?: FixedJournalUpdateWithWhereUniqueWithoutLedgerHeadInput | FixedJournalUpdateWithWhereUniqueWithoutLedgerHeadInput[]
    updateMany?: FixedJournalUpdateManyWithWhereWithoutLedgerHeadInput | FixedJournalUpdateManyWithWhereWithoutLedgerHeadInput[]
    deleteMany?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
  }

  export type JournalUncheckedUpdateManyWithoutLedgerHeadNestedInput = {
    create?: XOR<JournalCreateWithoutLedgerHeadInput, JournalUncheckedCreateWithoutLedgerHeadInput> | JournalCreateWithoutLedgerHeadInput[] | JournalUncheckedCreateWithoutLedgerHeadInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutLedgerHeadInput | JournalCreateOrConnectWithoutLedgerHeadInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutLedgerHeadInput | JournalUpsertWithWhereUniqueWithoutLedgerHeadInput[]
    createMany?: JournalCreateManyLedgerHeadInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutLedgerHeadInput | JournalUpdateWithWhereUniqueWithoutLedgerHeadInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutLedgerHeadInput | JournalUpdateManyWithWhereWithoutLedgerHeadInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type TargetProductBatchCreateNestedManyWithoutProductInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductInput, TargetProductBatchUncheckedCreateWithoutProductInput> | TargetProductBatchCreateWithoutProductInput[] | TargetProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductInput | TargetProductBatchCreateOrConnectWithoutProductInput[]
    createMany?: TargetProductBatchCreateManyProductInputEnvelope
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StakeholderCreateNestedOneWithoutProductInput = {
    create?: XOR<StakeholderCreateWithoutProductInput, StakeholderUncheckedCreateWithoutProductInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutProductInput
    connect?: StakeholderWhereUniqueInput
  }

  export type SubCategoryCreateNestedOneWithoutProductInput = {
    create?: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductInput
    connect?: SubCategoryWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutProductInput = {
    create?: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductInput
    connect?: UnitWhereUniqueInput
  }

  export type TargetProductBatchUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductInput, TargetProductBatchUncheckedCreateWithoutProductInput> | TargetProductBatchCreateWithoutProductInput[] | TargetProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductInput | TargetProductBatchCreateOrConnectWithoutProductInput[]
    createMany?: TargetProductBatchCreateManyProductInputEnvelope
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TargetProductBatchUpdateManyWithoutProductNestedInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductInput, TargetProductBatchUncheckedCreateWithoutProductInput> | TargetProductBatchCreateWithoutProductInput[] | TargetProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductInput | TargetProductBatchCreateOrConnectWithoutProductInput[]
    upsert?: TargetProductBatchUpsertWithWhereUniqueWithoutProductInput | TargetProductBatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TargetProductBatchCreateManyProductInputEnvelope
    set?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    disconnect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    delete?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    update?: TargetProductBatchUpdateWithWhereUniqueWithoutProductInput | TargetProductBatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TargetProductBatchUpdateManyWithWhereWithoutProductInput | TargetProductBatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TargetProductBatchScalarWhereInput | TargetProductBatchScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StakeholderUpdateOneWithoutProductNestedInput = {
    create?: XOR<StakeholderCreateWithoutProductInput, StakeholderUncheckedCreateWithoutProductInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutProductInput
    upsert?: StakeholderUpsertWithoutProductInput
    disconnect?: StakeholderWhereInput | boolean
    delete?: StakeholderWhereInput | boolean
    connect?: StakeholderWhereUniqueInput
    update?: XOR<XOR<StakeholderUpdateToOneWithWhereWithoutProductInput, StakeholderUpdateWithoutProductInput>, StakeholderUncheckedUpdateWithoutProductInput>
  }

  export type SubCategoryUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductInput
    upsert?: SubCategoryUpsertWithoutProductInput
    connect?: SubCategoryWhereUniqueInput
    update?: XOR<XOR<SubCategoryUpdateToOneWithWhereWithoutProductInput, SubCategoryUpdateWithoutProductInput>, SubCategoryUncheckedUpdateWithoutProductInput>
  }

  export type UnitUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductInput
    upsert?: UnitUpsertWithoutProductInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutProductInput, UnitUpdateWithoutProductInput>, UnitUncheckedUpdateWithoutProductInput>
  }

  export type TargetProductBatchUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TargetProductBatchCreateWithoutProductInput, TargetProductBatchUncheckedCreateWithoutProductInput> | TargetProductBatchCreateWithoutProductInput[] | TargetProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TargetProductBatchCreateOrConnectWithoutProductInput | TargetProductBatchCreateOrConnectWithoutProductInput[]
    upsert?: TargetProductBatchUpsertWithWhereUniqueWithoutProductInput | TargetProductBatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TargetProductBatchCreateManyProductInputEnvelope
    set?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    disconnect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    delete?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    connect?: TargetProductBatchWhereUniqueInput | TargetProductBatchWhereUniqueInput[]
    update?: TargetProductBatchUpdateWithWhereUniqueWithoutProductInput | TargetProductBatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TargetProductBatchUpdateManyWithWhereWithoutProductInput | TargetProductBatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TargetProductBatchScalarWhereInput | TargetProductBatchScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type BankTransactionCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type BankTransactionUpdateManyWithoutBankAccountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput | BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput | BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBankAccountInput | BankTransactionUpdateManyWithWhereWithoutBankAccountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput | BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput | BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBankAccountInput | BankTransactionUpdateManyWithWhereWithoutBankAccountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type BankAccountCreateNestedOneWithoutBankTransactionInput = {
    create?: XOR<BankAccountCreateWithoutBankTransactionInput, BankAccountUncheckedCreateWithoutBankTransactionInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutBankTransactionInput
    connect?: BankAccountWhereUniqueInput
  }

  export type JournalCreateNestedOneWithoutBankTransactionInput = {
    create?: XOR<JournalCreateWithoutBankTransactionInput, JournalUncheckedCreateWithoutBankTransactionInput>
    connectOrCreate?: JournalCreateOrConnectWithoutBankTransactionInput
    connect?: JournalWhereUniqueInput
  }

  export type BankAccountUpdateOneRequiredWithoutBankTransactionNestedInput = {
    create?: XOR<BankAccountCreateWithoutBankTransactionInput, BankAccountUncheckedCreateWithoutBankTransactionInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutBankTransactionInput
    upsert?: BankAccountUpsertWithoutBankTransactionInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutBankTransactionInput, BankAccountUpdateWithoutBankTransactionInput>, BankAccountUncheckedUpdateWithoutBankTransactionInput>
  }

  export type JournalUpdateOneWithoutBankTransactionNestedInput = {
    create?: XOR<JournalCreateWithoutBankTransactionInput, JournalUncheckedCreateWithoutBankTransactionInput>
    connectOrCreate?: JournalCreateOrConnectWithoutBankTransactionInput
    upsert?: JournalUpsertWithoutBankTransactionInput
    disconnect?: JournalWhereInput | boolean
    delete?: JournalWhereInput | boolean
    connect?: JournalWhereUniqueInput
    update?: XOR<XOR<JournalUpdateToOneWithWhereWithoutBankTransactionInput, JournalUpdateWithoutBankTransactionInput>, JournalUncheckedUpdateWithoutBankTransactionInput>
  }

  export type DepoCreateNestedOneWithoutInventoryInput = {
    create?: XOR<DepoCreateWithoutInventoryInput, DepoUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: DepoCreateOrConnectWithoutInventoryInput
    connect?: DepoWhereUniqueInput
  }

  export type FixedJournalCreateNestedOneWithoutInventoryInput = {
    create?: XOR<FixedJournalCreateWithoutInventoryInput, FixedJournalUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: FixedJournalCreateOrConnectWithoutInventoryInput
    connect?: FixedJournalWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    connect?: ProductWhereUniqueInput
  }

  export type TransactionInfoCreateNestedOneWithoutInventoryInput = {
    create?: XOR<TransactionInfoCreateWithoutInventoryInput, TransactionInfoUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutInventoryInput
    connect?: TransactionInfoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoriesInput = {
    create?: XOR<UserCreateWithoutInventoriesInput, UserUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoriesInput
    connect?: UserWhereUniqueInput
  }

  export type DepoUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<DepoCreateWithoutInventoryInput, DepoUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: DepoCreateOrConnectWithoutInventoryInput
    upsert?: DepoUpsertWithoutInventoryInput
    disconnect?: DepoWhereInput | boolean
    delete?: DepoWhereInput | boolean
    connect?: DepoWhereUniqueInput
    update?: XOR<XOR<DepoUpdateToOneWithWhereWithoutInventoryInput, DepoUpdateWithoutInventoryInput>, DepoUncheckedUpdateWithoutInventoryInput>
  }

  export type FixedJournalUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<FixedJournalCreateWithoutInventoryInput, FixedJournalUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: FixedJournalCreateOrConnectWithoutInventoryInput
    upsert?: FixedJournalUpsertWithoutInventoryInput
    disconnect?: FixedJournalWhereInput | boolean
    delete?: FixedJournalWhereInput | boolean
    connect?: FixedJournalWhereUniqueInput
    update?: XOR<XOR<FixedJournalUpdateToOneWithWhereWithoutInventoryInput, FixedJournalUpdateWithoutInventoryInput>, FixedJournalUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    upsert?: ProductUpsertWithoutInventoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryInput, ProductUpdateWithoutInventoryInput>, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type TransactionInfoUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutInventoryInput, TransactionInfoUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutInventoryInput
    upsert?: TransactionInfoUpsertWithoutInventoryInput
    disconnect?: TransactionInfoWhereInput | boolean
    delete?: TransactionInfoWhereInput | boolean
    connect?: TransactionInfoWhereUniqueInput
    update?: XOR<XOR<TransactionInfoUpdateToOneWithWhereWithoutInventoryInput, TransactionInfoUpdateWithoutInventoryInput>, TransactionInfoUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateOneWithoutInventoriesNestedInput = {
    create?: XOR<UserCreateWithoutInventoriesInput, UserUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoriesInput
    upsert?: UserUpsertWithoutInventoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoriesInput, UserUpdateWithoutInventoriesInput>, UserUncheckedUpdateWithoutInventoriesInput>
  }

  export type InventoryCreateNestedManyWithoutTransactionInfoInput = {
    create?: XOR<InventoryCreateWithoutTransactionInfoInput, InventoryUncheckedCreateWithoutTransactionInfoInput> | InventoryCreateWithoutTransactionInfoInput[] | InventoryUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutTransactionInfoInput | InventoryCreateOrConnectWithoutTransactionInfoInput[]
    createMany?: InventoryCreateManyTransactionInfoInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type JournalCreateNestedManyWithoutTransactionInfoInput = {
    create?: XOR<JournalCreateWithoutTransactionInfoInput, JournalUncheckedCreateWithoutTransactionInfoInput> | JournalCreateWithoutTransactionInfoInput[] | JournalUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutTransactionInfoInput | JournalCreateOrConnectWithoutTransactionInfoInput[]
    createMany?: JournalCreateManyTransactionInfoInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type ChemistCreateNestedOneWithoutTransactionInfoInput = {
    create?: XOR<ChemistCreateWithoutTransactionInfoInput, ChemistUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: ChemistCreateOrConnectWithoutTransactionInfoInput
    connect?: ChemistWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutTransactionInfoInput = {
    create?: XOR<CustomersCreateWithoutTransactionInfoInput, CustomersUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutTransactionInfoInput
    connect?: CustomersWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionInfoInput = {
    create?: XOR<UserCreateWithoutTransactionInfoInput, UserUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInfoInput
    connect?: UserWhereUniqueInput
  }

  export type PartyCreateNestedOneWithoutTransactionInfoInput = {
    create?: XOR<PartyCreateWithoutTransactionInfoInput, PartyUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: PartyCreateOrConnectWithoutTransactionInfoInput
    connect?: PartyWhereUniqueInput
  }

  export type StakeholderCreateNestedOneWithoutTransactionInfoInput = {
    create?: XOR<StakeholderCreateWithoutTransactionInfoInput, StakeholderUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutTransactionInfoInput
    connect?: StakeholderWhereUniqueInput
  }

  export type InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput = {
    create?: XOR<InventoryCreateWithoutTransactionInfoInput, InventoryUncheckedCreateWithoutTransactionInfoInput> | InventoryCreateWithoutTransactionInfoInput[] | InventoryUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutTransactionInfoInput | InventoryCreateOrConnectWithoutTransactionInfoInput[]
    createMany?: InventoryCreateManyTransactionInfoInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type JournalUncheckedCreateNestedManyWithoutTransactionInfoInput = {
    create?: XOR<JournalCreateWithoutTransactionInfoInput, JournalUncheckedCreateWithoutTransactionInfoInput> | JournalCreateWithoutTransactionInfoInput[] | JournalUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutTransactionInfoInput | JournalCreateOrConnectWithoutTransactionInfoInput[]
    createMany?: JournalCreateManyTransactionInfoInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type EnumVoucherTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoucherType
  }

  export type NullableEnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType | null
  }

  export type InventoryUpdateManyWithoutTransactionInfoNestedInput = {
    create?: XOR<InventoryCreateWithoutTransactionInfoInput, InventoryUncheckedCreateWithoutTransactionInfoInput> | InventoryCreateWithoutTransactionInfoInput[] | InventoryUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutTransactionInfoInput | InventoryCreateOrConnectWithoutTransactionInfoInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutTransactionInfoInput | InventoryUpsertWithWhereUniqueWithoutTransactionInfoInput[]
    createMany?: InventoryCreateManyTransactionInfoInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutTransactionInfoInput | InventoryUpdateWithWhereUniqueWithoutTransactionInfoInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutTransactionInfoInput | InventoryUpdateManyWithWhereWithoutTransactionInfoInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type JournalUpdateManyWithoutTransactionInfoNestedInput = {
    create?: XOR<JournalCreateWithoutTransactionInfoInput, JournalUncheckedCreateWithoutTransactionInfoInput> | JournalCreateWithoutTransactionInfoInput[] | JournalUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutTransactionInfoInput | JournalCreateOrConnectWithoutTransactionInfoInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutTransactionInfoInput | JournalUpsertWithWhereUniqueWithoutTransactionInfoInput[]
    createMany?: JournalCreateManyTransactionInfoInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutTransactionInfoInput | JournalUpdateWithWhereUniqueWithoutTransactionInfoInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutTransactionInfoInput | JournalUpdateManyWithWhereWithoutTransactionInfoInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type ChemistUpdateOneWithoutTransactionInfoNestedInput = {
    create?: XOR<ChemistCreateWithoutTransactionInfoInput, ChemistUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: ChemistCreateOrConnectWithoutTransactionInfoInput
    upsert?: ChemistUpsertWithoutTransactionInfoInput
    disconnect?: ChemistWhereInput | boolean
    delete?: ChemistWhereInput | boolean
    connect?: ChemistWhereUniqueInput
    update?: XOR<XOR<ChemistUpdateToOneWithWhereWithoutTransactionInfoInput, ChemistUpdateWithoutTransactionInfoInput>, ChemistUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type CustomersUpdateOneWithoutTransactionInfoNestedInput = {
    create?: XOR<CustomersCreateWithoutTransactionInfoInput, CustomersUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutTransactionInfoInput
    upsert?: CustomersUpsertWithoutTransactionInfoInput
    disconnect?: CustomersWhereInput | boolean
    delete?: CustomersWhereInput | boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutTransactionInfoInput, CustomersUpdateWithoutTransactionInfoInput>, CustomersUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type UserUpdateOneWithoutTransactionInfoNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInfoInput, UserUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInfoInput
    upsert?: UserUpsertWithoutTransactionInfoInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInfoInput, UserUpdateWithoutTransactionInfoInput>, UserUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type PartyUpdateOneWithoutTransactionInfoNestedInput = {
    create?: XOR<PartyCreateWithoutTransactionInfoInput, PartyUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: PartyCreateOrConnectWithoutTransactionInfoInput
    upsert?: PartyUpsertWithoutTransactionInfoInput
    disconnect?: PartyWhereInput | boolean
    delete?: PartyWhereInput | boolean
    connect?: PartyWhereUniqueInput
    update?: XOR<XOR<PartyUpdateToOneWithWhereWithoutTransactionInfoInput, PartyUpdateWithoutTransactionInfoInput>, PartyUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type StakeholderUpdateOneWithoutTransactionInfoNestedInput = {
    create?: XOR<StakeholderCreateWithoutTransactionInfoInput, StakeholderUncheckedCreateWithoutTransactionInfoInput>
    connectOrCreate?: StakeholderCreateOrConnectWithoutTransactionInfoInput
    upsert?: StakeholderUpsertWithoutTransactionInfoInput
    disconnect?: StakeholderWhereInput | boolean
    delete?: StakeholderWhereInput | boolean
    connect?: StakeholderWhereUniqueInput
    update?: XOR<XOR<StakeholderUpdateToOneWithWhereWithoutTransactionInfoInput, StakeholderUpdateWithoutTransactionInfoInput>, StakeholderUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput = {
    create?: XOR<InventoryCreateWithoutTransactionInfoInput, InventoryUncheckedCreateWithoutTransactionInfoInput> | InventoryCreateWithoutTransactionInfoInput[] | InventoryUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutTransactionInfoInput | InventoryCreateOrConnectWithoutTransactionInfoInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutTransactionInfoInput | InventoryUpsertWithWhereUniqueWithoutTransactionInfoInput[]
    createMany?: InventoryCreateManyTransactionInfoInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutTransactionInfoInput | InventoryUpdateWithWhereUniqueWithoutTransactionInfoInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutTransactionInfoInput | InventoryUpdateManyWithWhereWithoutTransactionInfoInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput = {
    create?: XOR<JournalCreateWithoutTransactionInfoInput, JournalUncheckedCreateWithoutTransactionInfoInput> | JournalCreateWithoutTransactionInfoInput[] | JournalUncheckedCreateWithoutTransactionInfoInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutTransactionInfoInput | JournalCreateOrConnectWithoutTransactionInfoInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutTransactionInfoInput | JournalUpsertWithWhereUniqueWithoutTransactionInfoInput[]
    createMany?: JournalCreateManyTransactionInfoInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutTransactionInfoInput | JournalUpdateWithWhereUniqueWithoutTransactionInfoInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutTransactionInfoInput | JournalUpdateManyWithWhereWithoutTransactionInfoInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type DepoCreateNestedOneWithoutJournalInput = {
    create?: XOR<DepoCreateWithoutJournalInput, DepoUncheckedCreateWithoutJournalInput>
    connectOrCreate?: DepoCreateOrConnectWithoutJournalInput
    connect?: DepoWhereUniqueInput
  }

  export type LedgerHeadCreateNestedOneWithoutJournalInput = {
    create?: XOR<LedgerHeadCreateWithoutJournalInput, LedgerHeadUncheckedCreateWithoutJournalInput>
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutJournalInput
    connect?: LedgerHeadWhereUniqueInput
  }

  export type TransactionInfoCreateNestedOneWithoutJournalInput = {
    create?: XOR<TransactionInfoCreateWithoutJournalInput, TransactionInfoUncheckedCreateWithoutJournalInput>
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutJournalInput
    connect?: TransactionInfoWhereUniqueInput
  }

  export type BankTransactionCreateNestedManyWithoutJournalInput = {
    create?: XOR<BankTransactionCreateWithoutJournalInput, BankTransactionUncheckedCreateWithoutJournalInput> | BankTransactionCreateWithoutJournalInput[] | BankTransactionUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutJournalInput | BankTransactionCreateOrConnectWithoutJournalInput[]
    createMany?: BankTransactionCreateManyJournalInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type BankTransactionUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<BankTransactionCreateWithoutJournalInput, BankTransactionUncheckedCreateWithoutJournalInput> | BankTransactionCreateWithoutJournalInput[] | BankTransactionUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutJournalInput | BankTransactionCreateOrConnectWithoutJournalInput[]
    createMany?: BankTransactionCreateManyJournalInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type DepoUpdateOneWithoutJournalNestedInput = {
    create?: XOR<DepoCreateWithoutJournalInput, DepoUncheckedCreateWithoutJournalInput>
    connectOrCreate?: DepoCreateOrConnectWithoutJournalInput
    upsert?: DepoUpsertWithoutJournalInput
    disconnect?: DepoWhereInput | boolean
    delete?: DepoWhereInput | boolean
    connect?: DepoWhereUniqueInput
    update?: XOR<XOR<DepoUpdateToOneWithWhereWithoutJournalInput, DepoUpdateWithoutJournalInput>, DepoUncheckedUpdateWithoutJournalInput>
  }

  export type LedgerHeadUpdateOneWithoutJournalNestedInput = {
    create?: XOR<LedgerHeadCreateWithoutJournalInput, LedgerHeadUncheckedCreateWithoutJournalInput>
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutJournalInput
    upsert?: LedgerHeadUpsertWithoutJournalInput
    disconnect?: LedgerHeadWhereInput | boolean
    delete?: LedgerHeadWhereInput | boolean
    connect?: LedgerHeadWhereUniqueInput
    update?: XOR<XOR<LedgerHeadUpdateToOneWithWhereWithoutJournalInput, LedgerHeadUpdateWithoutJournalInput>, LedgerHeadUncheckedUpdateWithoutJournalInput>
  }

  export type TransactionInfoUpdateOneWithoutJournalNestedInput = {
    create?: XOR<TransactionInfoCreateWithoutJournalInput, TransactionInfoUncheckedCreateWithoutJournalInput>
    connectOrCreate?: TransactionInfoCreateOrConnectWithoutJournalInput
    upsert?: TransactionInfoUpsertWithoutJournalInput
    disconnect?: TransactionInfoWhereInput | boolean
    delete?: TransactionInfoWhereInput | boolean
    connect?: TransactionInfoWhereUniqueInput
    update?: XOR<XOR<TransactionInfoUpdateToOneWithWhereWithoutJournalInput, TransactionInfoUpdateWithoutJournalInput>, TransactionInfoUncheckedUpdateWithoutJournalInput>
  }

  export type BankTransactionUpdateManyWithoutJournalNestedInput = {
    create?: XOR<BankTransactionCreateWithoutJournalInput, BankTransactionUncheckedCreateWithoutJournalInput> | BankTransactionCreateWithoutJournalInput[] | BankTransactionUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutJournalInput | BankTransactionCreateOrConnectWithoutJournalInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutJournalInput | BankTransactionUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: BankTransactionCreateManyJournalInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutJournalInput | BankTransactionUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutJournalInput | BankTransactionUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type BankTransactionUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<BankTransactionCreateWithoutJournalInput, BankTransactionUncheckedCreateWithoutJournalInput> | BankTransactionCreateWithoutJournalInput[] | BankTransactionUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutJournalInput | BankTransactionCreateOrConnectWithoutJournalInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutJournalInput | BankTransactionUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: BankTransactionCreateManyJournalInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutJournalInput | BankTransactionUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutJournalInput | BankTransactionUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type ChemistCreateNestedOneWithoutFixedJournalInput = {
    create?: XOR<ChemistCreateWithoutFixedJournalInput, ChemistUncheckedCreateWithoutFixedJournalInput>
    connectOrCreate?: ChemistCreateOrConnectWithoutFixedJournalInput
    connect?: ChemistWhereUniqueInput
  }

  export type DepoCreateNestedOneWithoutFixedJournalInput = {
    create?: XOR<DepoCreateWithoutFixedJournalInput, DepoUncheckedCreateWithoutFixedJournalInput>
    connectOrCreate?: DepoCreateOrConnectWithoutFixedJournalInput
    connect?: DepoWhereUniqueInput
  }

  export type LedgerHeadCreateNestedOneWithoutFixedJournalInput = {
    create?: XOR<LedgerHeadCreateWithoutFixedJournalInput, LedgerHeadUncheckedCreateWithoutFixedJournalInput>
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutFixedJournalInput
    connect?: LedgerHeadWhereUniqueInput
  }

  export type InventoryCreateNestedManyWithoutFixedJournalInput = {
    create?: XOR<InventoryCreateWithoutFixedJournalInput, InventoryUncheckedCreateWithoutFixedJournalInput> | InventoryCreateWithoutFixedJournalInput[] | InventoryUncheckedCreateWithoutFixedJournalInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutFixedJournalInput | InventoryCreateOrConnectWithoutFixedJournalInput[]
    createMany?: InventoryCreateManyFixedJournalInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutFixedJournalInput = {
    create?: XOR<InventoryCreateWithoutFixedJournalInput, InventoryUncheckedCreateWithoutFixedJournalInput> | InventoryCreateWithoutFixedJournalInput[] | InventoryUncheckedCreateWithoutFixedJournalInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutFixedJournalInput | InventoryCreateOrConnectWithoutFixedJournalInput[]
    createMany?: InventoryCreateManyFixedJournalInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type ChemistUpdateOneRequiredWithoutFixedJournalNestedInput = {
    create?: XOR<ChemistCreateWithoutFixedJournalInput, ChemistUncheckedCreateWithoutFixedJournalInput>
    connectOrCreate?: ChemistCreateOrConnectWithoutFixedJournalInput
    upsert?: ChemistUpsertWithoutFixedJournalInput
    connect?: ChemistWhereUniqueInput
    update?: XOR<XOR<ChemistUpdateToOneWithWhereWithoutFixedJournalInput, ChemistUpdateWithoutFixedJournalInput>, ChemistUncheckedUpdateWithoutFixedJournalInput>
  }

  export type DepoUpdateOneRequiredWithoutFixedJournalNestedInput = {
    create?: XOR<DepoCreateWithoutFixedJournalInput, DepoUncheckedCreateWithoutFixedJournalInput>
    connectOrCreate?: DepoCreateOrConnectWithoutFixedJournalInput
    upsert?: DepoUpsertWithoutFixedJournalInput
    connect?: DepoWhereUniqueInput
    update?: XOR<XOR<DepoUpdateToOneWithWhereWithoutFixedJournalInput, DepoUpdateWithoutFixedJournalInput>, DepoUncheckedUpdateWithoutFixedJournalInput>
  }

  export type LedgerHeadUpdateOneRequiredWithoutFixedJournalNestedInput = {
    create?: XOR<LedgerHeadCreateWithoutFixedJournalInput, LedgerHeadUncheckedCreateWithoutFixedJournalInput>
    connectOrCreate?: LedgerHeadCreateOrConnectWithoutFixedJournalInput
    upsert?: LedgerHeadUpsertWithoutFixedJournalInput
    connect?: LedgerHeadWhereUniqueInput
    update?: XOR<XOR<LedgerHeadUpdateToOneWithWhereWithoutFixedJournalInput, LedgerHeadUpdateWithoutFixedJournalInput>, LedgerHeadUncheckedUpdateWithoutFixedJournalInput>
  }

  export type InventoryUpdateManyWithoutFixedJournalNestedInput = {
    create?: XOR<InventoryCreateWithoutFixedJournalInput, InventoryUncheckedCreateWithoutFixedJournalInput> | InventoryCreateWithoutFixedJournalInput[] | InventoryUncheckedCreateWithoutFixedJournalInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutFixedJournalInput | InventoryCreateOrConnectWithoutFixedJournalInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutFixedJournalInput | InventoryUpsertWithWhereUniqueWithoutFixedJournalInput[]
    createMany?: InventoryCreateManyFixedJournalInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutFixedJournalInput | InventoryUpdateWithWhereUniqueWithoutFixedJournalInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutFixedJournalInput | InventoryUpdateManyWithWhereWithoutFixedJournalInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutFixedJournalNestedInput = {
    create?: XOR<InventoryCreateWithoutFixedJournalInput, InventoryUncheckedCreateWithoutFixedJournalInput> | InventoryCreateWithoutFixedJournalInput[] | InventoryUncheckedCreateWithoutFixedJournalInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutFixedJournalInput | InventoryCreateOrConnectWithoutFixedJournalInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutFixedJournalInput | InventoryUpsertWithWhereUniqueWithoutFixedJournalInput[]
    createMany?: InventoryCreateManyFixedJournalInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutFixedJournalInput | InventoryUpdateWithWhereUniqueWithoutFixedJournalInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutFixedJournalInput | InventoryUpdateManyWithWhereWithoutFixedJournalInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderStatusCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStatusCreateWithoutOrderInput, OrderStatusUncheckedCreateWithoutOrderInput> | OrderStatusCreateWithoutOrderInput[] | OrderStatusUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrderInput | OrderStatusCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStatusCreateManyOrderInputEnvelope
    connect?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
  }

  export type ChemistCreateNestedOneWithoutOrderInput = {
    create?: XOR<ChemistCreateWithoutOrderInput, ChemistUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ChemistCreateOrConnectWithoutOrderInput
    connect?: ChemistWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderStatusUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStatusCreateWithoutOrderInput, OrderStatusUncheckedCreateWithoutOrderInput> | OrderStatusCreateWithoutOrderInput[] | OrderStatusUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrderInput | OrderStatusCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStatusCreateManyOrderInputEnvelope
    connect?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderStatusUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStatusCreateWithoutOrderInput, OrderStatusUncheckedCreateWithoutOrderInput> | OrderStatusCreateWithoutOrderInput[] | OrderStatusUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrderInput | OrderStatusCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStatusUpsertWithWhereUniqueWithoutOrderInput | OrderStatusUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStatusCreateManyOrderInputEnvelope
    set?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    disconnect?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    delete?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    connect?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    update?: OrderStatusUpdateWithWhereUniqueWithoutOrderInput | OrderStatusUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStatusUpdateManyWithWhereWithoutOrderInput | OrderStatusUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStatusScalarWhereInput | OrderStatusScalarWhereInput[]
  }

  export type ChemistUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<ChemistCreateWithoutOrderInput, ChemistUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ChemistCreateOrConnectWithoutOrderInput
    upsert?: ChemistUpsertWithoutOrderInput
    connect?: ChemistWhereUniqueInput
    update?: XOR<XOR<ChemistUpdateToOneWithWhereWithoutOrderInput, ChemistUpdateWithoutOrderInput>, ChemistUncheckedUpdateWithoutOrderInput>
  }

  export type UserUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    upsert?: UserUpsertWithoutOrderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderInput, UserUpdateWithoutOrderInput>, UserUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderStatusUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStatusCreateWithoutOrderInput, OrderStatusUncheckedCreateWithoutOrderInput> | OrderStatusCreateWithoutOrderInput[] | OrderStatusUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrderInput | OrderStatusCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStatusUpsertWithWhereUniqueWithoutOrderInput | OrderStatusUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStatusCreateManyOrderInputEnvelope
    set?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    disconnect?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    delete?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    connect?: OrderStatusWhereUniqueInput | OrderStatusWhereUniqueInput[]
    update?: OrderStatusUpdateWithWhereUniqueWithoutOrderInput | OrderStatusUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStatusUpdateManyWithWhereWithoutOrderInput | OrderStatusUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStatusScalarWhereInput | OrderStatusScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemInput
    upsert?: OrderUpsertWithoutOrderItemInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemInput, OrderUpdateWithoutOrderItemInput>, OrderUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput
    upsert?: ProductUpsertWithoutOrderItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemInput, ProductUpdateWithoutOrderItemInput>, ProductUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderCreateNestedOneWithoutOrderStatusInput = {
    create?: XOR<OrderCreateWithoutOrderStatusInput, OrderUncheckedCreateWithoutOrderStatusInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderStatusInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumOrdStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrdStatus
  }

  export type OrderUpdateOneWithoutOrderStatusNestedInput = {
    create?: XOR<OrderCreateWithoutOrderStatusInput, OrderUncheckedCreateWithoutOrderStatusInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderStatusInput
    upsert?: OrderUpsertWithoutOrderStatusInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderStatusInput, OrderUpdateWithoutOrderStatusInput>, OrderUncheckedUpdateWithoutOrderStatusInput>
  }

  export type UserCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    upsert?: UserUpsertWithoutAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceInput, UserUpdateWithoutAttendanceInput>, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserCreateNestedOneWithoutOvertimeInput = {
    create?: XOR<UserCreateWithoutOvertimeInput, UserUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: UserCreateOrConnectWithoutOvertimeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOvertimeNestedInput = {
    create?: XOR<UserCreateWithoutOvertimeInput, UserUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: UserCreateOrConnectWithoutOvertimeInput
    upsert?: UserUpsertWithoutOvertimeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOvertimeInput, UserUpdateWithoutOvertimeInput>, UserUncheckedUpdateWithoutOvertimeInput>
  }

  export type LevesCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LevesCreateWithoutLeaveTypeInput, LevesUncheckedCreateWithoutLeaveTypeInput> | LevesCreateWithoutLeaveTypeInput[] | LevesUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutLeaveTypeInput | LevesCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LevesCreateManyLeaveTypeInputEnvelope
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
  }

  export type LevesUncheckedCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LevesCreateWithoutLeaveTypeInput, LevesUncheckedCreateWithoutLeaveTypeInput> | LevesCreateWithoutLeaveTypeInput[] | LevesUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutLeaveTypeInput | LevesCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LevesCreateManyLeaveTypeInputEnvelope
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
  }

  export type LevesUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LevesCreateWithoutLeaveTypeInput, LevesUncheckedCreateWithoutLeaveTypeInput> | LevesCreateWithoutLeaveTypeInput[] | LevesUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutLeaveTypeInput | LevesCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LevesUpsertWithWhereUniqueWithoutLeaveTypeInput | LevesUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LevesCreateManyLeaveTypeInputEnvelope
    set?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    disconnect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    delete?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    update?: LevesUpdateWithWhereUniqueWithoutLeaveTypeInput | LevesUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LevesUpdateManyWithWhereWithoutLeaveTypeInput | LevesUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LevesScalarWhereInput | LevesScalarWhereInput[]
  }

  export type LevesUncheckedUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LevesCreateWithoutLeaveTypeInput, LevesUncheckedCreateWithoutLeaveTypeInput> | LevesCreateWithoutLeaveTypeInput[] | LevesUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LevesCreateOrConnectWithoutLeaveTypeInput | LevesCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LevesUpsertWithWhereUniqueWithoutLeaveTypeInput | LevesUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LevesCreateManyLeaveTypeInputEnvelope
    set?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    disconnect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    delete?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    connect?: LevesWhereUniqueInput | LevesWhereUniqueInput[]
    update?: LevesUpdateWithWhereUniqueWithoutLeaveTypeInput | LevesUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LevesUpdateManyWithWhereWithoutLeaveTypeInput | LevesUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LevesScalarWhereInput | LevesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLevesInput = {
    create?: XOR<UserCreateWithoutLevesInput, UserUncheckedCreateWithoutLevesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLevesInput
    connect?: UserWhereUniqueInput
  }

  export type LeaveTypeCreateNestedOneWithoutLevesInput = {
    create?: XOR<LeaveTypeCreateWithoutLevesInput, LeaveTypeUncheckedCreateWithoutLevesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLevesInput
    connect?: LeaveTypeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLevesNestedInput = {
    create?: XOR<UserCreateWithoutLevesInput, UserUncheckedCreateWithoutLevesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLevesInput
    upsert?: UserUpsertWithoutLevesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLevesInput, UserUpdateWithoutLevesInput>, UserUncheckedUpdateWithoutLevesInput>
  }

  export type LeaveTypeUpdateOneRequiredWithoutLevesNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutLevesInput, LeaveTypeUncheckedCreateWithoutLevesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLevesInput
    upsert?: LeaveTypeUpsertWithoutLevesInput
    connect?: LeaveTypeWhereUniqueInput
    update?: XOR<XOR<LeaveTypeUpdateToOneWithWhereWithoutLevesInput, LeaveTypeUpdateWithoutLevesInput>, LeaveTypeUncheckedUpdateWithoutLevesInput>
  }

  export type UserCreateNestedOneWithoutSalaryInfoInput = {
    create?: XOR<UserCreateWithoutSalaryInfoInput, UserUncheckedCreateWithoutSalaryInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryInfoInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalaryInfoNestedInput = {
    create?: XOR<UserCreateWithoutSalaryInfoInput, UserUncheckedCreateWithoutSalaryInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryInfoInput
    upsert?: UserUpsertWithoutSalaryInfoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryInfoInput, UserUpdateWithoutSalaryInfoInput>, UserUncheckedUpdateWithoutSalaryInfoInput>
  }

  export type UserCreateNestedOneWithoutPayrollInput = {
    create?: XOR<UserCreateWithoutPayrollInput, UserUncheckedCreateWithoutPayrollInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPayrollNestedInput = {
    create?: XOR<UserCreateWithoutPayrollInput, UserUncheckedCreateWithoutPayrollInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollInput
    upsert?: UserUpsertWithoutPayrollInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPayrollInput, UserUpdateWithoutPayrollInput>, UserUncheckedUpdateWithoutPayrollInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumPartyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartyType | EnumPartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartyType[]
    notIn?: $Enums.PartyType[]
    not?: NestedEnumPartyTypeFilter<$PrismaModel> | $Enums.PartyType
  }

  export type NestedEnumPartyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartyType | EnumPartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartyType[]
    notIn?: $Enums.PartyType[]
    not?: NestedEnumPartyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartyTypeFilter<$PrismaModel>
    _max?: NestedEnumPartyTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[]
    notIn?: $Enums.TargetType[]
    not?: NestedEnumTargetTypeFilter<$PrismaModel> | $Enums.TargetType
  }

  export type NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[]
    notIn?: $Enums.TargetType[]
    not?: NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumTargetTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[]
    notIn?: $Enums.VoucherType[]
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type NestedEnumPaymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | null
    notIn?: $Enums.PaymentType[] | null
    not?: NestedEnumPaymentTypeNullableFilter<$PrismaModel> | $Enums.PaymentType | null
  }

  export type NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[]
    notIn?: $Enums.VoucherType[]
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentType[] | null
    notIn?: $Enums.PaymentType[] | null
    not?: NestedEnumPaymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrdStatus | EnumOrdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrdStatus[]
    notIn?: $Enums.OrdStatus[]
    not?: NestedEnumOrdStatusFilter<$PrismaModel> | $Enums.OrdStatus
  }

  export type NestedEnumOrdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrdStatus | EnumOrdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrdStatus[]
    notIn?: $Enums.OrdStatus[]
    not?: NestedEnumOrdStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrdStatusFilter<$PrismaModel>
    _max?: NestedEnumOrdStatusFilter<$PrismaModel>
  }

  export type ProductWiseTargetCreateWithoutUserInput = {
    targetStart: Date | string
    targetEnd: Date | string
    targetType: $Enums.TargetType
    createdAt?: Date | string
    updatedAt?: Date | string
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductWiseTargetInput
  }

  export type ProductWiseTargetUncheckedCreateWithoutUserInput = {
    id?: number
    targetStart: Date | string
    targetEnd: Date | string
    targetType: $Enums.TargetType
    createdAt?: Date | string
    updatedAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductWiseTargetInput
  }

  export type ProductWiseTargetCreateOrConnectWithoutUserInput = {
    where: ProductWiseTargetWhereUniqueInput
    create: XOR<ProductWiseTargetCreateWithoutUserInput, ProductWiseTargetUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateWithoutUserInput = {
    date: Date | string
    time: string
    status: string
    comments: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    time: string
    status: string
    comments: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeProfileCreateWithoutUserInput = {
    fatherName: string
    motherName: string
    officeContactNo?: string | null
    currentAddress?: string | null
    permanentAddress?: string | null
    nid?: string | null
    dob: Date | string
    contactNo: string
    emergencyContactNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileUncheckedCreateWithoutUserInput = {
    id?: number
    fatherName: string
    motherName: string
    officeContactNo?: string | null
    currentAddress?: string | null
    permanentAddress?: string | null
    nid?: string | null
    dob: Date | string
    contactNo: string
    emergencyContactNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileCreateOrConnectWithoutUserInput = {
    where: EmployeeProfileWhereUniqueInput
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
  }

  export type LevesCreateWithoutUserInput = {
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveType: LeaveTypeCreateNestedOneWithoutLevesInput
  }

  export type LevesUncheckedCreateWithoutUserInput = {
    id?: number
    leaveTypeId: number
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevesCreateOrConnectWithoutUserInput = {
    where: LevesWhereUniqueInput
    create: XOR<LevesCreateWithoutUserInput, LevesUncheckedCreateWithoutUserInput>
  }

  export type LevesCreateManyUserInputEnvelope = {
    data: LevesCreateManyUserInput | LevesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MpoTargetCreateWithoutUserInput = {
    month: string
    tergatAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MpoTargetUncheckedCreateWithoutUserInput = {
    id?: number
    month: string
    tergatAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MpoTargetCreateOrConnectWithoutUserInput = {
    where: MpoTargetWhereUniqueInput
    create: XOR<MpoTargetCreateWithoutUserInput, MpoTargetUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateWithoutUserInput = {
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemCreateNestedManyWithoutOrderInput
    orderStatus?: OrderStatusCreateNestedManyWithoutOrderInput
    chemist: ChemistCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    chemistId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    orderStatus?: OrderStatusUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeCreateWithoutUserInput = {
    overtimeDate: Date | string
    overtimeHours: string
    others: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeUncheckedCreateWithoutUserInput = {
    id?: number
    overtimeDate: Date | string
    overtimeHours: string
    others: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateOrConnectWithoutUserInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput>
  }

  export type OvertimeCreateManyUserInputEnvelope = {
    data: OvertimeCreateManyUserInput | OvertimeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutUserInput = {
    payDate: Date | string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUncheckedCreateWithoutUserInput = {
    id?: number
    payDate: Date | string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutUserInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput>
  }

  export type PayrollCreateManyUserInputEnvelope = {
    data: PayrollCreateManyUserInput | PayrollCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalaryInfoCreateWithoutUserInput = {
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryInfoUncheckedCreateWithoutUserInput = {
    id?: number
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryInfoCreateOrConnectWithoutUserInput = {
    where: SalaryInfoWhereUniqueInput
    create: XOR<SalaryInfoCreateWithoutUserInput, SalaryInfoUncheckedCreateWithoutUserInput>
  }

  export type SalaryInfoCreateManyUserInputEnvelope = {
    data: SalaryInfoCreateManyUserInput | SalaryInfoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScopeCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutScopesInput
    depo?: DepoCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderCreateNestedManyWithoutScopesInput
    jobPost: JobPostCreateNestedOneWithoutScopeInput
  }

  export type ScopeUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutScopesInput
    depo?: DepoUncheckedCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderUncheckedCreateNestedManyWithoutScopesInput
  }

  export type ScopeCreateOrConnectWithoutUserInput = {
    where: ScopeWhereUniqueInput
    create: XOR<ScopeCreateWithoutUserInput, ScopeUncheckedCreateWithoutUserInput>
  }

  export type TransactionInfoCreateWithoutUserInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalCreateNestedManyWithoutTransactionInfoInput
    chemist?: ChemistCreateNestedOneWithoutTransactionInfoInput
    customers?: CustomersCreateNestedOneWithoutTransactionInfoInput
    party?: PartyCreateNestedOneWithoutTransactionInfoInput
    stakeholder?: StakeholderCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoCreateOrConnectWithoutUserInput = {
    where: TransactionInfoWhereUniqueInput
    create: XOR<TransactionInfoCreateWithoutUserInput, TransactionInfoUncheckedCreateWithoutUserInput>
  }

  export type TransactionInfoCreateManyUserInputEnvelope = {
    data: TransactionInfoCreateManyUserInput | TransactionInfoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutUserInput = {
    date: Date | string
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
    depo?: DepoCreateNestedOneWithoutInventoryInput
    fixedJournal?: FixedJournalCreateNestedOneWithoutInventoryInput
    product: ProductCreateNestedOneWithoutInventoryInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryCreateOrConnectWithoutUserInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutUserInput, InventoryUncheckedCreateWithoutUserInput>
  }

  export type InventoryCreateManyUserInputEnvelope = {
    data: InventoryCreateManyUserInput | InventoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductWiseTargetUpsertWithoutUserInput = {
    update: XOR<ProductWiseTargetUpdateWithoutUserInput, ProductWiseTargetUncheckedUpdateWithoutUserInput>
    create: XOR<ProductWiseTargetCreateWithoutUserInput, ProductWiseTargetUncheckedCreateWithoutUserInput>
    where?: ProductWiseTargetWhereInput
  }

  export type ProductWiseTargetUpdateToOneWithWhereWithoutUserInput = {
    where?: ProductWiseTargetWhereInput
    data: XOR<ProductWiseTargetUpdateWithoutUserInput, ProductWiseTargetUncheckedUpdateWithoutUserInput>
  }

  export type ProductWiseTargetUpdateWithoutUserInput = {
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductWiseTargetNestedInput
  }

  export type ProductWiseTargetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductWiseTargetNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: IntFilter<"Attendance"> | number
    employeeId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    time?: StringFilter<"Attendance"> | string
    status?: StringFilter<"Attendance"> | string
    comments?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type EmployeeProfileUpsertWithoutUserInput = {
    update: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    where?: EmployeeProfileWhereInput
  }

  export type EmployeeProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeProfileWhereInput
    data: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeProfileUpdateWithoutUserInput = {
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    officeContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNo?: StringFieldUpdateOperationsInput | string
    emergencyContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    officeContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNo?: StringFieldUpdateOperationsInput | string
    emergencyContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevesUpsertWithWhereUniqueWithoutUserInput = {
    where: LevesWhereUniqueInput
    update: XOR<LevesUpdateWithoutUserInput, LevesUncheckedUpdateWithoutUserInput>
    create: XOR<LevesCreateWithoutUserInput, LevesUncheckedCreateWithoutUserInput>
  }

  export type LevesUpdateWithWhereUniqueWithoutUserInput = {
    where: LevesWhereUniqueInput
    data: XOR<LevesUpdateWithoutUserInput, LevesUncheckedUpdateWithoutUserInput>
  }

  export type LevesUpdateManyWithWhereWithoutUserInput = {
    where: LevesScalarWhereInput
    data: XOR<LevesUpdateManyMutationInput, LevesUncheckedUpdateManyWithoutUserInput>
  }

  export type LevesScalarWhereInput = {
    AND?: LevesScalarWhereInput | LevesScalarWhereInput[]
    OR?: LevesScalarWhereInput[]
    NOT?: LevesScalarWhereInput | LevesScalarWhereInput[]
    id?: IntFilter<"Leves"> | number
    leaveTypeId?: IntFilter<"Leves"> | number
    employeeId?: StringFilter<"Leves"> | string
    startDate?: DateTimeFilter<"Leves"> | Date | string
    endDate?: DateTimeFilter<"Leves"> | Date | string
    leaveReason?: StringFilter<"Leves"> | string
    createdAt?: DateTimeFilter<"Leves"> | Date | string
    updatedAt?: DateTimeFilter<"Leves"> | Date | string
  }

  export type MpoTargetUpsertWithoutUserInput = {
    update: XOR<MpoTargetUpdateWithoutUserInput, MpoTargetUncheckedUpdateWithoutUserInput>
    create: XOR<MpoTargetCreateWithoutUserInput, MpoTargetUncheckedCreateWithoutUserInput>
    where?: MpoTargetWhereInput
  }

  export type MpoTargetUpdateToOneWithWhereWithoutUserInput = {
    where?: MpoTargetWhereInput
    data: XOR<MpoTargetUpdateWithoutUserInput, MpoTargetUncheckedUpdateWithoutUserInput>
  }

  export type MpoTargetUpdateWithoutUserInput = {
    month?: StringFieldUpdateOperationsInput | string
    tergatAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpoTargetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    tergatAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    employeeId?: StringFilter<"Order"> | string
    chemistId?: StringFilter<"Order"> | string
    orderNo?: StringFilter<"Order"> | string
    date?: DateTimeFilter<"Order"> | Date | string
    discount?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type OvertimeUpsertWithWhereUniqueWithoutUserInput = {
    where: OvertimeWhereUniqueInput
    update: XOR<OvertimeUpdateWithoutUserInput, OvertimeUncheckedUpdateWithoutUserInput>
    create: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput>
  }

  export type OvertimeUpdateWithWhereUniqueWithoutUserInput = {
    where: OvertimeWhereUniqueInput
    data: XOR<OvertimeUpdateWithoutUserInput, OvertimeUncheckedUpdateWithoutUserInput>
  }

  export type OvertimeUpdateManyWithWhereWithoutUserInput = {
    where: OvertimeScalarWhereInput
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyWithoutUserInput>
  }

  export type OvertimeScalarWhereInput = {
    AND?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
    OR?: OvertimeScalarWhereInput[]
    NOT?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
    id?: IntFilter<"Overtime"> | number
    employeeId?: StringFilter<"Overtime"> | string
    overtimeDate?: DateTimeFilter<"Overtime"> | Date | string
    overtimeHours?: StringFilter<"Overtime"> | string
    others?: StringFilter<"Overtime"> | string
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutUserInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutUserInput, PayrollUncheckedUpdateWithoutUserInput>
    create: XOR<PayrollCreateWithoutUserInput, PayrollUncheckedCreateWithoutUserInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutUserInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutUserInput, PayrollUncheckedUpdateWithoutUserInput>
  }

  export type PayrollUpdateManyWithWhereWithoutUserInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutUserInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: IntFilter<"Payroll"> | number
    employeeId?: StringFilter<"Payroll"> | string
    payDate?: DateTimeFilter<"Payroll"> | Date | string
    basicSalary?: FloatFilter<"Payroll"> | number
    houseRend?: FloatFilter<"Payroll"> | number
    mobile?: FloatFilter<"Payroll"> | number
    medial?: FloatFilter<"Payroll"> | number
    taDa?: FloatFilter<"Payroll"> | number
    insentive?: FloatFilter<"Payroll"> | number
    eidBonus?: FloatFilter<"Payroll"> | number
    boishakhi?: FloatFilter<"Payroll"> | number
    others?: FloatFilter<"Payroll"> | number
    fp?: FloatFilter<"Payroll"> | number
    insurance?: FloatFilter<"Payroll"> | number
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
  }

  export type SalaryInfoUpsertWithWhereUniqueWithoutUserInput = {
    where: SalaryInfoWhereUniqueInput
    update: XOR<SalaryInfoUpdateWithoutUserInput, SalaryInfoUncheckedUpdateWithoutUserInput>
    create: XOR<SalaryInfoCreateWithoutUserInput, SalaryInfoUncheckedCreateWithoutUserInput>
  }

  export type SalaryInfoUpdateWithWhereUniqueWithoutUserInput = {
    where: SalaryInfoWhereUniqueInput
    data: XOR<SalaryInfoUpdateWithoutUserInput, SalaryInfoUncheckedUpdateWithoutUserInput>
  }

  export type SalaryInfoUpdateManyWithWhereWithoutUserInput = {
    where: SalaryInfoScalarWhereInput
    data: XOR<SalaryInfoUpdateManyMutationInput, SalaryInfoUncheckedUpdateManyWithoutUserInput>
  }

  export type SalaryInfoScalarWhereInput = {
    AND?: SalaryInfoScalarWhereInput | SalaryInfoScalarWhereInput[]
    OR?: SalaryInfoScalarWhereInput[]
    NOT?: SalaryInfoScalarWhereInput | SalaryInfoScalarWhereInput[]
    id?: IntFilter<"SalaryInfo"> | number
    employeeId?: StringFilter<"SalaryInfo"> | string
    basicSalary?: FloatFilter<"SalaryInfo"> | number
    houseRend?: FloatFilter<"SalaryInfo"> | number
    mobile?: FloatFilter<"SalaryInfo"> | number
    medial?: FloatFilter<"SalaryInfo"> | number
    taDa?: FloatFilter<"SalaryInfo"> | number
    insuranceAmount?: FloatFilter<"SalaryInfo"> | number
    createdAt?: DateTimeFilter<"SalaryInfo"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryInfo"> | Date | string
  }

  export type ScopeUpsertWithoutUserInput = {
    update: XOR<ScopeUpdateWithoutUserInput, ScopeUncheckedUpdateWithoutUserInput>
    create: XOR<ScopeCreateWithoutUserInput, ScopeUncheckedCreateWithoutUserInput>
    where?: ScopeWhereInput
  }

  export type ScopeUpdateToOneWithWhereWithoutUserInput = {
    where?: ScopeWhereInput
    data: XOR<ScopeUpdateWithoutUserInput, ScopeUncheckedUpdateWithoutUserInput>
  }

  export type ScopeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutScopesNestedInput
    depo?: DepoUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUpdateManyWithoutScopesNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutScopeNestedInput
  }

  export type ScopeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutScopesNestedInput
    depo?: DepoUncheckedUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUncheckedUpdateManyWithoutScopesNestedInput
  }

  export type TransactionInfoUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionInfoWhereUniqueInput
    update: XOR<TransactionInfoUpdateWithoutUserInput, TransactionInfoUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionInfoCreateWithoutUserInput, TransactionInfoUncheckedCreateWithoutUserInput>
  }

  export type TransactionInfoUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionInfoWhereUniqueInput
    data: XOR<TransactionInfoUpdateWithoutUserInput, TransactionInfoUncheckedUpdateWithoutUserInput>
  }

  export type TransactionInfoUpdateManyWithWhereWithoutUserInput = {
    where: TransactionInfoScalarWhereInput
    data: XOR<TransactionInfoUpdateManyMutationInput, TransactionInfoUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionInfoScalarWhereInput = {
    AND?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
    OR?: TransactionInfoScalarWhereInput[]
    NOT?: TransactionInfoScalarWhereInput | TransactionInfoScalarWhereInput[]
    id?: IntFilter<"TransactionInfo"> | number
    date?: DateTimeFilter<"TransactionInfo"> | Date | string
    voucherNo?: StringFilter<"TransactionInfo"> | string
    invoiceNo?: StringNullableFilter<"TransactionInfo"> | string | null
    chemistId?: StringNullableFilter<"TransactionInfo"> | string | null
    customerId?: IntNullableFilter<"TransactionInfo"> | number | null
    stakeholderId?: StringNullableFilter<"TransactionInfo"> | string | null
    employeeId?: StringNullableFilter<"TransactionInfo"> | string | null
    partyId?: IntNullableFilter<"TransactionInfo"> | number | null
    voucherType?: EnumVoucherTypeFilter<"TransactionInfo"> | $Enums.VoucherType
    paymentType?: EnumPaymentTypeNullableFilter<"TransactionInfo"> | $Enums.PaymentType | null
    status?: EnumStatusFilter<"TransactionInfo"> | $Enums.Status
    createdAt?: DateTimeFilter<"TransactionInfo"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionInfo"> | Date | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutUserInput, InventoryUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryCreateWithoutUserInput, InventoryUncheckedCreateWithoutUserInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutUserInput, InventoryUncheckedUpdateWithoutUserInput>
  }

  export type InventoryUpdateManyWithWhereWithoutUserInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: IntFilter<"Inventory"> | number
    date?: DateTimeFilter<"Inventory"> | Date | string
    productId?: IntFilter<"Inventory"> | number
    depoId?: IntNullableFilter<"Inventory"> | number | null
    employeeId?: StringNullableFilter<"Inventory"> | string | null
    transactionId?: IntNullableFilter<"Inventory"> | number | null
    fixedJournalId?: IntNullableFilter<"Inventory"> | number | null
    unitPrice?: FloatFilter<"Inventory"> | number
    quantityAdd?: FloatNullableFilter<"Inventory"> | number | null
    quantityLess?: FloatNullableFilter<"Inventory"> | number | null
    debitAmount?: FloatNullableFilter<"Inventory"> | number | null
    creditAmount?: FloatNullableFilter<"Inventory"> | number | null
    isClosing?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    isFixted?: BoolFilter<"Inventory"> | boolean
  }

  export type UserCreateWithoutEmployeeProfileInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmployeeProfileInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmployeeProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
  }

  export type UserUpsertWithoutEmployeeProfileInput = {
    update: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type UserUpdateWithoutEmployeeProfileInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DepoCreateWithoutJobPostInput = {
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutDepoInput
    inventory?: InventoryCreateNestedManyWithoutDepoInput
    journal?: JournalCreateNestedManyWithoutDepoInput
    scopes?: ScopeCreateNestedManyWithoutDepoInput
  }

  export type DepoUncheckedCreateWithoutJobPostInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutDepoInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutDepoInput
    journal?: JournalUncheckedCreateNestedManyWithoutDepoInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutDepoInput
  }

  export type DepoCreateOrConnectWithoutJobPostInput = {
    where: DepoWhereUniqueInput
    create: XOR<DepoCreateWithoutJobPostInput, DepoUncheckedCreateWithoutJobPostInput>
  }

  export type ScopeCreateWithoutJobPostInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutScopesInput
    depo?: DepoCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderCreateNestedManyWithoutScopesInput
    user: UserCreateNestedOneWithoutScopeInput
  }

  export type ScopeUncheckedCreateWithoutJobPostInput = {
    id?: number
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutScopesInput
    depo?: DepoUncheckedCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderUncheckedCreateNestedManyWithoutScopesInput
  }

  export type ScopeCreateOrConnectWithoutJobPostInput = {
    where: ScopeWhereUniqueInput
    create: XOR<ScopeCreateWithoutJobPostInput, ScopeUncheckedCreateWithoutJobPostInput>
  }

  export type ScopeCreateManyJobPostInputEnvelope = {
    data: ScopeCreateManyJobPostInput | ScopeCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type DepoUpsertWithoutJobPostInput = {
    update: XOR<DepoUpdateWithoutJobPostInput, DepoUncheckedUpdateWithoutJobPostInput>
    create: XOR<DepoCreateWithoutJobPostInput, DepoUncheckedCreateWithoutJobPostInput>
    where?: DepoWhereInput
  }

  export type DepoUpdateToOneWithWhereWithoutJobPostInput = {
    where?: DepoWhereInput
    data: XOR<DepoUpdateWithoutJobPostInput, DepoUncheckedUpdateWithoutJobPostInput>
  }

  export type DepoUpdateWithoutJobPostInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUpdateManyWithoutDepoNestedInput
    journal?: JournalUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateWithoutJobPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutDepoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutDepoNestedInput
  }

  export type ScopeUpsertWithWhereUniqueWithoutJobPostInput = {
    where: ScopeWhereUniqueInput
    update: XOR<ScopeUpdateWithoutJobPostInput, ScopeUncheckedUpdateWithoutJobPostInput>
    create: XOR<ScopeCreateWithoutJobPostInput, ScopeUncheckedCreateWithoutJobPostInput>
  }

  export type ScopeUpdateWithWhereUniqueWithoutJobPostInput = {
    where: ScopeWhereUniqueInput
    data: XOR<ScopeUpdateWithoutJobPostInput, ScopeUncheckedUpdateWithoutJobPostInput>
  }

  export type ScopeUpdateManyWithWhereWithoutJobPostInput = {
    where: ScopeScalarWhereInput
    data: XOR<ScopeUpdateManyMutationInput, ScopeUncheckedUpdateManyWithoutJobPostInput>
  }

  export type ScopeScalarWhereInput = {
    AND?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
    OR?: ScopeScalarWhereInput[]
    NOT?: ScopeScalarWhereInput | ScopeScalarWhereInput[]
    id?: IntFilter<"Scope"> | number
    employeeId?: StringFilter<"Scope"> | string
    postId?: IntFilter<"Scope"> | number
    createdAt?: DateTimeFilter<"Scope"> | Date | string
    updatedAt?: DateTimeFilter<"Scope"> | Date | string
  }

  export type DepoCreateWithoutChemistInput = {
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    FixedJournal?: FixedJournalCreateNestedManyWithoutDepoInput
    inventory?: InventoryCreateNestedManyWithoutDepoInput
    jobPost?: JobPostCreateNestedManyWithoutDepoInput
    journal?: JournalCreateNestedManyWithoutDepoInput
    scopes?: ScopeCreateNestedManyWithoutDepoInput
  }

  export type DepoUncheckedCreateWithoutChemistInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutDepoInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutDepoInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutDepoInput
    journal?: JournalUncheckedCreateNestedManyWithoutDepoInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutDepoInput
  }

  export type DepoCreateOrConnectWithoutChemistInput = {
    where: DepoWhereUniqueInput
    create: XOR<DepoCreateWithoutChemistInput, DepoUncheckedCreateWithoutChemistInput>
  }

  export type ScopeCreateWithoutChemistInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    depo?: DepoCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderCreateNestedManyWithoutScopesInput
    user: UserCreateNestedOneWithoutScopeInput
    jobPost: JobPostCreateNestedOneWithoutScopeInput
  }

  export type ScopeUncheckedCreateWithoutChemistInput = {
    id?: number
    employeeId: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    depo?: DepoUncheckedCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderUncheckedCreateNestedManyWithoutScopesInput
  }

  export type ScopeCreateOrConnectWithoutChemistInput = {
    where: ScopeWhereUniqueInput
    create: XOR<ScopeCreateWithoutChemistInput, ScopeUncheckedCreateWithoutChemistInput>
  }

  export type FixedJournalCreateWithoutChemistInput = {
    date: Date | string
    voucherNo: string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutFixedJournalInput
    ledgerHead: LedgerHeadCreateNestedOneWithoutFixedJournalInput
    inventory?: InventoryCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalUncheckedCreateWithoutChemistInput = {
    id?: number
    date: Date | string
    voucherNo: string
    ledgerHeadId: number
    depoId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalCreateOrConnectWithoutChemistInput = {
    where: FixedJournalWhereUniqueInput
    create: XOR<FixedJournalCreateWithoutChemistInput, FixedJournalUncheckedCreateWithoutChemistInput>
  }

  export type FixedJournalCreateManyChemistInputEnvelope = {
    data: FixedJournalCreateManyChemistInput | FixedJournalCreateManyChemistInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutChemistInput = {
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemCreateNestedManyWithoutOrderInput
    orderStatus?: OrderStatusCreateNestedManyWithoutOrderInput
    user: UserCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutChemistInput = {
    id?: number
    employeeId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    orderStatus?: OrderStatusUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutChemistInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutChemistInput, OrderUncheckedCreateWithoutChemistInput>
  }

  export type OrderCreateManyChemistInputEnvelope = {
    data: OrderCreateManyChemistInput | OrderCreateManyChemistInput[]
    skipDuplicates?: boolean
  }

  export type TransactionInfoCreateWithoutChemistInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalCreateNestedManyWithoutTransactionInfoInput
    customers?: CustomersCreateNestedOneWithoutTransactionInfoInput
    user?: UserCreateNestedOneWithoutTransactionInfoInput
    party?: PartyCreateNestedOneWithoutTransactionInfoInput
    stakeholder?: StakeholderCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateWithoutChemistInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoCreateOrConnectWithoutChemistInput = {
    where: TransactionInfoWhereUniqueInput
    create: XOR<TransactionInfoCreateWithoutChemistInput, TransactionInfoUncheckedCreateWithoutChemistInput>
  }

  export type TransactionInfoCreateManyChemistInputEnvelope = {
    data: TransactionInfoCreateManyChemistInput | TransactionInfoCreateManyChemistInput[]
    skipDuplicates?: boolean
  }

  export type DepoUpsertWithoutChemistInput = {
    update: XOR<DepoUpdateWithoutChemistInput, DepoUncheckedUpdateWithoutChemistInput>
    create: XOR<DepoCreateWithoutChemistInput, DepoUncheckedCreateWithoutChemistInput>
    where?: DepoWhereInput
  }

  export type DepoUpdateToOneWithWhereWithoutChemistInput = {
    where?: DepoWhereInput
    data: XOR<DepoUpdateWithoutChemistInput, DepoUncheckedUpdateWithoutChemistInput>
  }

  export type DepoUpdateWithoutChemistInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FixedJournal?: FixedJournalUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUpdateManyWithoutDepoNestedInput
    journal?: JournalUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutDepoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutDepoNestedInput
  }

  export type ScopeUpsertWithWhereUniqueWithoutChemistInput = {
    where: ScopeWhereUniqueInput
    update: XOR<ScopeUpdateWithoutChemistInput, ScopeUncheckedUpdateWithoutChemistInput>
    create: XOR<ScopeCreateWithoutChemistInput, ScopeUncheckedCreateWithoutChemistInput>
  }

  export type ScopeUpdateWithWhereUniqueWithoutChemistInput = {
    where: ScopeWhereUniqueInput
    data: XOR<ScopeUpdateWithoutChemistInput, ScopeUncheckedUpdateWithoutChemistInput>
  }

  export type ScopeUpdateManyWithWhereWithoutChemistInput = {
    where: ScopeScalarWhereInput
    data: XOR<ScopeUpdateManyMutationInput, ScopeUncheckedUpdateManyWithoutChemistInput>
  }

  export type FixedJournalUpsertWithWhereUniqueWithoutChemistInput = {
    where: FixedJournalWhereUniqueInput
    update: XOR<FixedJournalUpdateWithoutChemistInput, FixedJournalUncheckedUpdateWithoutChemistInput>
    create: XOR<FixedJournalCreateWithoutChemistInput, FixedJournalUncheckedCreateWithoutChemistInput>
  }

  export type FixedJournalUpdateWithWhereUniqueWithoutChemistInput = {
    where: FixedJournalWhereUniqueInput
    data: XOR<FixedJournalUpdateWithoutChemistInput, FixedJournalUncheckedUpdateWithoutChemistInput>
  }

  export type FixedJournalUpdateManyWithWhereWithoutChemistInput = {
    where: FixedJournalScalarWhereInput
    data: XOR<FixedJournalUpdateManyMutationInput, FixedJournalUncheckedUpdateManyWithoutChemistInput>
  }

  export type FixedJournalScalarWhereInput = {
    AND?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
    OR?: FixedJournalScalarWhereInput[]
    NOT?: FixedJournalScalarWhereInput | FixedJournalScalarWhereInput[]
    id?: IntFilter<"FixedJournal"> | number
    date?: DateTimeFilter<"FixedJournal"> | Date | string
    voucherNo?: StringFilter<"FixedJournal"> | string
    chemistId?: StringFilter<"FixedJournal"> | string
    ledgerHeadId?: IntFilter<"FixedJournal"> | number
    depoId?: IntFilter<"FixedJournal"> | number
    creditAmount?: FloatNullableFilter<"FixedJournal"> | number | null
    debitAmount?: FloatNullableFilter<"FixedJournal"> | number | null
    narration?: StringNullableFilter<"FixedJournal"> | string | null
    isClosing?: BoolFilter<"FixedJournal"> | boolean
    createdAt?: DateTimeFilter<"FixedJournal"> | Date | string
    updatedAt?: DateTimeFilter<"FixedJournal"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutChemistInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutChemistInput, OrderUncheckedUpdateWithoutChemistInput>
    create: XOR<OrderCreateWithoutChemistInput, OrderUncheckedCreateWithoutChemistInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutChemistInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutChemistInput, OrderUncheckedUpdateWithoutChemistInput>
  }

  export type OrderUpdateManyWithWhereWithoutChemistInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutChemistInput>
  }

  export type TransactionInfoUpsertWithWhereUniqueWithoutChemistInput = {
    where: TransactionInfoWhereUniqueInput
    update: XOR<TransactionInfoUpdateWithoutChemistInput, TransactionInfoUncheckedUpdateWithoutChemistInput>
    create: XOR<TransactionInfoCreateWithoutChemistInput, TransactionInfoUncheckedCreateWithoutChemistInput>
  }

  export type TransactionInfoUpdateWithWhereUniqueWithoutChemistInput = {
    where: TransactionInfoWhereUniqueInput
    data: XOR<TransactionInfoUpdateWithoutChemistInput, TransactionInfoUncheckedUpdateWithoutChemistInput>
  }

  export type TransactionInfoUpdateManyWithWhereWithoutChemistInput = {
    where: TransactionInfoScalarWhereInput
    data: XOR<TransactionInfoUpdateManyMutationInput, TransactionInfoUncheckedUpdateManyWithoutChemistInput>
  }

  export type ChemistCreateWithoutDepoInput = {
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ScopeCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutChemistInput
    order?: OrderCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutChemistInput
  }

  export type ChemistUncheckedCreateWithoutDepoInput = {
    id?: number
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ScopeUncheckedCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutChemistInput
    order?: OrderUncheckedCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutChemistInput
  }

  export type ChemistCreateOrConnectWithoutDepoInput = {
    where: ChemistWhereUniqueInput
    create: XOR<ChemistCreateWithoutDepoInput, ChemistUncheckedCreateWithoutDepoInput>
  }

  export type ChemistCreateManyDepoInputEnvelope = {
    data: ChemistCreateManyDepoInput | ChemistCreateManyDepoInput[]
    skipDuplicates?: boolean
  }

  export type FixedJournalCreateWithoutDepoInput = {
    date: Date | string
    voucherNo: string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist: ChemistCreateNestedOneWithoutFixedJournalInput
    ledgerHead: LedgerHeadCreateNestedOneWithoutFixedJournalInput
    inventory?: InventoryCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalUncheckedCreateWithoutDepoInput = {
    id?: number
    date: Date | string
    voucherNo: string
    chemistId: string
    ledgerHeadId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalCreateOrConnectWithoutDepoInput = {
    where: FixedJournalWhereUniqueInput
    create: XOR<FixedJournalCreateWithoutDepoInput, FixedJournalUncheckedCreateWithoutDepoInput>
  }

  export type FixedJournalCreateManyDepoInputEnvelope = {
    data: FixedJournalCreateManyDepoInput | FixedJournalCreateManyDepoInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutDepoInput = {
    date: Date | string
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
    fixedJournal?: FixedJournalCreateNestedOneWithoutInventoryInput
    product: ProductCreateNestedOneWithoutInventoryInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutInventoryInput
    user?: UserCreateNestedOneWithoutInventoriesInput
  }

  export type InventoryUncheckedCreateWithoutDepoInput = {
    id?: number
    date: Date | string
    productId: number
    employeeId?: string | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryCreateOrConnectWithoutDepoInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutDepoInput, InventoryUncheckedCreateWithoutDepoInput>
  }

  export type InventoryCreateManyDepoInputEnvelope = {
    data: InventoryCreateManyDepoInput | InventoryCreateManyDepoInput[]
    skipDuplicates?: boolean
  }

  export type JobPostCreateWithoutDepoInput = {
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: ScopeCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutDepoInput = {
    id?: number
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: ScopeUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutDepoInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutDepoInput, JobPostUncheckedCreateWithoutDepoInput>
  }

  export type JobPostCreateManyDepoInputEnvelope = {
    data: JobPostCreateManyDepoInput | JobPostCreateManyDepoInput[]
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutDepoInput = {
    date: Date | string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerHead?: LedgerHeadCreateNestedOneWithoutJournalInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutJournalInput
    bankTransaction?: BankTransactionCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutDepoInput = {
    id?: number
    transactionId?: number | null
    ledgerHeadId?: number | null
    date: Date | string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransaction?: BankTransactionUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalCreateOrConnectWithoutDepoInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutDepoInput, JournalUncheckedCreateWithoutDepoInput>
  }

  export type JournalCreateManyDepoInputEnvelope = {
    data: JournalCreateManyDepoInput | JournalCreateManyDepoInput[]
    skipDuplicates?: boolean
  }

  export type ScopeCreateWithoutDepoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderCreateNestedManyWithoutScopesInput
    user: UserCreateNestedOneWithoutScopeInput
    jobPost: JobPostCreateNestedOneWithoutScopeInput
  }

  export type ScopeUncheckedCreateWithoutDepoInput = {
    id?: number
    employeeId: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutScopesInput
    stakeholder?: StakeholderUncheckedCreateNestedManyWithoutScopesInput
  }

  export type ScopeCreateOrConnectWithoutDepoInput = {
    where: ScopeWhereUniqueInput
    create: XOR<ScopeCreateWithoutDepoInput, ScopeUncheckedCreateWithoutDepoInput>
  }

  export type ChemistUpsertWithWhereUniqueWithoutDepoInput = {
    where: ChemistWhereUniqueInput
    update: XOR<ChemistUpdateWithoutDepoInput, ChemistUncheckedUpdateWithoutDepoInput>
    create: XOR<ChemistCreateWithoutDepoInput, ChemistUncheckedCreateWithoutDepoInput>
  }

  export type ChemistUpdateWithWhereUniqueWithoutDepoInput = {
    where: ChemistWhereUniqueInput
    data: XOR<ChemistUpdateWithoutDepoInput, ChemistUncheckedUpdateWithoutDepoInput>
  }

  export type ChemistUpdateManyWithWhereWithoutDepoInput = {
    where: ChemistScalarWhereInput
    data: XOR<ChemistUpdateManyMutationInput, ChemistUncheckedUpdateManyWithoutDepoInput>
  }

  export type ChemistScalarWhereInput = {
    AND?: ChemistScalarWhereInput | ChemistScalarWhereInput[]
    OR?: ChemistScalarWhereInput[]
    NOT?: ChemistScalarWhereInput | ChemistScalarWhereInput[]
    id?: IntFilter<"Chemist"> | number
    chemistId?: StringFilter<"Chemist"> | string
    depoId?: IntFilter<"Chemist"> | number
    pharmacyName?: StringFilter<"Chemist"> | string
    contactPerson?: StringFilter<"Chemist"> | string
    contactNo?: StringFilter<"Chemist"> | string
    address?: StringFilter<"Chemist"> | string
    photo?: StringNullableFilter<"Chemist"> | string | null
    discountRate?: IntNullableFilter<"Chemist"> | number | null
    openingDueAmount?: FloatNullableFilter<"Chemist"> | number | null
    openingDate?: DateTimeFilter<"Chemist"> | Date | string
    isDeleted?: BoolFilter<"Chemist"> | boolean
    createdAt?: DateTimeFilter<"Chemist"> | Date | string
    updatedAt?: DateTimeFilter<"Chemist"> | Date | string
  }

  export type FixedJournalUpsertWithWhereUniqueWithoutDepoInput = {
    where: FixedJournalWhereUniqueInput
    update: XOR<FixedJournalUpdateWithoutDepoInput, FixedJournalUncheckedUpdateWithoutDepoInput>
    create: XOR<FixedJournalCreateWithoutDepoInput, FixedJournalUncheckedCreateWithoutDepoInput>
  }

  export type FixedJournalUpdateWithWhereUniqueWithoutDepoInput = {
    where: FixedJournalWhereUniqueInput
    data: XOR<FixedJournalUpdateWithoutDepoInput, FixedJournalUncheckedUpdateWithoutDepoInput>
  }

  export type FixedJournalUpdateManyWithWhereWithoutDepoInput = {
    where: FixedJournalScalarWhereInput
    data: XOR<FixedJournalUpdateManyMutationInput, FixedJournalUncheckedUpdateManyWithoutDepoInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutDepoInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutDepoInput, InventoryUncheckedUpdateWithoutDepoInput>
    create: XOR<InventoryCreateWithoutDepoInput, InventoryUncheckedCreateWithoutDepoInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutDepoInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutDepoInput, InventoryUncheckedUpdateWithoutDepoInput>
  }

  export type InventoryUpdateManyWithWhereWithoutDepoInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutDepoInput>
  }

  export type JobPostUpsertWithWhereUniqueWithoutDepoInput = {
    where: JobPostWhereUniqueInput
    update: XOR<JobPostUpdateWithoutDepoInput, JobPostUncheckedUpdateWithoutDepoInput>
    create: XOR<JobPostCreateWithoutDepoInput, JobPostUncheckedCreateWithoutDepoInput>
  }

  export type JobPostUpdateWithWhereUniqueWithoutDepoInput = {
    where: JobPostWhereUniqueInput
    data: XOR<JobPostUpdateWithoutDepoInput, JobPostUncheckedUpdateWithoutDepoInput>
  }

  export type JobPostUpdateManyWithWhereWithoutDepoInput = {
    where: JobPostScalarWhereInput
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyWithoutDepoInput>
  }

  export type JobPostScalarWhereInput = {
    AND?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
    OR?: JobPostScalarWhereInput[]
    NOT?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
    id?: IntFilter<"JobPost"> | number
    depoId?: IntFilter<"JobPost"> | number
    postName?: StringFilter<"JobPost"> | string
    qualification?: StringFilter<"JobPost"> | string
    responsibility?: StringFilter<"JobPost"> | string
    isDelete?: BoolFilter<"JobPost"> | boolean
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    updatedAt?: DateTimeFilter<"JobPost"> | Date | string
  }

  export type JournalUpsertWithWhereUniqueWithoutDepoInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutDepoInput, JournalUncheckedUpdateWithoutDepoInput>
    create: XOR<JournalCreateWithoutDepoInput, JournalUncheckedCreateWithoutDepoInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutDepoInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutDepoInput, JournalUncheckedUpdateWithoutDepoInput>
  }

  export type JournalUpdateManyWithWhereWithoutDepoInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutDepoInput>
  }

  export type JournalScalarWhereInput = {
    AND?: JournalScalarWhereInput | JournalScalarWhereInput[]
    OR?: JournalScalarWhereInput[]
    NOT?: JournalScalarWhereInput | JournalScalarWhereInput[]
    id?: IntFilter<"Journal"> | number
    transactionId?: IntNullableFilter<"Journal"> | number | null
    ledgerHeadId?: IntNullableFilter<"Journal"> | number | null
    date?: DateTimeFilter<"Journal"> | Date | string
    depoId?: IntNullableFilter<"Journal"> | number | null
    creditAmount?: FloatNullableFilter<"Journal"> | number | null
    debitAmount?: FloatNullableFilter<"Journal"> | number | null
    narration?: StringNullableFilter<"Journal"> | string | null
    isClosing?: BoolFilter<"Journal"> | boolean
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    updatedAt?: DateTimeFilter<"Journal"> | Date | string
  }

  export type ScopeUpsertWithWhereUniqueWithoutDepoInput = {
    where: ScopeWhereUniqueInput
    update: XOR<ScopeUpdateWithoutDepoInput, ScopeUncheckedUpdateWithoutDepoInput>
    create: XOR<ScopeCreateWithoutDepoInput, ScopeUncheckedCreateWithoutDepoInput>
  }

  export type ScopeUpdateWithWhereUniqueWithoutDepoInput = {
    where: ScopeWhereUniqueInput
    data: XOR<ScopeUpdateWithoutDepoInput, ScopeUncheckedUpdateWithoutDepoInput>
  }

  export type ScopeUpdateManyWithWhereWithoutDepoInput = {
    where: ScopeScalarWhereInput
    data: XOR<ScopeUpdateManyMutationInput, ScopeUncheckedUpdateManyWithoutDepoInput>
  }

  export type TransactionInfoCreateWithoutPartyInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalCreateNestedManyWithoutTransactionInfoInput
    chemist?: ChemistCreateNestedOneWithoutTransactionInfoInput
    customers?: CustomersCreateNestedOneWithoutTransactionInfoInput
    user?: UserCreateNestedOneWithoutTransactionInfoInput
    stakeholder?: StakeholderCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateWithoutPartyInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoCreateOrConnectWithoutPartyInput = {
    where: TransactionInfoWhereUniqueInput
    create: XOR<TransactionInfoCreateWithoutPartyInput, TransactionInfoUncheckedCreateWithoutPartyInput>
  }

  export type TransactionInfoCreateManyPartyInputEnvelope = {
    data: TransactionInfoCreateManyPartyInput | TransactionInfoCreateManyPartyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionInfoUpsertWithWhereUniqueWithoutPartyInput = {
    where: TransactionInfoWhereUniqueInput
    update: XOR<TransactionInfoUpdateWithoutPartyInput, TransactionInfoUncheckedUpdateWithoutPartyInput>
    create: XOR<TransactionInfoCreateWithoutPartyInput, TransactionInfoUncheckedCreateWithoutPartyInput>
  }

  export type TransactionInfoUpdateWithWhereUniqueWithoutPartyInput = {
    where: TransactionInfoWhereUniqueInput
    data: XOR<TransactionInfoUpdateWithoutPartyInput, TransactionInfoUncheckedUpdateWithoutPartyInput>
  }

  export type TransactionInfoUpdateManyWithWhereWithoutPartyInput = {
    where: TransactionInfoScalarWhereInput
    data: XOR<TransactionInfoUpdateManyMutationInput, TransactionInfoUncheckedUpdateManyWithoutPartyInput>
  }

  export type ProductCreateWithoutStakeholderInput = {
    name: string
    description: string
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    orderItem?: OrderItemCreateNestedManyWithoutProductInput
    subCategory: SubCategoryCreateNestedOneWithoutProductInput
    unit: UnitCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStakeholderInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStakeholderInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStakeholderInput, ProductUncheckedCreateWithoutStakeholderInput>
  }

  export type ProductCreateManyStakeholderInputEnvelope = {
    data: ProductCreateManyStakeholderInput | ProductCreateManyStakeholderInput[]
    skipDuplicates?: boolean
  }

  export type StakeholderDegreeCreateWithoutStakeholderInput = {
    degreeName: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderDegreeUncheckedCreateWithoutStakeholderInput = {
    id?: number
    degreeName: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderDegreeCreateOrConnectWithoutStakeholderInput = {
    where: StakeholderDegreeWhereUniqueInput
    create: XOR<StakeholderDegreeCreateWithoutStakeholderInput, StakeholderDegreeUncheckedCreateWithoutStakeholderInput>
  }

  export type StakeholderDeisgnationCreateWithoutStakeholderInput = {
    designation: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderDeisgnationUncheckedCreateWithoutStakeholderInput = {
    id?: number
    designation: string
    description?: string | null
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderDeisgnationCreateOrConnectWithoutStakeholderInput = {
    where: StakeholderDeisgnationWhereUniqueInput
    create: XOR<StakeholderDeisgnationCreateWithoutStakeholderInput, StakeholderDeisgnationUncheckedCreateWithoutStakeholderInput>
  }

  export type ScopeCreateWithoutStakeholderInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutScopesInput
    depo?: DepoCreateNestedManyWithoutScopesInput
    user: UserCreateNestedOneWithoutScopeInput
    jobPost: JobPostCreateNestedOneWithoutScopeInput
  }

  export type ScopeUncheckedCreateWithoutStakeholderInput = {
    id?: number
    employeeId: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutScopesInput
    depo?: DepoUncheckedCreateNestedManyWithoutScopesInput
  }

  export type ScopeCreateOrConnectWithoutStakeholderInput = {
    where: ScopeWhereUniqueInput
    create: XOR<ScopeCreateWithoutStakeholderInput, ScopeUncheckedCreateWithoutStakeholderInput>
  }

  export type stakeholderChemberCreateWithoutStakeholderInput = {
    address: string
    chemberDay: string
    chemberTime: string
    chemberName: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type stakeholderChemberUncheckedCreateWithoutStakeholderInput = {
    id?: number
    address: string
    chemberDay: string
    chemberTime: string
    chemberName: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type stakeholderChemberCreateOrConnectWithoutStakeholderInput = {
    where: stakeholderChemberWhereUniqueInput
    create: XOR<stakeholderChemberCreateWithoutStakeholderInput, stakeholderChemberUncheckedCreateWithoutStakeholderInput>
  }

  export type stakeholderChemberCreateManyStakeholderInputEnvelope = {
    data: stakeholderChemberCreateManyStakeholderInput | stakeholderChemberCreateManyStakeholderInput[]
    skipDuplicates?: boolean
  }

  export type StakeholderOcationCreateWithoutStakeholderInput = {
    ocationName: string
    relation: string
    personName?: string | null
    dob?: Date | string | null
    otherInfo?: string | null
  }

  export type StakeholderOcationUncheckedCreateWithoutStakeholderInput = {
    id?: number
    ocationName: string
    relation: string
    personName?: string | null
    dob?: Date | string | null
    otherInfo?: string | null
  }

  export type StakeholderOcationCreateOrConnectWithoutStakeholderInput = {
    where: StakeholderOcationWhereUniqueInput
    create: XOR<StakeholderOcationCreateWithoutStakeholderInput, StakeholderOcationUncheckedCreateWithoutStakeholderInput>
  }

  export type StakeholderOcationCreateManyStakeholderInputEnvelope = {
    data: StakeholderOcationCreateManyStakeholderInput | StakeholderOcationCreateManyStakeholderInput[]
    skipDuplicates?: boolean
  }

  export type TransactionInfoCreateWithoutStakeholderInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalCreateNestedManyWithoutTransactionInfoInput
    chemist?: ChemistCreateNestedOneWithoutTransactionInfoInput
    customers?: CustomersCreateNestedOneWithoutTransactionInfoInput
    user?: UserCreateNestedOneWithoutTransactionInfoInput
    party?: PartyCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateWithoutStakeholderInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoCreateOrConnectWithoutStakeholderInput = {
    where: TransactionInfoWhereUniqueInput
    create: XOR<TransactionInfoCreateWithoutStakeholderInput, TransactionInfoUncheckedCreateWithoutStakeholderInput>
  }

  export type TransactionInfoCreateManyStakeholderInputEnvelope = {
    data: TransactionInfoCreateManyStakeholderInput | TransactionInfoCreateManyStakeholderInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutStakeholderInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutStakeholderInput, ProductUncheckedUpdateWithoutStakeholderInput>
    create: XOR<ProductCreateWithoutStakeholderInput, ProductUncheckedCreateWithoutStakeholderInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutStakeholderInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutStakeholderInput, ProductUncheckedUpdateWithoutStakeholderInput>
  }

  export type ProductUpdateManyWithWhereWithoutStakeholderInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutStakeholderInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    subCategoryId?: IntFilter<"Product"> | number
    stakeholderId?: IntNullableFilter<"Product"> | number | null
    size?: StringFilter<"Product"> | string
    unitId?: IntFilter<"Product"> | number
    mrp?: FloatFilter<"Product"> | number
    tp?: FloatFilter<"Product"> | number
    balance?: FloatFilter<"Product"> | number
    quantity?: FloatFilter<"Product"> | number
    unitPrice?: FloatFilter<"Product"> | number
    date?: DateTimeFilter<"Product"> | Date | string
    status?: EnumStatusFilter<"Product"> | $Enums.Status
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updateAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type StakeholderDegreeUpsertWithoutStakeholderInput = {
    update: XOR<StakeholderDegreeUpdateWithoutStakeholderInput, StakeholderDegreeUncheckedUpdateWithoutStakeholderInput>
    create: XOR<StakeholderDegreeCreateWithoutStakeholderInput, StakeholderDegreeUncheckedCreateWithoutStakeholderInput>
    where?: StakeholderDegreeWhereInput
  }

  export type StakeholderDegreeUpdateToOneWithWhereWithoutStakeholderInput = {
    where?: StakeholderDegreeWhereInput
    data: XOR<StakeholderDegreeUpdateWithoutStakeholderInput, StakeholderDegreeUncheckedUpdateWithoutStakeholderInput>
  }

  export type StakeholderDegreeUpdateWithoutStakeholderInput = {
    degreeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderDegreeUncheckedUpdateWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    degreeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderDeisgnationUpsertWithoutStakeholderInput = {
    update: XOR<StakeholderDeisgnationUpdateWithoutStakeholderInput, StakeholderDeisgnationUncheckedUpdateWithoutStakeholderInput>
    create: XOR<StakeholderDeisgnationCreateWithoutStakeholderInput, StakeholderDeisgnationUncheckedCreateWithoutStakeholderInput>
    where?: StakeholderDeisgnationWhereInput
  }

  export type StakeholderDeisgnationUpdateToOneWithWhereWithoutStakeholderInput = {
    where?: StakeholderDeisgnationWhereInput
    data: XOR<StakeholderDeisgnationUpdateWithoutStakeholderInput, StakeholderDeisgnationUncheckedUpdateWithoutStakeholderInput>
  }

  export type StakeholderDeisgnationUpdateWithoutStakeholderInput = {
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderDeisgnationUncheckedUpdateWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeUpsertWithWhereUniqueWithoutStakeholderInput = {
    where: ScopeWhereUniqueInput
    update: XOR<ScopeUpdateWithoutStakeholderInput, ScopeUncheckedUpdateWithoutStakeholderInput>
    create: XOR<ScopeCreateWithoutStakeholderInput, ScopeUncheckedCreateWithoutStakeholderInput>
  }

  export type ScopeUpdateWithWhereUniqueWithoutStakeholderInput = {
    where: ScopeWhereUniqueInput
    data: XOR<ScopeUpdateWithoutStakeholderInput, ScopeUncheckedUpdateWithoutStakeholderInput>
  }

  export type ScopeUpdateManyWithWhereWithoutStakeholderInput = {
    where: ScopeScalarWhereInput
    data: XOR<ScopeUpdateManyMutationInput, ScopeUncheckedUpdateManyWithoutStakeholderInput>
  }

  export type stakeholderChemberUpsertWithWhereUniqueWithoutStakeholderInput = {
    where: stakeholderChemberWhereUniqueInput
    update: XOR<stakeholderChemberUpdateWithoutStakeholderInput, stakeholderChemberUncheckedUpdateWithoutStakeholderInput>
    create: XOR<stakeholderChemberCreateWithoutStakeholderInput, stakeholderChemberUncheckedCreateWithoutStakeholderInput>
  }

  export type stakeholderChemberUpdateWithWhereUniqueWithoutStakeholderInput = {
    where: stakeholderChemberWhereUniqueInput
    data: XOR<stakeholderChemberUpdateWithoutStakeholderInput, stakeholderChemberUncheckedUpdateWithoutStakeholderInput>
  }

  export type stakeholderChemberUpdateManyWithWhereWithoutStakeholderInput = {
    where: stakeholderChemberScalarWhereInput
    data: XOR<stakeholderChemberUpdateManyMutationInput, stakeholderChemberUncheckedUpdateManyWithoutStakeholderInput>
  }

  export type stakeholderChemberScalarWhereInput = {
    AND?: stakeholderChemberScalarWhereInput | stakeholderChemberScalarWhereInput[]
    OR?: stakeholderChemberScalarWhereInput[]
    NOT?: stakeholderChemberScalarWhereInput | stakeholderChemberScalarWhereInput[]
    id?: IntFilter<"stakeholderChember"> | number
    stakeId?: StringNullableFilter<"stakeholderChember"> | string | null
    address?: StringFilter<"stakeholderChember"> | string
    chemberDay?: StringFilter<"stakeholderChember"> | string
    chemberTime?: StringFilter<"stakeholderChember"> | string
    chemberName?: StringFilter<"stakeholderChember"> | string
    location?: StringFilter<"stakeholderChember"> | string
    createdAt?: DateTimeFilter<"stakeholderChember"> | Date | string
    updatedAt?: DateTimeFilter<"stakeholderChember"> | Date | string
  }

  export type StakeholderOcationUpsertWithWhereUniqueWithoutStakeholderInput = {
    where: StakeholderOcationWhereUniqueInput
    update: XOR<StakeholderOcationUpdateWithoutStakeholderInput, StakeholderOcationUncheckedUpdateWithoutStakeholderInput>
    create: XOR<StakeholderOcationCreateWithoutStakeholderInput, StakeholderOcationUncheckedCreateWithoutStakeholderInput>
  }

  export type StakeholderOcationUpdateWithWhereUniqueWithoutStakeholderInput = {
    where: StakeholderOcationWhereUniqueInput
    data: XOR<StakeholderOcationUpdateWithoutStakeholderInput, StakeholderOcationUncheckedUpdateWithoutStakeholderInput>
  }

  export type StakeholderOcationUpdateManyWithWhereWithoutStakeholderInput = {
    where: StakeholderOcationScalarWhereInput
    data: XOR<StakeholderOcationUpdateManyMutationInput, StakeholderOcationUncheckedUpdateManyWithoutStakeholderInput>
  }

  export type StakeholderOcationScalarWhereInput = {
    AND?: StakeholderOcationScalarWhereInput | StakeholderOcationScalarWhereInput[]
    OR?: StakeholderOcationScalarWhereInput[]
    NOT?: StakeholderOcationScalarWhereInput | StakeholderOcationScalarWhereInput[]
    id?: IntFilter<"StakeholderOcation"> | number
    stakeId?: StringFilter<"StakeholderOcation"> | string
    ocationName?: StringFilter<"StakeholderOcation"> | string
    relation?: StringFilter<"StakeholderOcation"> | string
    personName?: StringNullableFilter<"StakeholderOcation"> | string | null
    dob?: DateTimeNullableFilter<"StakeholderOcation"> | Date | string | null
    otherInfo?: StringNullableFilter<"StakeholderOcation"> | string | null
  }

  export type TransactionInfoUpsertWithWhereUniqueWithoutStakeholderInput = {
    where: TransactionInfoWhereUniqueInput
    update: XOR<TransactionInfoUpdateWithoutStakeholderInput, TransactionInfoUncheckedUpdateWithoutStakeholderInput>
    create: XOR<TransactionInfoCreateWithoutStakeholderInput, TransactionInfoUncheckedCreateWithoutStakeholderInput>
  }

  export type TransactionInfoUpdateWithWhereUniqueWithoutStakeholderInput = {
    where: TransactionInfoWhereUniqueInput
    data: XOR<TransactionInfoUpdateWithoutStakeholderInput, TransactionInfoUncheckedUpdateWithoutStakeholderInput>
  }

  export type TransactionInfoUpdateManyWithWhereWithoutStakeholderInput = {
    where: TransactionInfoScalarWhereInput
    data: XOR<TransactionInfoUpdateManyMutationInput, TransactionInfoUncheckedUpdateManyWithoutStakeholderInput>
  }

  export type StakeholderCreateWithoutStakeholderDeisgnationInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutStakeholderInput
    stakeholderDegree: StakeholderDegreeCreateNestedOneWithoutStakeholderInput
    scopes?: ScopeCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutStakeholderInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderCreateOrConnectWithoutStakeholderDeisgnationInput = {
    where: StakeholderWhereUniqueInput
    create: XOR<StakeholderCreateWithoutStakeholderDeisgnationInput, StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput>
  }

  export type StakeholderCreateManyStakeholderDeisgnationInputEnvelope = {
    data: StakeholderCreateManyStakeholderDeisgnationInput | StakeholderCreateManyStakeholderDeisgnationInput[]
    skipDuplicates?: boolean
  }

  export type StakeholderUpsertWithWhereUniqueWithoutStakeholderDeisgnationInput = {
    where: StakeholderWhereUniqueInput
    update: XOR<StakeholderUpdateWithoutStakeholderDeisgnationInput, StakeholderUncheckedUpdateWithoutStakeholderDeisgnationInput>
    create: XOR<StakeholderCreateWithoutStakeholderDeisgnationInput, StakeholderUncheckedCreateWithoutStakeholderDeisgnationInput>
  }

  export type StakeholderUpdateWithWhereUniqueWithoutStakeholderDeisgnationInput = {
    where: StakeholderWhereUniqueInput
    data: XOR<StakeholderUpdateWithoutStakeholderDeisgnationInput, StakeholderUncheckedUpdateWithoutStakeholderDeisgnationInput>
  }

  export type StakeholderUpdateManyWithWhereWithoutStakeholderDeisgnationInput = {
    where: StakeholderScalarWhereInput
    data: XOR<StakeholderUpdateManyMutationInput, StakeholderUncheckedUpdateManyWithoutStakeholderDeisgnationInput>
  }

  export type StakeholderScalarWhereInput = {
    AND?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
    OR?: StakeholderScalarWhereInput[]
    NOT?: StakeholderScalarWhereInput | StakeholderScalarWhereInput[]
    id?: IntFilter<"Stakeholder"> | number
    scopeId?: IntNullableFilter<"Stakeholder"> | number | null
    stakeId?: StringFilter<"Stakeholder"> | string
    name?: StringFilter<"Stakeholder"> | string
    designationId?: IntFilter<"Stakeholder"> | number
    degreeId?: IntFilter<"Stakeholder"> | number
    category?: StringFilter<"Stakeholder"> | string
    officeAddress?: StringFilter<"Stakeholder"> | string
    contactNo?: StringFilter<"Stakeholder"> | string
    honorary?: IntFilter<"Stakeholder"> | number
    paymentDate?: DateTimeFilter<"Stakeholder"> | Date | string
    rxCommitment?: IntFilter<"Stakeholder"> | number
    createdAt?: DateTimeFilter<"Stakeholder"> | Date | string
    updatedAt?: DateTimeFilter<"Stakeholder"> | Date | string
  }

  export type StakeholderCreateWithoutStakeholderDegreeInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutStakeholderInput
    stakeholderDeisgnation: StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput
    scopes?: ScopeCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateWithoutStakeholderDegreeInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutStakeholderInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderCreateOrConnectWithoutStakeholderDegreeInput = {
    where: StakeholderWhereUniqueInput
    create: XOR<StakeholderCreateWithoutStakeholderDegreeInput, StakeholderUncheckedCreateWithoutStakeholderDegreeInput>
  }

  export type StakeholderCreateManyStakeholderDegreeInputEnvelope = {
    data: StakeholderCreateManyStakeholderDegreeInput | StakeholderCreateManyStakeholderDegreeInput[]
    skipDuplicates?: boolean
  }

  export type StakeholderUpsertWithWhereUniqueWithoutStakeholderDegreeInput = {
    where: StakeholderWhereUniqueInput
    update: XOR<StakeholderUpdateWithoutStakeholderDegreeInput, StakeholderUncheckedUpdateWithoutStakeholderDegreeInput>
    create: XOR<StakeholderCreateWithoutStakeholderDegreeInput, StakeholderUncheckedCreateWithoutStakeholderDegreeInput>
  }

  export type StakeholderUpdateWithWhereUniqueWithoutStakeholderDegreeInput = {
    where: StakeholderWhereUniqueInput
    data: XOR<StakeholderUpdateWithoutStakeholderDegreeInput, StakeholderUncheckedUpdateWithoutStakeholderDegreeInput>
  }

  export type StakeholderUpdateManyWithWhereWithoutStakeholderDegreeInput = {
    where: StakeholderScalarWhereInput
    data: XOR<StakeholderUpdateManyMutationInput, StakeholderUncheckedUpdateManyWithoutStakeholderDegreeInput>
  }

  export type StakeholderCreateWithoutStakeholderChemberInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutStakeholderInput
    stakeholderDegree: StakeholderDegreeCreateNestedOneWithoutStakeholderInput
    stakeholderDeisgnation: StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput
    scopes?: ScopeCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateWithoutStakeholderChemberInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutStakeholderInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderCreateOrConnectWithoutStakeholderChemberInput = {
    where: StakeholderWhereUniqueInput
    create: XOR<StakeholderCreateWithoutStakeholderChemberInput, StakeholderUncheckedCreateWithoutStakeholderChemberInput>
  }

  export type StakeholderUpsertWithoutStakeholderChemberInput = {
    update: XOR<StakeholderUpdateWithoutStakeholderChemberInput, StakeholderUncheckedUpdateWithoutStakeholderChemberInput>
    create: XOR<StakeholderCreateWithoutStakeholderChemberInput, StakeholderUncheckedCreateWithoutStakeholderChemberInput>
    where?: StakeholderWhereInput
  }

  export type StakeholderUpdateToOneWithWhereWithoutStakeholderChemberInput = {
    where?: StakeholderWhereInput
    data: XOR<StakeholderUpdateWithoutStakeholderChemberInput, StakeholderUncheckedUpdateWithoutStakeholderChemberInput>
  }

  export type StakeholderUpdateWithoutStakeholderChemberInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutStakeholderNestedInput
    stakeholderDegree?: StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput
    stakeholderDeisgnation?: StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput
    scopes?: ScopeUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateWithoutStakeholderChemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutStakeholderNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderCreateWithoutStakeholderOcationInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutStakeholderInput
    stakeholderDegree: StakeholderDegreeCreateNestedOneWithoutStakeholderInput
    stakeholderDeisgnation: StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput
    scopes?: ScopeCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateWithoutStakeholderOcationInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutStakeholderInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderCreateOrConnectWithoutStakeholderOcationInput = {
    where: StakeholderWhereUniqueInput
    create: XOR<StakeholderCreateWithoutStakeholderOcationInput, StakeholderUncheckedCreateWithoutStakeholderOcationInput>
  }

  export type StakeholderUpsertWithoutStakeholderOcationInput = {
    update: XOR<StakeholderUpdateWithoutStakeholderOcationInput, StakeholderUncheckedUpdateWithoutStakeholderOcationInput>
    create: XOR<StakeholderCreateWithoutStakeholderOcationInput, StakeholderUncheckedCreateWithoutStakeholderOcationInput>
    where?: StakeholderWhereInput
  }

  export type StakeholderUpdateToOneWithWhereWithoutStakeholderOcationInput = {
    where?: StakeholderWhereInput
    data: XOR<StakeholderUpdateWithoutStakeholderOcationInput, StakeholderUncheckedUpdateWithoutStakeholderOcationInput>
  }

  export type StakeholderUpdateWithoutStakeholderOcationInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutStakeholderNestedInput
    stakeholderDegree?: StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput
    stakeholderDeisgnation?: StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput
    scopes?: ScopeUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateWithoutStakeholderOcationInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutStakeholderNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type TransactionInfoCreateWithoutCustomersInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalCreateNestedManyWithoutTransactionInfoInput
    chemist?: ChemistCreateNestedOneWithoutTransactionInfoInput
    user?: UserCreateNestedOneWithoutTransactionInfoInput
    party?: PartyCreateNestedOneWithoutTransactionInfoInput
    stakeholder?: StakeholderCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateWithoutCustomersInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoCreateOrConnectWithoutCustomersInput = {
    where: TransactionInfoWhereUniqueInput
    create: XOR<TransactionInfoCreateWithoutCustomersInput, TransactionInfoUncheckedCreateWithoutCustomersInput>
  }

  export type TransactionInfoCreateManyCustomersInputEnvelope = {
    data: TransactionInfoCreateManyCustomersInput | TransactionInfoCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type TransactionInfoUpsertWithWhereUniqueWithoutCustomersInput = {
    where: TransactionInfoWhereUniqueInput
    update: XOR<TransactionInfoUpdateWithoutCustomersInput, TransactionInfoUncheckedUpdateWithoutCustomersInput>
    create: XOR<TransactionInfoCreateWithoutCustomersInput, TransactionInfoUncheckedCreateWithoutCustomersInput>
  }

  export type TransactionInfoUpdateWithWhereUniqueWithoutCustomersInput = {
    where: TransactionInfoWhereUniqueInput
    data: XOR<TransactionInfoUpdateWithoutCustomersInput, TransactionInfoUncheckedUpdateWithoutCustomersInput>
  }

  export type TransactionInfoUpdateManyWithWhereWithoutCustomersInput = {
    where: TransactionInfoScalarWhereInput
    data: XOR<TransactionInfoUpdateManyMutationInput, TransactionInfoUncheckedUpdateManyWithoutCustomersInput>
  }

  export type ChemistCreateWithoutScopesInput = {
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutChemistInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutChemistInput
    order?: OrderCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutChemistInput
  }

  export type ChemistUncheckedCreateWithoutScopesInput = {
    id?: number
    chemistId: string
    depoId: number
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutChemistInput
    order?: OrderUncheckedCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutChemistInput
  }

  export type ChemistCreateOrConnectWithoutScopesInput = {
    where: ChemistWhereUniqueInput
    create: XOR<ChemistCreateWithoutScopesInput, ChemistUncheckedCreateWithoutScopesInput>
  }

  export type DepoCreateWithoutScopesInput = {
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutDepoInput
    inventory?: InventoryCreateNestedManyWithoutDepoInput
    jobPost?: JobPostCreateNestedManyWithoutDepoInput
    journal?: JournalCreateNestedManyWithoutDepoInput
  }

  export type DepoUncheckedCreateWithoutScopesInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutDepoInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutDepoInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutDepoInput
    journal?: JournalUncheckedCreateNestedManyWithoutDepoInput
  }

  export type DepoCreateOrConnectWithoutScopesInput = {
    where: DepoWhereUniqueInput
    create: XOR<DepoCreateWithoutScopesInput, DepoUncheckedCreateWithoutScopesInput>
  }

  export type StakeholderCreateWithoutScopesInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutStakeholderInput
    stakeholderDegree: StakeholderDegreeCreateNestedOneWithoutStakeholderInput
    stakeholderDeisgnation: StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateWithoutScopesInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderCreateOrConnectWithoutScopesInput = {
    where: StakeholderWhereUniqueInput
    create: XOR<StakeholderCreateWithoutScopesInput, StakeholderUncheckedCreateWithoutScopesInput>
  }

  export type UserCreateWithoutScopeInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScopeInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScopeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScopeInput, UserUncheckedCreateWithoutScopeInput>
  }

  export type JobPostCreateWithoutScopeInput = {
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutScopeInput = {
    id?: number
    depoId: number
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobPostCreateOrConnectWithoutScopeInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutScopeInput, JobPostUncheckedCreateWithoutScopeInput>
  }

  export type ChemistUpsertWithWhereUniqueWithoutScopesInput = {
    where: ChemistWhereUniqueInput
    update: XOR<ChemistUpdateWithoutScopesInput, ChemistUncheckedUpdateWithoutScopesInput>
    create: XOR<ChemistCreateWithoutScopesInput, ChemistUncheckedCreateWithoutScopesInput>
  }

  export type ChemistUpdateWithWhereUniqueWithoutScopesInput = {
    where: ChemistWhereUniqueInput
    data: XOR<ChemistUpdateWithoutScopesInput, ChemistUncheckedUpdateWithoutScopesInput>
  }

  export type ChemistUpdateManyWithWhereWithoutScopesInput = {
    where: ChemistScalarWhereInput
    data: XOR<ChemistUpdateManyMutationInput, ChemistUncheckedUpdateManyWithoutScopesInput>
  }

  export type DepoUpsertWithWhereUniqueWithoutScopesInput = {
    where: DepoWhereUniqueInput
    update: XOR<DepoUpdateWithoutScopesInput, DepoUncheckedUpdateWithoutScopesInput>
    create: XOR<DepoCreateWithoutScopesInput, DepoUncheckedCreateWithoutScopesInput>
  }

  export type DepoUpdateWithWhereUniqueWithoutScopesInput = {
    where: DepoWhereUniqueInput
    data: XOR<DepoUpdateWithoutScopesInput, DepoUncheckedUpdateWithoutScopesInput>
  }

  export type DepoUpdateManyWithWhereWithoutScopesInput = {
    where: DepoScalarWhereInput
    data: XOR<DepoUpdateManyMutationInput, DepoUncheckedUpdateManyWithoutScopesInput>
  }

  export type DepoScalarWhereInput = {
    AND?: DepoScalarWhereInput | DepoScalarWhereInput[]
    OR?: DepoScalarWhereInput[]
    NOT?: DepoScalarWhereInput | DepoScalarWhereInput[]
    id?: IntFilter<"Depo"> | number
    depoName?: StringFilter<"Depo"> | string
    location?: StringFilter<"Depo"> | string
    scopeId?: IntNullableFilter<"Depo"> | number | null
    status?: EnumStatusFilter<"Depo"> | $Enums.Status
    createdAt?: DateTimeFilter<"Depo"> | Date | string
    updatedAt?: DateTimeFilter<"Depo"> | Date | string
  }

  export type StakeholderUpsertWithWhereUniqueWithoutScopesInput = {
    where: StakeholderWhereUniqueInput
    update: XOR<StakeholderUpdateWithoutScopesInput, StakeholderUncheckedUpdateWithoutScopesInput>
    create: XOR<StakeholderCreateWithoutScopesInput, StakeholderUncheckedCreateWithoutScopesInput>
  }

  export type StakeholderUpdateWithWhereUniqueWithoutScopesInput = {
    where: StakeholderWhereUniqueInput
    data: XOR<StakeholderUpdateWithoutScopesInput, StakeholderUncheckedUpdateWithoutScopesInput>
  }

  export type StakeholderUpdateManyWithWhereWithoutScopesInput = {
    where: StakeholderScalarWhereInput
    data: XOR<StakeholderUpdateManyMutationInput, StakeholderUncheckedUpdateManyWithoutScopesInput>
  }

  export type UserUpsertWithoutScopeInput = {
    update: XOR<UserUpdateWithoutScopeInput, UserUncheckedUpdateWithoutScopeInput>
    create: XOR<UserCreateWithoutScopeInput, UserUncheckedCreateWithoutScopeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScopeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScopeInput, UserUncheckedUpdateWithoutScopeInput>
  }

  export type UserUpdateWithoutScopeInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScopeInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobPostUpsertWithoutScopeInput = {
    update: XOR<JobPostUpdateWithoutScopeInput, JobPostUncheckedUpdateWithoutScopeInput>
    create: XOR<JobPostCreateWithoutScopeInput, JobPostUncheckedCreateWithoutScopeInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutScopeInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutScopeInput, JobPostUncheckedUpdateWithoutScopeInput>
  }

  export type JobPostUpdateWithoutScopeInput = {
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutScopeInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMpoTargetInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMpoTargetInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMpoTargetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMpoTargetInput, UserUncheckedCreateWithoutMpoTargetInput>
  }

  export type UserUpsertWithoutMpoTargetInput = {
    update: XOR<UserUpdateWithoutMpoTargetInput, UserUncheckedUpdateWithoutMpoTargetInput>
    create: XOR<UserCreateWithoutMpoTargetInput, UserUncheckedCreateWithoutMpoTargetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMpoTargetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMpoTargetInput, UserUncheckedUpdateWithoutMpoTargetInput>
  }

  export type UserUpdateWithoutMpoTargetInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMpoTargetInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProductWiseTargetInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductWiseTargetInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductWiseTargetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductWiseTargetInput, UserUncheckedCreateWithoutProductWiseTargetInput>
  }

  export type TargetProductBatchCreateWithoutProductWiseTargetInput = {
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTargetProductBatchInput
  }

  export type TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput = {
    id?: number
    productId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TargetProductBatchCreateOrConnectWithoutProductWiseTargetInput = {
    where: TargetProductBatchWhereUniqueInput
    create: XOR<TargetProductBatchCreateWithoutProductWiseTargetInput, TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput>
  }

  export type TargetProductBatchCreateManyProductWiseTargetInputEnvelope = {
    data: TargetProductBatchCreateManyProductWiseTargetInput | TargetProductBatchCreateManyProductWiseTargetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductWiseTargetInput = {
    update: XOR<UserUpdateWithoutProductWiseTargetInput, UserUncheckedUpdateWithoutProductWiseTargetInput>
    create: XOR<UserCreateWithoutProductWiseTargetInput, UserUncheckedCreateWithoutProductWiseTargetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductWiseTargetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductWiseTargetInput, UserUncheckedUpdateWithoutProductWiseTargetInput>
  }

  export type UserUpdateWithoutProductWiseTargetInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductWiseTargetInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TargetProductBatchUpsertWithWhereUniqueWithoutProductWiseTargetInput = {
    where: TargetProductBatchWhereUniqueInput
    update: XOR<TargetProductBatchUpdateWithoutProductWiseTargetInput, TargetProductBatchUncheckedUpdateWithoutProductWiseTargetInput>
    create: XOR<TargetProductBatchCreateWithoutProductWiseTargetInput, TargetProductBatchUncheckedCreateWithoutProductWiseTargetInput>
  }

  export type TargetProductBatchUpdateWithWhereUniqueWithoutProductWiseTargetInput = {
    where: TargetProductBatchWhereUniqueInput
    data: XOR<TargetProductBatchUpdateWithoutProductWiseTargetInput, TargetProductBatchUncheckedUpdateWithoutProductWiseTargetInput>
  }

  export type TargetProductBatchUpdateManyWithWhereWithoutProductWiseTargetInput = {
    where: TargetProductBatchScalarWhereInput
    data: XOR<TargetProductBatchUpdateManyMutationInput, TargetProductBatchUncheckedUpdateManyWithoutProductWiseTargetInput>
  }

  export type TargetProductBatchScalarWhereInput = {
    AND?: TargetProductBatchScalarWhereInput | TargetProductBatchScalarWhereInput[]
    OR?: TargetProductBatchScalarWhereInput[]
    NOT?: TargetProductBatchScalarWhereInput | TargetProductBatchScalarWhereInput[]
    id?: IntFilter<"TargetProductBatch"> | number
    productId?: IntFilter<"TargetProductBatch"> | number
    productTargetId?: IntFilter<"TargetProductBatch"> | number
    numberOfProduct?: IntFilter<"TargetProductBatch"> | number
    insentiveAmount?: FloatFilter<"TargetProductBatch"> | number
    createdAt?: DateTimeFilter<"TargetProductBatch"> | Date | string
    updatedAt?: DateTimeFilter<"TargetProductBatch"> | Date | string
  }

  export type ProductCreateWithoutTargetProductBatchInput = {
    name: string
    description: string
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutProductInput
    orderItem?: OrderItemCreateNestedManyWithoutProductInput
    Stakeholder?: StakeholderCreateNestedOneWithoutProductInput
    subCategory: SubCategoryCreateNestedOneWithoutProductInput
    unit: UnitCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTargetProductBatchInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId?: number | null
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTargetProductBatchInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTargetProductBatchInput, ProductUncheckedCreateWithoutTargetProductBatchInput>
  }

  export type ProductWiseTargetCreateWithoutTargetProductBatchInput = {
    targetStart: Date | string
    targetEnd: Date | string
    targetType: $Enums.TargetType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductWiseTargetInput
  }

  export type ProductWiseTargetUncheckedCreateWithoutTargetProductBatchInput = {
    id?: number
    employeeId: string
    targetStart: Date | string
    targetEnd: Date | string
    targetType: $Enums.TargetType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductWiseTargetCreateOrConnectWithoutTargetProductBatchInput = {
    where: ProductWiseTargetWhereUniqueInput
    create: XOR<ProductWiseTargetCreateWithoutTargetProductBatchInput, ProductWiseTargetUncheckedCreateWithoutTargetProductBatchInput>
  }

  export type ProductUpsertWithoutTargetProductBatchInput = {
    update: XOR<ProductUpdateWithoutTargetProductBatchInput, ProductUncheckedUpdateWithoutTargetProductBatchInput>
    create: XOR<ProductCreateWithoutTargetProductBatchInput, ProductUncheckedCreateWithoutTargetProductBatchInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTargetProductBatchInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTargetProductBatchInput, ProductUncheckedUpdateWithoutTargetProductBatchInput>
  }

  export type ProductUpdateWithoutTargetProductBatchInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUpdateManyWithoutProductNestedInput
    Stakeholder?: StakeholderUpdateOneWithoutProductNestedInput
    subCategory?: SubCategoryUpdateOneRequiredWithoutProductNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTargetProductBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductWiseTargetUpsertWithoutTargetProductBatchInput = {
    update: XOR<ProductWiseTargetUpdateWithoutTargetProductBatchInput, ProductWiseTargetUncheckedUpdateWithoutTargetProductBatchInput>
    create: XOR<ProductWiseTargetCreateWithoutTargetProductBatchInput, ProductWiseTargetUncheckedCreateWithoutTargetProductBatchInput>
    where?: ProductWiseTargetWhereInput
  }

  export type ProductWiseTargetUpdateToOneWithWhereWithoutTargetProductBatchInput = {
    where?: ProductWiseTargetWhereInput
    data: XOR<ProductWiseTargetUpdateWithoutTargetProductBatchInput, ProductWiseTargetUncheckedUpdateWithoutTargetProductBatchInput>
  }

  export type ProductWiseTargetUpdateWithoutTargetProductBatchInput = {
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductWiseTargetNestedInput
  }

  export type ProductWiseTargetUncheckedUpdateWithoutTargetProductBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    targetStart?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryCreateWithoutCategoryInput = {
    subCategoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    subCategoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryCreateOrConnectWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryCreateManyCategoryInputEnvelope = {
    data: SubCategoryCreateManyCategoryInput | SubCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    update: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    data: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubCategoryScalarWhereInput
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubCategoryScalarWhereInput = {
    AND?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    OR?: SubCategoryScalarWhereInput[]
    NOT?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    id?: IntFilter<"SubCategory"> | number
    subCategoryName?: StringFilter<"SubCategory"> | string
    categoryId?: IntFilter<"SubCategory"> | number
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
  }

  export type ProductCreateWithoutSubCategoryInput = {
    name: string
    description: string
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    orderItem?: OrderItemCreateNestedManyWithoutProductInput
    Stakeholder?: StakeholderCreateNestedOneWithoutProductInput
    unit: UnitCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSubCategoryInput = {
    id?: number
    name: string
    description: string
    stakeholderId?: number | null
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductCreateManySubCategoryInputEnvelope = {
    data: ProductCreateManySubCategoryInput | ProductCreateManySubCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutSubCategoryInput = {
    categoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutSubCategoryInput = {
    id?: number
    categoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutSubCategoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutSubCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type CategoryUpsertWithoutSubCategoryInput = {
    update: XOR<CategoryUpdateWithoutSubCategoryInput, CategoryUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubCategoryInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubCategoryInput, CategoryUncheckedUpdateWithoutSubCategoryInput>
  }

  export type CategoryUpdateWithoutSubCategoryInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutSubCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutUnitInput = {
    name: string
    description: string
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    orderItem?: OrderItemCreateNestedManyWithoutProductInput
    Stakeholder?: StakeholderCreateNestedOneWithoutProductInput
    subCategory: SubCategoryCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId?: number | null
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUnitInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput>
  }

  export type ProductCreateManyUnitInputEnvelope = {
    data: ProductCreateManyUnitInput | ProductCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutUnitInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUnitInput, ProductUncheckedUpdateWithoutUnitInput>
    create: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUnitInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUnitInput, ProductUncheckedUpdateWithoutUnitInput>
  }

  export type ProductUpdateManyWithWhereWithoutUnitInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUnitInput>
  }

  export type LedgerHeadCreateWithoutAccountHeadInput = {
    ledgerName: string
    ledgerCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedJournal?: FixedJournalCreateNestedManyWithoutLedgerHeadInput
    journal?: JournalCreateNestedManyWithoutLedgerHeadInput
  }

  export type LedgerHeadUncheckedCreateWithoutAccountHeadInput = {
    id?: number
    ledgerName: string
    ledgerCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutLedgerHeadInput
    journal?: JournalUncheckedCreateNestedManyWithoutLedgerHeadInput
  }

  export type LedgerHeadCreateOrConnectWithoutAccountHeadInput = {
    where: LedgerHeadWhereUniqueInput
    create: XOR<LedgerHeadCreateWithoutAccountHeadInput, LedgerHeadUncheckedCreateWithoutAccountHeadInput>
  }

  export type LedgerHeadCreateManyAccountHeadInputEnvelope = {
    data: LedgerHeadCreateManyAccountHeadInput | LedgerHeadCreateManyAccountHeadInput[]
    skipDuplicates?: boolean
  }

  export type LedgerHeadUpsertWithWhereUniqueWithoutAccountHeadInput = {
    where: LedgerHeadWhereUniqueInput
    update: XOR<LedgerHeadUpdateWithoutAccountHeadInput, LedgerHeadUncheckedUpdateWithoutAccountHeadInput>
    create: XOR<LedgerHeadCreateWithoutAccountHeadInput, LedgerHeadUncheckedCreateWithoutAccountHeadInput>
  }

  export type LedgerHeadUpdateWithWhereUniqueWithoutAccountHeadInput = {
    where: LedgerHeadWhereUniqueInput
    data: XOR<LedgerHeadUpdateWithoutAccountHeadInput, LedgerHeadUncheckedUpdateWithoutAccountHeadInput>
  }

  export type LedgerHeadUpdateManyWithWhereWithoutAccountHeadInput = {
    where: LedgerHeadScalarWhereInput
    data: XOR<LedgerHeadUpdateManyMutationInput, LedgerHeadUncheckedUpdateManyWithoutAccountHeadInput>
  }

  export type LedgerHeadScalarWhereInput = {
    AND?: LedgerHeadScalarWhereInput | LedgerHeadScalarWhereInput[]
    OR?: LedgerHeadScalarWhereInput[]
    NOT?: LedgerHeadScalarWhereInput | LedgerHeadScalarWhereInput[]
    id?: IntFilter<"LedgerHead"> | number
    ledgerName?: StringFilter<"LedgerHead"> | string
    ledgerCode?: StringFilter<"LedgerHead"> | string
    headCodeId?: IntFilter<"LedgerHead"> | number
    createdAt?: DateTimeFilter<"LedgerHead"> | Date | string
    updatedAt?: DateTimeFilter<"LedgerHead"> | Date | string
  }

  export type FixedJournalCreateWithoutLedgerHeadInput = {
    date: Date | string
    voucherNo: string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist: ChemistCreateNestedOneWithoutFixedJournalInput
    depo: DepoCreateNestedOneWithoutFixedJournalInput
    inventory?: InventoryCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalUncheckedCreateWithoutLedgerHeadInput = {
    id?: number
    date: Date | string
    voucherNo: string
    chemistId: string
    depoId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutFixedJournalInput
  }

  export type FixedJournalCreateOrConnectWithoutLedgerHeadInput = {
    where: FixedJournalWhereUniqueInput
    create: XOR<FixedJournalCreateWithoutLedgerHeadInput, FixedJournalUncheckedCreateWithoutLedgerHeadInput>
  }

  export type FixedJournalCreateManyLedgerHeadInputEnvelope = {
    data: FixedJournalCreateManyLedgerHeadInput | FixedJournalCreateManyLedgerHeadInput[]
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutLedgerHeadInput = {
    date: Date | string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo?: DepoCreateNestedOneWithoutJournalInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutJournalInput
    bankTransaction?: BankTransactionCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutLedgerHeadInput = {
    id?: number
    transactionId?: number | null
    date: Date | string
    depoId?: number | null
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransaction?: BankTransactionUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalCreateOrConnectWithoutLedgerHeadInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutLedgerHeadInput, JournalUncheckedCreateWithoutLedgerHeadInput>
  }

  export type JournalCreateManyLedgerHeadInputEnvelope = {
    data: JournalCreateManyLedgerHeadInput | JournalCreateManyLedgerHeadInput[]
    skipDuplicates?: boolean
  }

  export type AccountHeadCreateWithoutLedgerHeadInput = {
    headName: string
    headCode: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type AccountHeadUncheckedCreateWithoutLedgerHeadInput = {
    id?: number
    headName: string
    headCode: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type AccountHeadCreateOrConnectWithoutLedgerHeadInput = {
    where: AccountHeadWhereUniqueInput
    create: XOR<AccountHeadCreateWithoutLedgerHeadInput, AccountHeadUncheckedCreateWithoutLedgerHeadInput>
  }

  export type FixedJournalUpsertWithWhereUniqueWithoutLedgerHeadInput = {
    where: FixedJournalWhereUniqueInput
    update: XOR<FixedJournalUpdateWithoutLedgerHeadInput, FixedJournalUncheckedUpdateWithoutLedgerHeadInput>
    create: XOR<FixedJournalCreateWithoutLedgerHeadInput, FixedJournalUncheckedCreateWithoutLedgerHeadInput>
  }

  export type FixedJournalUpdateWithWhereUniqueWithoutLedgerHeadInput = {
    where: FixedJournalWhereUniqueInput
    data: XOR<FixedJournalUpdateWithoutLedgerHeadInput, FixedJournalUncheckedUpdateWithoutLedgerHeadInput>
  }

  export type FixedJournalUpdateManyWithWhereWithoutLedgerHeadInput = {
    where: FixedJournalScalarWhereInput
    data: XOR<FixedJournalUpdateManyMutationInput, FixedJournalUncheckedUpdateManyWithoutLedgerHeadInput>
  }

  export type JournalUpsertWithWhereUniqueWithoutLedgerHeadInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutLedgerHeadInput, JournalUncheckedUpdateWithoutLedgerHeadInput>
    create: XOR<JournalCreateWithoutLedgerHeadInput, JournalUncheckedCreateWithoutLedgerHeadInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutLedgerHeadInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutLedgerHeadInput, JournalUncheckedUpdateWithoutLedgerHeadInput>
  }

  export type JournalUpdateManyWithWhereWithoutLedgerHeadInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutLedgerHeadInput>
  }

  export type AccountHeadUpsertWithoutLedgerHeadInput = {
    update: XOR<AccountHeadUpdateWithoutLedgerHeadInput, AccountHeadUncheckedUpdateWithoutLedgerHeadInput>
    create: XOR<AccountHeadCreateWithoutLedgerHeadInput, AccountHeadUncheckedCreateWithoutLedgerHeadInput>
    where?: AccountHeadWhereInput
  }

  export type AccountHeadUpdateToOneWithWhereWithoutLedgerHeadInput = {
    where?: AccountHeadWhereInput
    data: XOR<AccountHeadUpdateWithoutLedgerHeadInput, AccountHeadUncheckedUpdateWithoutLedgerHeadInput>
  }

  export type AccountHeadUpdateWithoutLedgerHeadInput = {
    headName?: StringFieldUpdateOperationsInput | string
    headCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountHeadUncheckedUpdateWithoutLedgerHeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    headName?: StringFieldUpdateOperationsInput | string
    headCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchCreateWithoutProductInput = {
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget: ProductWiseTargetCreateNestedOneWithoutTargetProductBatchInput
  }

  export type TargetProductBatchUncheckedCreateWithoutProductInput = {
    id?: number
    productTargetId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TargetProductBatchCreateOrConnectWithoutProductInput = {
    where: TargetProductBatchWhereUniqueInput
    create: XOR<TargetProductBatchCreateWithoutProductInput, TargetProductBatchUncheckedCreateWithoutProductInput>
  }

  export type TargetProductBatchCreateManyProductInputEnvelope = {
    data: TargetProductBatchCreateManyProductInput | TargetProductBatchCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutProductInput = {
    date: Date | string
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
    depo?: DepoCreateNestedOneWithoutInventoryInput
    fixedJournal?: FixedJournalCreateNestedOneWithoutInventoryInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutInventoryInput
    user?: UserCreateNestedOneWithoutInventoriesInput
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: number
    date: Date | string
    depoId?: number | null
    employeeId?: string | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryCreateManyProductInputEnvelope = {
    data: InventoryCreateManyProductInput | InventoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    quintity: number
    tpRate: number
    amount: number
    order: OrderCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quintity: number
    tpRate: number
    amount: number
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StakeholderCreateWithoutProductInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stakeholderDegree: StakeholderDegreeCreateNestedOneWithoutStakeholderInput
    stakeholderDeisgnation: StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput
    scopes?: ScopeCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateWithoutProductInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ScopeUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderCreateOrConnectWithoutProductInput = {
    where: StakeholderWhereUniqueInput
    create: XOR<StakeholderCreateWithoutProductInput, StakeholderUncheckedCreateWithoutProductInput>
  }

  export type SubCategoryCreateWithoutProductInput = {
    subCategoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutProductInput = {
    id?: number
    subCategoryName: string
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubCategoryCreateOrConnectWithoutProductInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput>
  }

  export type UnitCreateWithoutProductInput = {
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UnitUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UnitCreateOrConnectWithoutProductInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
  }

  export type TargetProductBatchUpsertWithWhereUniqueWithoutProductInput = {
    where: TargetProductBatchWhereUniqueInput
    update: XOR<TargetProductBatchUpdateWithoutProductInput, TargetProductBatchUncheckedUpdateWithoutProductInput>
    create: XOR<TargetProductBatchCreateWithoutProductInput, TargetProductBatchUncheckedCreateWithoutProductInput>
  }

  export type TargetProductBatchUpdateWithWhereUniqueWithoutProductInput = {
    where: TargetProductBatchWhereUniqueInput
    data: XOR<TargetProductBatchUpdateWithoutProductInput, TargetProductBatchUncheckedUpdateWithoutProductInput>
  }

  export type TargetProductBatchUpdateManyWithWhereWithoutProductInput = {
    where: TargetProductBatchScalarWhereInput
    data: XOR<TargetProductBatchUpdateManyMutationInput, TargetProductBatchUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateManyWithWhereWithoutProductInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quintity?: IntFilter<"OrderItem"> | number
    tpRate?: IntFilter<"OrderItem"> | number
    amount?: IntFilter<"OrderItem"> | number
  }

  export type StakeholderUpsertWithoutProductInput = {
    update: XOR<StakeholderUpdateWithoutProductInput, StakeholderUncheckedUpdateWithoutProductInput>
    create: XOR<StakeholderCreateWithoutProductInput, StakeholderUncheckedCreateWithoutProductInput>
    where?: StakeholderWhereInput
  }

  export type StakeholderUpdateToOneWithWhereWithoutProductInput = {
    where?: StakeholderWhereInput
    data: XOR<StakeholderUpdateWithoutProductInput, StakeholderUncheckedUpdateWithoutProductInput>
  }

  export type StakeholderUpdateWithoutProductInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stakeholderDegree?: StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput
    stakeholderDeisgnation?: StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput
    scopes?: ScopeUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ScopeUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type SubCategoryUpsertWithoutProductInput = {
    update: XOR<SubCategoryUpdateWithoutProductInput, SubCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput>
    where?: SubCategoryWhereInput
  }

  export type SubCategoryUpdateToOneWithWhereWithoutProductInput = {
    where?: SubCategoryWhereInput
    data: XOR<SubCategoryUpdateWithoutProductInput, SubCategoryUncheckedUpdateWithoutProductInput>
  }

  export type SubCategoryUpdateWithoutProductInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpsertWithoutProductInput = {
    update: XOR<UnitUpdateWithoutProductInput, UnitUncheckedUpdateWithoutProductInput>
    create: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutProductInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutProductInput, UnitUncheckedUpdateWithoutProductInput>
  }

  export type UnitUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateWithoutBankAccountInput = {
    date: Date | string
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journal?: JournalCreateNestedOneWithoutBankTransactionInput
  }

  export type BankTransactionUncheckedCreateWithoutBankAccountInput = {
    id?: number
    date: Date | string
    debitAmount?: number | null
    creditAmount?: number | null
    journalId?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateOrConnectWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    create: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput>
  }

  export type BankTransactionCreateManyBankAccountInputEnvelope = {
    data: BankTransactionCreateManyBankAccountInput | BankTransactionCreateManyBankAccountInput[]
    skipDuplicates?: boolean
  }

  export type BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    update: XOR<BankTransactionUpdateWithoutBankAccountInput, BankTransactionUncheckedUpdateWithoutBankAccountInput>
    create: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput>
  }

  export type BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    data: XOR<BankTransactionUpdateWithoutBankAccountInput, BankTransactionUncheckedUpdateWithoutBankAccountInput>
  }

  export type BankTransactionUpdateManyWithWhereWithoutBankAccountInput = {
    where: BankTransactionScalarWhereInput
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyWithoutBankAccountInput>
  }

  export type BankTransactionScalarWhereInput = {
    AND?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    OR?: BankTransactionScalarWhereInput[]
    NOT?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    id?: IntFilter<"BankTransaction"> | number
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccountId?: IntFilter<"BankTransaction"> | number
    debitAmount?: IntNullableFilter<"BankTransaction"> | number | null
    creditAmount?: IntNullableFilter<"BankTransaction"> | number | null
    journalId?: IntNullableFilter<"BankTransaction"> | number | null
    isClosing?: BoolFilter<"BankTransaction"> | boolean
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
  }

  export type BankAccountCreateWithoutBankTransactionInput = {
    bankName: string
    branceName?: string | null
    accountNumber: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUncheckedCreateWithoutBankTransactionInput = {
    id?: number
    bankName: string
    branceName?: string | null
    accountNumber: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutBankTransactionInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutBankTransactionInput, BankAccountUncheckedCreateWithoutBankTransactionInput>
  }

  export type JournalCreateWithoutBankTransactionInput = {
    date: Date | string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo?: DepoCreateNestedOneWithoutJournalInput
    ledgerHead?: LedgerHeadCreateNestedOneWithoutJournalInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutBankTransactionInput = {
    id?: number
    transactionId?: number | null
    ledgerHeadId?: number | null
    date: Date | string
    depoId?: number | null
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCreateOrConnectWithoutBankTransactionInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutBankTransactionInput, JournalUncheckedCreateWithoutBankTransactionInput>
  }

  export type BankAccountUpsertWithoutBankTransactionInput = {
    update: XOR<BankAccountUpdateWithoutBankTransactionInput, BankAccountUncheckedUpdateWithoutBankTransactionInput>
    create: XOR<BankAccountCreateWithoutBankTransactionInput, BankAccountUncheckedCreateWithoutBankTransactionInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutBankTransactionInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutBankTransactionInput, BankAccountUncheckedUpdateWithoutBankTransactionInput>
  }

  export type BankAccountUpdateWithoutBankTransactionInput = {
    bankName?: StringFieldUpdateOperationsInput | string
    branceName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateWithoutBankTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankName?: StringFieldUpdateOperationsInput | string
    branceName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUpsertWithoutBankTransactionInput = {
    update: XOR<JournalUpdateWithoutBankTransactionInput, JournalUncheckedUpdateWithoutBankTransactionInput>
    create: XOR<JournalCreateWithoutBankTransactionInput, JournalUncheckedCreateWithoutBankTransactionInput>
    where?: JournalWhereInput
  }

  export type JournalUpdateToOneWithWhereWithoutBankTransactionInput = {
    where?: JournalWhereInput
    data: XOR<JournalUpdateWithoutBankTransactionInput, JournalUncheckedUpdateWithoutBankTransactionInput>
  }

  export type JournalUpdateWithoutBankTransactionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneWithoutJournalNestedInput
    ledgerHead?: LedgerHeadUpdateOneWithoutJournalNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutBankTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepoCreateWithoutInventoryInput = {
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutDepoInput
    jobPost?: JobPostCreateNestedManyWithoutDepoInput
    journal?: JournalCreateNestedManyWithoutDepoInput
    scopes?: ScopeCreateNestedManyWithoutDepoInput
  }

  export type DepoUncheckedCreateWithoutInventoryInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutDepoInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutDepoInput
    journal?: JournalUncheckedCreateNestedManyWithoutDepoInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutDepoInput
  }

  export type DepoCreateOrConnectWithoutInventoryInput = {
    where: DepoWhereUniqueInput
    create: XOR<DepoCreateWithoutInventoryInput, DepoUncheckedCreateWithoutInventoryInput>
  }

  export type FixedJournalCreateWithoutInventoryInput = {
    date: Date | string
    voucherNo: string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist: ChemistCreateNestedOneWithoutFixedJournalInput
    depo: DepoCreateNestedOneWithoutFixedJournalInput
    ledgerHead: LedgerHeadCreateNestedOneWithoutFixedJournalInput
  }

  export type FixedJournalUncheckedCreateWithoutInventoryInput = {
    id?: number
    date: Date | string
    voucherNo: string
    chemistId: string
    ledgerHeadId: number
    depoId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedJournalCreateOrConnectWithoutInventoryInput = {
    where: FixedJournalWhereUniqueInput
    create: XOR<FixedJournalCreateWithoutInventoryInput, FixedJournalUncheckedCreateWithoutInventoryInput>
  }

  export type ProductCreateWithoutInventoryInput = {
    name: string
    description: string
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductInput
    orderItem?: OrderItemCreateNestedManyWithoutProductInput
    Stakeholder?: StakeholderCreateNestedOneWithoutProductInput
    subCategory: SubCategoryCreateNestedOneWithoutProductInput
    unit: UnitCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId?: number | null
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductInput
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
  }

  export type TransactionInfoCreateWithoutInventoryInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    journal?: JournalCreateNestedManyWithoutTransactionInfoInput
    chemist?: ChemistCreateNestedOneWithoutTransactionInfoInput
    customers?: CustomersCreateNestedOneWithoutTransactionInfoInput
    user?: UserCreateNestedOneWithoutTransactionInfoInput
    party?: PartyCreateNestedOneWithoutTransactionInfoInput
    stakeholder?: StakeholderCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateWithoutInventoryInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoCreateOrConnectWithoutInventoryInput = {
    where: TransactionInfoWhereUniqueInput
    create: XOR<TransactionInfoCreateWithoutInventoryInput, TransactionInfoUncheckedCreateWithoutInventoryInput>
  }

  export type UserCreateWithoutInventoriesInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoriesInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoriesInput, UserUncheckedCreateWithoutInventoriesInput>
  }

  export type DepoUpsertWithoutInventoryInput = {
    update: XOR<DepoUpdateWithoutInventoryInput, DepoUncheckedUpdateWithoutInventoryInput>
    create: XOR<DepoCreateWithoutInventoryInput, DepoUncheckedCreateWithoutInventoryInput>
    where?: DepoWhereInput
  }

  export type DepoUpdateToOneWithWhereWithoutInventoryInput = {
    where?: DepoWhereInput
    data: XOR<DepoUpdateWithoutInventoryInput, DepoUncheckedUpdateWithoutInventoryInput>
  }

  export type DepoUpdateWithoutInventoryInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUpdateManyWithoutDepoNestedInput
    journal?: JournalUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutDepoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutDepoNestedInput
  }

  export type FixedJournalUpsertWithoutInventoryInput = {
    update: XOR<FixedJournalUpdateWithoutInventoryInput, FixedJournalUncheckedUpdateWithoutInventoryInput>
    create: XOR<FixedJournalCreateWithoutInventoryInput, FixedJournalUncheckedCreateWithoutInventoryInput>
    where?: FixedJournalWhereInput
  }

  export type FixedJournalUpdateToOneWithWhereWithoutInventoryInput = {
    where?: FixedJournalWhereInput
    data: XOR<FixedJournalUpdateWithoutInventoryInput, FixedJournalUncheckedUpdateWithoutInventoryInput>
  }

  export type FixedJournalUpdateWithoutInventoryInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateOneRequiredWithoutFixedJournalNestedInput
    depo?: DepoUpdateOneRequiredWithoutFixedJournalNestedInput
    ledgerHead?: LedgerHeadUpdateOneRequiredWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    ledgerHeadId?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutInventoryInput = {
    update: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUpdateManyWithoutProductNestedInput
    Stakeholder?: StakeholderUpdateOneWithoutProductNestedInput
    subCategory?: SubCategoryUpdateOneRequiredWithoutProductNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TransactionInfoUpsertWithoutInventoryInput = {
    update: XOR<TransactionInfoUpdateWithoutInventoryInput, TransactionInfoUncheckedUpdateWithoutInventoryInput>
    create: XOR<TransactionInfoCreateWithoutInventoryInput, TransactionInfoUncheckedCreateWithoutInventoryInput>
    where?: TransactionInfoWhereInput
  }

  export type TransactionInfoUpdateToOneWithWhereWithoutInventoryInput = {
    where?: TransactionInfoWhereInput
    data: XOR<TransactionInfoUpdateWithoutInventoryInput, TransactionInfoUncheckedUpdateWithoutInventoryInput>
  }

  export type TransactionInfoUpdateWithoutInventoryInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateManyWithoutTransactionInfoNestedInput
    chemist?: ChemistUpdateOneWithoutTransactionInfoNestedInput
    customers?: CustomersUpdateOneWithoutTransactionInfoNestedInput
    user?: UserUpdateOneWithoutTransactionInfoNestedInput
    party?: PartyUpdateOneWithoutTransactionInfoNestedInput
    stakeholder?: StakeholderUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type UserUpsertWithoutInventoriesInput = {
    update: XOR<UserUpdateWithoutInventoriesInput, UserUncheckedUpdateWithoutInventoriesInput>
    create: XOR<UserCreateWithoutInventoriesInput, UserUncheckedCreateWithoutInventoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoriesInput, UserUncheckedUpdateWithoutInventoriesInput>
  }

  export type UserUpdateWithoutInventoriesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InventoryCreateWithoutTransactionInfoInput = {
    date: Date | string
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
    depo?: DepoCreateNestedOneWithoutInventoryInput
    fixedJournal?: FixedJournalCreateNestedOneWithoutInventoryInput
    product: ProductCreateNestedOneWithoutInventoryInput
    user?: UserCreateNestedOneWithoutInventoriesInput
  }

  export type InventoryUncheckedCreateWithoutTransactionInfoInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    employeeId?: string | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryCreateOrConnectWithoutTransactionInfoInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutTransactionInfoInput, InventoryUncheckedCreateWithoutTransactionInfoInput>
  }

  export type InventoryCreateManyTransactionInfoInputEnvelope = {
    data: InventoryCreateManyTransactionInfoInput | InventoryCreateManyTransactionInfoInput[]
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutTransactionInfoInput = {
    date: Date | string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo?: DepoCreateNestedOneWithoutJournalInput
    ledgerHead?: LedgerHeadCreateNestedOneWithoutJournalInput
    bankTransaction?: BankTransactionCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutTransactionInfoInput = {
    id?: number
    ledgerHeadId?: number | null
    date: Date | string
    depoId?: number | null
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransaction?: BankTransactionUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalCreateOrConnectWithoutTransactionInfoInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutTransactionInfoInput, JournalUncheckedCreateWithoutTransactionInfoInput>
  }

  export type JournalCreateManyTransactionInfoInputEnvelope = {
    data: JournalCreateManyTransactionInfoInput | JournalCreateManyTransactionInfoInput[]
    skipDuplicates?: boolean
  }

  export type ChemistCreateWithoutTransactionInfoInput = {
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutChemistInput
    scopes?: ScopeCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutChemistInput
    order?: OrderCreateNestedManyWithoutChemistInput
  }

  export type ChemistUncheckedCreateWithoutTransactionInfoInput = {
    id?: number
    chemistId: string
    depoId: number
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ScopeUncheckedCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutChemistInput
    order?: OrderUncheckedCreateNestedManyWithoutChemistInput
  }

  export type ChemistCreateOrConnectWithoutTransactionInfoInput = {
    where: ChemistWhereUniqueInput
    create: XOR<ChemistCreateWithoutTransactionInfoInput, ChemistUncheckedCreateWithoutTransactionInfoInput>
  }

  export type CustomersCreateWithoutTransactionInfoInput = {
    name?: string | null
    contactNo: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomersUncheckedCreateWithoutTransactionInfoInput = {
    id?: number
    name?: string | null
    contactNo: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomersCreateOrConnectWithoutTransactionInfoInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutTransactionInfoInput, CustomersUncheckedCreateWithoutTransactionInfoInput>
  }

  export type UserCreateWithoutTransactionInfoInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInfoInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInfoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInfoInput, UserUncheckedCreateWithoutTransactionInfoInput>
  }

  export type PartyCreateWithoutTransactionInfoInput = {
    partyName: string
    contactNo: string
    address: string
    partytype: $Enums.PartyType
    openingAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartyUncheckedCreateWithoutTransactionInfoInput = {
    id?: number
    partyName: string
    contactNo: string
    address: string
    partytype: $Enums.PartyType
    openingAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartyCreateOrConnectWithoutTransactionInfoInput = {
    where: PartyWhereUniqueInput
    create: XOR<PartyCreateWithoutTransactionInfoInput, PartyUncheckedCreateWithoutTransactionInfoInput>
  }

  export type StakeholderCreateWithoutTransactionInfoInput = {
    scopeId?: number | null
    stakeId: string
    name: string
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutStakeholderInput
    stakeholderDegree: StakeholderDegreeCreateNestedOneWithoutStakeholderInput
    stakeholderDeisgnation: StakeholderDeisgnationCreateNestedOneWithoutStakeholderInput
    scopes?: ScopeCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderUncheckedCreateWithoutTransactionInfoInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutStakeholderInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderChember?: stakeholderChemberUncheckedCreateNestedManyWithoutStakeholderInput
    stakeholderOcation?: StakeholderOcationUncheckedCreateNestedManyWithoutStakeholderInput
  }

  export type StakeholderCreateOrConnectWithoutTransactionInfoInput = {
    where: StakeholderWhereUniqueInput
    create: XOR<StakeholderCreateWithoutTransactionInfoInput, StakeholderUncheckedCreateWithoutTransactionInfoInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutTransactionInfoInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutTransactionInfoInput, InventoryUncheckedUpdateWithoutTransactionInfoInput>
    create: XOR<InventoryCreateWithoutTransactionInfoInput, InventoryUncheckedCreateWithoutTransactionInfoInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutTransactionInfoInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutTransactionInfoInput, InventoryUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type InventoryUpdateManyWithWhereWithoutTransactionInfoInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutTransactionInfoInput>
  }

  export type JournalUpsertWithWhereUniqueWithoutTransactionInfoInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutTransactionInfoInput, JournalUncheckedUpdateWithoutTransactionInfoInput>
    create: XOR<JournalCreateWithoutTransactionInfoInput, JournalUncheckedCreateWithoutTransactionInfoInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutTransactionInfoInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutTransactionInfoInput, JournalUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type JournalUpdateManyWithWhereWithoutTransactionInfoInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutTransactionInfoInput>
  }

  export type ChemistUpsertWithoutTransactionInfoInput = {
    update: XOR<ChemistUpdateWithoutTransactionInfoInput, ChemistUncheckedUpdateWithoutTransactionInfoInput>
    create: XOR<ChemistCreateWithoutTransactionInfoInput, ChemistUncheckedCreateWithoutTransactionInfoInput>
    where?: ChemistWhereInput
  }

  export type ChemistUpdateToOneWithWhereWithoutTransactionInfoInput = {
    where?: ChemistWhereInput
    data: XOR<ChemistUpdateWithoutTransactionInfoInput, ChemistUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type ChemistUpdateWithoutTransactionInfoInput = {
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutChemistNestedInput
    scopes?: ScopeUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutChemistNestedInput
    order?: OrderUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ScopeUncheckedUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutChemistNestedInput
    order?: OrderUncheckedUpdateManyWithoutChemistNestedInput
  }

  export type CustomersUpsertWithoutTransactionInfoInput = {
    update: XOR<CustomersUpdateWithoutTransactionInfoInput, CustomersUncheckedUpdateWithoutTransactionInfoInput>
    create: XOR<CustomersCreateWithoutTransactionInfoInput, CustomersUncheckedCreateWithoutTransactionInfoInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutTransactionInfoInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutTransactionInfoInput, CustomersUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type CustomersUpdateWithoutTransactionInfoInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersUncheckedUpdateWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTransactionInfoInput = {
    update: XOR<UserUpdateWithoutTransactionInfoInput, UserUncheckedUpdateWithoutTransactionInfoInput>
    create: XOR<UserCreateWithoutTransactionInfoInput, UserUncheckedCreateWithoutTransactionInfoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInfoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInfoInput, UserUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type UserUpdateWithoutTransactionInfoInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PartyUpsertWithoutTransactionInfoInput = {
    update: XOR<PartyUpdateWithoutTransactionInfoInput, PartyUncheckedUpdateWithoutTransactionInfoInput>
    create: XOR<PartyCreateWithoutTransactionInfoInput, PartyUncheckedCreateWithoutTransactionInfoInput>
    where?: PartyWhereInput
  }

  export type PartyUpdateToOneWithWhereWithoutTransactionInfoInput = {
    where?: PartyWhereInput
    data: XOR<PartyUpdateWithoutTransactionInfoInput, PartyUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type PartyUpdateWithoutTransactionInfoInput = {
    partyName?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    partytype?: EnumPartyTypeFieldUpdateOperationsInput | $Enums.PartyType
    openingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartyUncheckedUpdateWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    partyName?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    partytype?: EnumPartyTypeFieldUpdateOperationsInput | $Enums.PartyType
    openingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderUpsertWithoutTransactionInfoInput = {
    update: XOR<StakeholderUpdateWithoutTransactionInfoInput, StakeholderUncheckedUpdateWithoutTransactionInfoInput>
    create: XOR<StakeholderCreateWithoutTransactionInfoInput, StakeholderUncheckedCreateWithoutTransactionInfoInput>
    where?: StakeholderWhereInput
  }

  export type StakeholderUpdateToOneWithWhereWithoutTransactionInfoInput = {
    where?: StakeholderWhereInput
    data: XOR<StakeholderUpdateWithoutTransactionInfoInput, StakeholderUncheckedUpdateWithoutTransactionInfoInput>
  }

  export type StakeholderUpdateWithoutTransactionInfoInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutStakeholderNestedInput
    stakeholderDegree?: StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput
    stakeholderDeisgnation?: StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput
    scopes?: ScopeUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutStakeholderNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type DepoCreateWithoutJournalInput = {
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutDepoInput
    inventory?: InventoryCreateNestedManyWithoutDepoInput
    jobPost?: JobPostCreateNestedManyWithoutDepoInput
    scopes?: ScopeCreateNestedManyWithoutDepoInput
  }

  export type DepoUncheckedCreateWithoutJournalInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutDepoInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutDepoInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutDepoInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutDepoInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutDepoInput
  }

  export type DepoCreateOrConnectWithoutJournalInput = {
    where: DepoWhereUniqueInput
    create: XOR<DepoCreateWithoutJournalInput, DepoUncheckedCreateWithoutJournalInput>
  }

  export type LedgerHeadCreateWithoutJournalInput = {
    ledgerName: string
    ledgerCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedJournal?: FixedJournalCreateNestedManyWithoutLedgerHeadInput
    accountHead: AccountHeadCreateNestedOneWithoutLedgerHeadInput
  }

  export type LedgerHeadUncheckedCreateWithoutJournalInput = {
    id?: number
    ledgerName: string
    ledgerCode: string
    headCodeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutLedgerHeadInput
  }

  export type LedgerHeadCreateOrConnectWithoutJournalInput = {
    where: LedgerHeadWhereUniqueInput
    create: XOR<LedgerHeadCreateWithoutJournalInput, LedgerHeadUncheckedCreateWithoutJournalInput>
  }

  export type TransactionInfoCreateWithoutJournalInput = {
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedManyWithoutTransactionInfoInput
    chemist?: ChemistCreateNestedOneWithoutTransactionInfoInput
    customers?: CustomersCreateNestedOneWithoutTransactionInfoInput
    user?: UserCreateNestedOneWithoutTransactionInfoInput
    party?: PartyCreateNestedOneWithoutTransactionInfoInput
    stakeholder?: StakeholderCreateNestedOneWithoutTransactionInfoInput
  }

  export type TransactionInfoUncheckedCreateWithoutJournalInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutTransactionInfoInput
  }

  export type TransactionInfoCreateOrConnectWithoutJournalInput = {
    where: TransactionInfoWhereUniqueInput
    create: XOR<TransactionInfoCreateWithoutJournalInput, TransactionInfoUncheckedCreateWithoutJournalInput>
  }

  export type BankTransactionCreateWithoutJournalInput = {
    date: Date | string
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccount: BankAccountCreateNestedOneWithoutBankTransactionInput
  }

  export type BankTransactionUncheckedCreateWithoutJournalInput = {
    id?: number
    date: Date | string
    bankAccountId: number
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateOrConnectWithoutJournalInput = {
    where: BankTransactionWhereUniqueInput
    create: XOR<BankTransactionCreateWithoutJournalInput, BankTransactionUncheckedCreateWithoutJournalInput>
  }

  export type BankTransactionCreateManyJournalInputEnvelope = {
    data: BankTransactionCreateManyJournalInput | BankTransactionCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type DepoUpsertWithoutJournalInput = {
    update: XOR<DepoUpdateWithoutJournalInput, DepoUncheckedUpdateWithoutJournalInput>
    create: XOR<DepoCreateWithoutJournalInput, DepoUncheckedCreateWithoutJournalInput>
    where?: DepoWhereInput
  }

  export type DepoUpdateToOneWithWhereWithoutJournalInput = {
    where?: DepoWhereInput
    data: XOR<DepoUpdateWithoutJournalInput, DepoUncheckedUpdateWithoutJournalInput>
  }

  export type DepoUpdateWithoutJournalInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutDepoNestedInput
  }

  export type LedgerHeadUpsertWithoutJournalInput = {
    update: XOR<LedgerHeadUpdateWithoutJournalInput, LedgerHeadUncheckedUpdateWithoutJournalInput>
    create: XOR<LedgerHeadCreateWithoutJournalInput, LedgerHeadUncheckedCreateWithoutJournalInput>
    where?: LedgerHeadWhereInput
  }

  export type LedgerHeadUpdateToOneWithWhereWithoutJournalInput = {
    where?: LedgerHeadWhereInput
    data: XOR<LedgerHeadUpdateWithoutJournalInput, LedgerHeadUncheckedUpdateWithoutJournalInput>
  }

  export type LedgerHeadUpdateWithoutJournalInput = {
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedJournal?: FixedJournalUpdateManyWithoutLedgerHeadNestedInput
    accountHead?: AccountHeadUpdateOneRequiredWithoutLedgerHeadNestedInput
  }

  export type LedgerHeadUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    headCodeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedJournal?: FixedJournalUncheckedUpdateManyWithoutLedgerHeadNestedInput
  }

  export type TransactionInfoUpsertWithoutJournalInput = {
    update: XOR<TransactionInfoUpdateWithoutJournalInput, TransactionInfoUncheckedUpdateWithoutJournalInput>
    create: XOR<TransactionInfoCreateWithoutJournalInput, TransactionInfoUncheckedCreateWithoutJournalInput>
    where?: TransactionInfoWhereInput
  }

  export type TransactionInfoUpdateToOneWithWhereWithoutJournalInput = {
    where?: TransactionInfoWhereInput
    data: XOR<TransactionInfoUpdateWithoutJournalInput, TransactionInfoUncheckedUpdateWithoutJournalInput>
  }

  export type TransactionInfoUpdateWithoutJournalInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutTransactionInfoNestedInput
    chemist?: ChemistUpdateOneWithoutTransactionInfoNestedInput
    customers?: CustomersUpdateOneWithoutTransactionInfoNestedInput
    user?: UserUpdateOneWithoutTransactionInfoNestedInput
    party?: PartyUpdateOneWithoutTransactionInfoNestedInput
    stakeholder?: StakeholderUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type BankTransactionUpsertWithWhereUniqueWithoutJournalInput = {
    where: BankTransactionWhereUniqueInput
    update: XOR<BankTransactionUpdateWithoutJournalInput, BankTransactionUncheckedUpdateWithoutJournalInput>
    create: XOR<BankTransactionCreateWithoutJournalInput, BankTransactionUncheckedCreateWithoutJournalInput>
  }

  export type BankTransactionUpdateWithWhereUniqueWithoutJournalInput = {
    where: BankTransactionWhereUniqueInput
    data: XOR<BankTransactionUpdateWithoutJournalInput, BankTransactionUncheckedUpdateWithoutJournalInput>
  }

  export type BankTransactionUpdateManyWithWhereWithoutJournalInput = {
    where: BankTransactionScalarWhereInput
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyWithoutJournalInput>
  }

  export type ChemistCreateWithoutFixedJournalInput = {
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutChemistInput
    scopes?: ScopeCreateNestedManyWithoutChemistInput
    order?: OrderCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutChemistInput
  }

  export type ChemistUncheckedCreateWithoutFixedJournalInput = {
    id?: number
    chemistId: string
    depoId: number
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ScopeUncheckedCreateNestedManyWithoutChemistInput
    order?: OrderUncheckedCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutChemistInput
  }

  export type ChemistCreateOrConnectWithoutFixedJournalInput = {
    where: ChemistWhereUniqueInput
    create: XOR<ChemistCreateWithoutFixedJournalInput, ChemistUncheckedCreateWithoutFixedJournalInput>
  }

  export type DepoCreateWithoutFixedJournalInput = {
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistCreateNestedManyWithoutDepoInput
    inventory?: InventoryCreateNestedManyWithoutDepoInput
    jobPost?: JobPostCreateNestedManyWithoutDepoInput
    journal?: JournalCreateNestedManyWithoutDepoInput
    scopes?: ScopeCreateNestedManyWithoutDepoInput
  }

  export type DepoUncheckedCreateWithoutFixedJournalInput = {
    id?: number
    depoName: string
    location: string
    scopeId?: number | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    chemist?: ChemistUncheckedCreateNestedManyWithoutDepoInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutDepoInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutDepoInput
    journal?: JournalUncheckedCreateNestedManyWithoutDepoInput
    scopes?: ScopeUncheckedCreateNestedManyWithoutDepoInput
  }

  export type DepoCreateOrConnectWithoutFixedJournalInput = {
    where: DepoWhereUniqueInput
    create: XOR<DepoCreateWithoutFixedJournalInput, DepoUncheckedCreateWithoutFixedJournalInput>
  }

  export type LedgerHeadCreateWithoutFixedJournalInput = {
    ledgerName: string
    ledgerCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    journal?: JournalCreateNestedManyWithoutLedgerHeadInput
    accountHead: AccountHeadCreateNestedOneWithoutLedgerHeadInput
  }

  export type LedgerHeadUncheckedCreateWithoutFixedJournalInput = {
    id?: number
    ledgerName: string
    ledgerCode: string
    headCodeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    journal?: JournalUncheckedCreateNestedManyWithoutLedgerHeadInput
  }

  export type LedgerHeadCreateOrConnectWithoutFixedJournalInput = {
    where: LedgerHeadWhereUniqueInput
    create: XOR<LedgerHeadCreateWithoutFixedJournalInput, LedgerHeadUncheckedCreateWithoutFixedJournalInput>
  }

  export type InventoryCreateWithoutFixedJournalInput = {
    date: Date | string
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
    depo?: DepoCreateNestedOneWithoutInventoryInput
    product: ProductCreateNestedOneWithoutInventoryInput
    transactionInfo?: TransactionInfoCreateNestedOneWithoutInventoryInput
    user?: UserCreateNestedOneWithoutInventoriesInput
  }

  export type InventoryUncheckedCreateWithoutFixedJournalInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    employeeId?: string | null
    transactionId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryCreateOrConnectWithoutFixedJournalInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutFixedJournalInput, InventoryUncheckedCreateWithoutFixedJournalInput>
  }

  export type InventoryCreateManyFixedJournalInputEnvelope = {
    data: InventoryCreateManyFixedJournalInput | InventoryCreateManyFixedJournalInput[]
    skipDuplicates?: boolean
  }

  export type ChemistUpsertWithoutFixedJournalInput = {
    update: XOR<ChemistUpdateWithoutFixedJournalInput, ChemistUncheckedUpdateWithoutFixedJournalInput>
    create: XOR<ChemistCreateWithoutFixedJournalInput, ChemistUncheckedCreateWithoutFixedJournalInput>
    where?: ChemistWhereInput
  }

  export type ChemistUpdateToOneWithWhereWithoutFixedJournalInput = {
    where?: ChemistWhereInput
    data: XOR<ChemistUpdateWithoutFixedJournalInput, ChemistUncheckedUpdateWithoutFixedJournalInput>
  }

  export type ChemistUpdateWithoutFixedJournalInput = {
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutChemistNestedInput
    scopes?: ScopeUpdateManyWithoutChemistNestedInput
    order?: OrderUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateWithoutFixedJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ScopeUncheckedUpdateManyWithoutChemistNestedInput
    order?: OrderUncheckedUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutChemistNestedInput
  }

  export type DepoUpsertWithoutFixedJournalInput = {
    update: XOR<DepoUpdateWithoutFixedJournalInput, DepoUncheckedUpdateWithoutFixedJournalInput>
    create: XOR<DepoCreateWithoutFixedJournalInput, DepoUncheckedCreateWithoutFixedJournalInput>
    where?: DepoWhereInput
  }

  export type DepoUpdateToOneWithWhereWithoutFixedJournalInput = {
    where?: DepoWhereInput
    data: XOR<DepoUpdateWithoutFixedJournalInput, DepoUncheckedUpdateWithoutFixedJournalInput>
  }

  export type DepoUpdateWithoutFixedJournalInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUpdateManyWithoutDepoNestedInput
    journal?: JournalUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateWithoutFixedJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutDepoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutDepoNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutDepoNestedInput
  }

  export type LedgerHeadUpsertWithoutFixedJournalInput = {
    update: XOR<LedgerHeadUpdateWithoutFixedJournalInput, LedgerHeadUncheckedUpdateWithoutFixedJournalInput>
    create: XOR<LedgerHeadCreateWithoutFixedJournalInput, LedgerHeadUncheckedCreateWithoutFixedJournalInput>
    where?: LedgerHeadWhereInput
  }

  export type LedgerHeadUpdateToOneWithWhereWithoutFixedJournalInput = {
    where?: LedgerHeadWhereInput
    data: XOR<LedgerHeadUpdateWithoutFixedJournalInput, LedgerHeadUncheckedUpdateWithoutFixedJournalInput>
  }

  export type LedgerHeadUpdateWithoutFixedJournalInput = {
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateManyWithoutLedgerHeadNestedInput
    accountHead?: AccountHeadUpdateOneRequiredWithoutLedgerHeadNestedInput
  }

  export type LedgerHeadUncheckedUpdateWithoutFixedJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    headCodeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUncheckedUpdateManyWithoutLedgerHeadNestedInput
  }

  export type InventoryUpsertWithWhereUniqueWithoutFixedJournalInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutFixedJournalInput, InventoryUncheckedUpdateWithoutFixedJournalInput>
    create: XOR<InventoryCreateWithoutFixedJournalInput, InventoryUncheckedCreateWithoutFixedJournalInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutFixedJournalInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutFixedJournalInput, InventoryUncheckedUpdateWithoutFixedJournalInput>
  }

  export type InventoryUpdateManyWithWhereWithoutFixedJournalInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutFixedJournalInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quintity: number
    tpRate: number
    amount: number
    product: ProductCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quintity: number
    tpRate: number
    amount: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderStatusCreateWithoutOrderInput = {
    status?: $Enums.OrdStatus
    comments?: string | null
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderStatusUncheckedCreateWithoutOrderInput = {
    id?: number
    status?: $Enums.OrdStatus
    comments?: string | null
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderStatusCreateOrConnectWithoutOrderInput = {
    where: OrderStatusWhereUniqueInput
    create: XOR<OrderStatusCreateWithoutOrderInput, OrderStatusUncheckedCreateWithoutOrderInput>
  }

  export type OrderStatusCreateManyOrderInputEnvelope = {
    data: OrderStatusCreateManyOrderInput | OrderStatusCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ChemistCreateWithoutOrderInput = {
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    depo: DepoCreateNestedOneWithoutChemistInput
    scopes?: ScopeCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutChemistInput
  }

  export type ChemistUncheckedCreateWithoutOrderInput = {
    id?: number
    chemistId: string
    depoId: number
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ScopeUncheckedCreateNestedManyWithoutChemistInput
    FixedJournal?: FixedJournalUncheckedCreateNestedManyWithoutChemistInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutChemistInput
  }

  export type ChemistCreateOrConnectWithoutOrderInput = {
    where: ChemistWhereUniqueInput
    create: XOR<ChemistCreateWithoutOrderInput, ChemistUncheckedCreateWithoutOrderInput>
  }

  export type UserCreateWithoutOrderInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderStatusUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderStatusWhereUniqueInput
    update: XOR<OrderStatusUpdateWithoutOrderInput, OrderStatusUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderStatusCreateWithoutOrderInput, OrderStatusUncheckedCreateWithoutOrderInput>
  }

  export type OrderStatusUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderStatusWhereUniqueInput
    data: XOR<OrderStatusUpdateWithoutOrderInput, OrderStatusUncheckedUpdateWithoutOrderInput>
  }

  export type OrderStatusUpdateManyWithWhereWithoutOrderInput = {
    where: OrderStatusScalarWhereInput
    data: XOR<OrderStatusUpdateManyMutationInput, OrderStatusUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderStatusScalarWhereInput = {
    AND?: OrderStatusScalarWhereInput | OrderStatusScalarWhereInput[]
    OR?: OrderStatusScalarWhereInput[]
    NOT?: OrderStatusScalarWhereInput | OrderStatusScalarWhereInput[]
    id?: IntFilter<"OrderStatus"> | number
    orderNo?: StringNullableFilter<"OrderStatus"> | string | null
    status?: EnumOrdStatusFilter<"OrderStatus"> | $Enums.OrdStatus
    comments?: StringNullableFilter<"OrderStatus"> | string | null
    dateTime?: DateTimeFilter<"OrderStatus"> | Date | string
    createdAt?: DateTimeFilter<"OrderStatus"> | Date | string
    updatedAt?: DateTimeFilter<"OrderStatus"> | Date | string
  }

  export type ChemistUpsertWithoutOrderInput = {
    update: XOR<ChemistUpdateWithoutOrderInput, ChemistUncheckedUpdateWithoutOrderInput>
    create: XOR<ChemistCreateWithoutOrderInput, ChemistUncheckedCreateWithoutOrderInput>
    where?: ChemistWhereInput
  }

  export type ChemistUpdateToOneWithWhereWithoutOrderInput = {
    where?: ChemistWhereInput
    data: XOR<ChemistUpdateWithoutOrderInput, ChemistUncheckedUpdateWithoutOrderInput>
  }

  export type ChemistUpdateWithoutOrderInput = {
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutChemistNestedInput
    scopes?: ScopeUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ScopeUncheckedUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutChemistNestedInput
  }

  export type UserUpsertWithoutOrderInput = {
    update: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
  }

  export type UserUpdateWithoutOrderInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateWithoutOrderItemInput = {
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderStatus?: OrderStatusCreateNestedManyWithoutOrderInput
    chemist: ChemistCreateNestedOneWithoutOrderInput
    user: UserCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemInput = {
    id?: number
    employeeId: string
    chemistId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderStatus?: OrderStatusUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
  }

  export type ProductCreateWithoutOrderItemInput = {
    name: string
    description: string
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    Stakeholder?: StakeholderCreateNestedOneWithoutProductInput
    subCategory: SubCategoryCreateNestedOneWithoutProductInput
    unit: UnitCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId?: number | null
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
    targetProductBatch?: TargetProductBatchUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderUpsertWithoutOrderItemInput = {
    update: XOR<OrderUpdateWithoutOrderItemInput, OrderUncheckedUpdateWithoutOrderItemInput>
    create: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemInput, OrderUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderUpdateWithoutOrderItemInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderStatus?: OrderStatusUpdateManyWithoutOrderNestedInput
    chemist?: ChemistUpdateOneRequiredWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderStatus?: OrderStatusUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemInput = {
    update: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductUpdateWithoutOrderItemInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    Stakeholder?: StakeholderUpdateOneWithoutProductNestedInput
    subCategory?: SubCategoryUpdateOneRequiredWithoutProductNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutOrderStatusInput = {
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemCreateNestedManyWithoutOrderInput
    chemist: ChemistCreateNestedOneWithoutOrderInput
    user: UserCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderStatusInput = {
    id?: number
    employeeId: string
    chemistId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderStatusInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderStatusInput, OrderUncheckedCreateWithoutOrderStatusInput>
  }

  export type OrderUpsertWithoutOrderStatusInput = {
    update: XOR<OrderUpdateWithoutOrderStatusInput, OrderUncheckedUpdateWithoutOrderStatusInput>
    create: XOR<OrderCreateWithoutOrderStatusInput, OrderUncheckedCreateWithoutOrderStatusInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderStatusInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderStatusInput, OrderUncheckedUpdateWithoutOrderStatusInput>
  }

  export type OrderUpdateWithoutOrderStatusInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateManyWithoutOrderNestedInput
    chemist?: ChemistUpdateOneRequiredWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutAttendanceInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
  }

  export type UserUpsertWithoutAttendanceInput = {
    update: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateWithoutAttendanceInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOvertimeInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOvertimeInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOvertimeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOvertimeInput, UserUncheckedCreateWithoutOvertimeInput>
  }

  export type UserUpsertWithoutOvertimeInput = {
    update: XOR<UserUpdateWithoutOvertimeInput, UserUncheckedUpdateWithoutOvertimeInput>
    create: XOR<UserCreateWithoutOvertimeInput, UserUncheckedCreateWithoutOvertimeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOvertimeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOvertimeInput, UserUncheckedUpdateWithoutOvertimeInput>
  }

  export type UserUpdateWithoutOvertimeInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOvertimeInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LevesCreateWithoutLeaveTypeInput = {
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLevesInput
  }

  export type LevesUncheckedCreateWithoutLeaveTypeInput = {
    id?: number
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevesCreateOrConnectWithoutLeaveTypeInput = {
    where: LevesWhereUniqueInput
    create: XOR<LevesCreateWithoutLeaveTypeInput, LevesUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LevesCreateManyLeaveTypeInputEnvelope = {
    data: LevesCreateManyLeaveTypeInput | LevesCreateManyLeaveTypeInput[]
    skipDuplicates?: boolean
  }

  export type LevesUpsertWithWhereUniqueWithoutLeaveTypeInput = {
    where: LevesWhereUniqueInput
    update: XOR<LevesUpdateWithoutLeaveTypeInput, LevesUncheckedUpdateWithoutLeaveTypeInput>
    create: XOR<LevesCreateWithoutLeaveTypeInput, LevesUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LevesUpdateWithWhereUniqueWithoutLeaveTypeInput = {
    where: LevesWhereUniqueInput
    data: XOR<LevesUpdateWithoutLeaveTypeInput, LevesUncheckedUpdateWithoutLeaveTypeInput>
  }

  export type LevesUpdateManyWithWhereWithoutLeaveTypeInput = {
    where: LevesScalarWhereInput
    data: XOR<LevesUpdateManyMutationInput, LevesUncheckedUpdateManyWithoutLeaveTypeInput>
  }

  export type UserCreateWithoutLevesInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLevesInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLevesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLevesInput, UserUncheckedCreateWithoutLevesInput>
  }

  export type LeaveTypeCreateWithoutLevesInput = {
    leaveName: string
  }

  export type LeaveTypeUncheckedCreateWithoutLevesInput = {
    id?: number
    leaveName: string
  }

  export type LeaveTypeCreateOrConnectWithoutLevesInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutLevesInput, LeaveTypeUncheckedCreateWithoutLevesInput>
  }

  export type UserUpsertWithoutLevesInput = {
    update: XOR<UserUpdateWithoutLevesInput, UserUncheckedUpdateWithoutLevesInput>
    create: XOR<UserCreateWithoutLevesInput, UserUncheckedCreateWithoutLevesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLevesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLevesInput, UserUncheckedUpdateWithoutLevesInput>
  }

  export type UserUpdateWithoutLevesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLevesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LeaveTypeUpsertWithoutLevesInput = {
    update: XOR<LeaveTypeUpdateWithoutLevesInput, LeaveTypeUncheckedUpdateWithoutLevesInput>
    create: XOR<LeaveTypeCreateWithoutLevesInput, LeaveTypeUncheckedCreateWithoutLevesInput>
    where?: LeaveTypeWhereInput
  }

  export type LeaveTypeUpdateToOneWithWhereWithoutLevesInput = {
    where?: LeaveTypeWhereInput
    data: XOR<LeaveTypeUpdateWithoutLevesInput, LeaveTypeUncheckedUpdateWithoutLevesInput>
  }

  export type LeaveTypeUpdateWithoutLevesInput = {
    leaveName?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveTypeUncheckedUpdateWithoutLevesInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveName?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutSalaryInfoInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    payroll?: PayrollCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalaryInfoInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    payroll?: PayrollUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalaryInfoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryInfoInput, UserUncheckedCreateWithoutSalaryInfoInput>
  }

  export type UserUpsertWithoutSalaryInfoInput = {
    update: XOR<UserUpdateWithoutSalaryInfoInput, UserUncheckedUpdateWithoutSalaryInfoInput>
    create: XOR<UserCreateWithoutSalaryInfoInput, UserUncheckedCreateWithoutSalaryInfoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryInfoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryInfoInput, UserUncheckedUpdateWithoutSalaryInfoInput>
  }

  export type UserUpdateWithoutSalaryInfoInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    payroll?: PayrollUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    payroll?: PayrollUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPayrollInput = {
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    leves?: LevesCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetCreateNestedOneWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    overtime?: OvertimeCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoCreateNestedManyWithoutUserInput
    scope?: ScopeCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoCreateNestedManyWithoutUserInput
    inventories?: InventoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPayrollInput = {
    id?: number
    employeeId: string
    name: string
    email: string
    password: string
    photo?: string | null
    roles: JsonNullValueInput | InputJsonValue
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productWiseTarget?: ProductWiseTargetUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    leves?: LevesUncheckedCreateNestedManyWithoutUserInput
    mpoTarget?: MpoTargetUncheckedCreateNestedOneWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    salaryInfo?: SalaryInfoUncheckedCreateNestedManyWithoutUserInput
    scope?: ScopeUncheckedCreateNestedOneWithoutUserInput
    transactionInfo?: TransactionInfoUncheckedCreateNestedManyWithoutUserInput
    inventories?: InventoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPayrollInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollInput, UserUncheckedCreateWithoutPayrollInput>
  }

  export type UserUpsertWithoutPayrollInput = {
    update: XOR<UserUpdateWithoutPayrollInput, UserUncheckedUpdateWithoutPayrollInput>
    create: XOR<UserCreateWithoutPayrollInput, UserUncheckedCreateWithoutPayrollInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPayrollInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPayrollInput, UserUncheckedUpdateWithoutPayrollInput>
  }

  export type UserUpdateWithoutPayrollInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    leves?: LevesUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUpdateOneWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUpdateManyWithoutUserNestedInput
    scope?: ScopeUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutUserNestedInput
    inventories?: InventoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    leves?: LevesUncheckedUpdateManyWithoutUserNestedInput
    mpoTarget?: MpoTargetUncheckedUpdateOneWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    salaryInfo?: SalaryInfoUncheckedUpdateManyWithoutUserNestedInput
    scope?: ScopeUncheckedUpdateOneWithoutUserNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutUserNestedInput
    inventories?: InventoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttendanceCreateManyUserInput = {
    id?: number
    date: Date | string
    time: string
    status: string
    comments: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevesCreateManyUserInput = {
    id?: number
    leaveTypeId: number
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: number
    chemistId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateManyUserInput = {
    id?: number
    overtimeDate: Date | string
    overtimeHours: string
    others: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyUserInput = {
    id?: number
    payDate: Date | string
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insentive: number
    eidBonus: number
    boishakhi: number
    others: number
    fp: number
    insurance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryInfoCreateManyUserInput = {
    id?: number
    basicSalary: number
    houseRend: number
    mobile: number
    medial: number
    taDa: number
    insuranceAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionInfoCreateManyUserInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateManyUserInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type AttendanceUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevesUpdateWithoutUserInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLevesNestedInput
  }

  export type LevesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveTypeId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveTypeId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateManyWithoutOrderNestedInput
    orderStatus?: OrderStatusUpdateManyWithoutOrderNestedInput
    chemist?: ChemistUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    orderStatus?: OrderStatusUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUpdateWithoutUserInput = {
    overtimeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimeHours?: StringFieldUpdateOperationsInput | string
    others?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    overtimeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimeHours?: StringFieldUpdateOperationsInput | string
    others?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    overtimeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimeHours?: StringFieldUpdateOperationsInput | string
    others?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutUserInput = {
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insentive?: FloatFieldUpdateOperationsInput | number
    eidBonus?: FloatFieldUpdateOperationsInput | number
    boishakhi?: FloatFieldUpdateOperationsInput | number
    others?: FloatFieldUpdateOperationsInput | number
    fp?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insentive?: FloatFieldUpdateOperationsInput | number
    eidBonus?: FloatFieldUpdateOperationsInput | number
    boishakhi?: FloatFieldUpdateOperationsInput | number
    others?: FloatFieldUpdateOperationsInput | number
    fp?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insentive?: FloatFieldUpdateOperationsInput | number
    eidBonus?: FloatFieldUpdateOperationsInput | number
    boishakhi?: FloatFieldUpdateOperationsInput | number
    others?: FloatFieldUpdateOperationsInput | number
    fp?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryInfoUpdateWithoutUserInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insuranceAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryInfoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insuranceAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryInfoUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    houseRend?: FloatFieldUpdateOperationsInput | number
    mobile?: FloatFieldUpdateOperationsInput | number
    medial?: FloatFieldUpdateOperationsInput | number
    taDa?: FloatFieldUpdateOperationsInput | number
    insuranceAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionInfoUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUpdateManyWithoutTransactionInfoNestedInput
    chemist?: ChemistUpdateOneWithoutTransactionInfoNestedInput
    customers?: CustomersUpdateOneWithoutTransactionInfoNestedInput
    party?: PartyUpdateOneWithoutTransactionInfoNestedInput
    stakeholder?: StakeholderUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
    depo?: DepoUpdateOneWithoutInventoryNestedInput
    fixedJournal?: FixedJournalUpdateOneWithoutInventoryNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ScopeCreateManyJobPostInput = {
    id?: number
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScopeUpdateWithoutJobPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutScopesNestedInput
    depo?: DepoUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUpdateManyWithoutScopesNestedInput
    user?: UserUpdateOneRequiredWithoutScopeNestedInput
  }

  export type ScopeUncheckedUpdateWithoutJobPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutScopesNestedInput
    depo?: DepoUncheckedUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUncheckedUpdateManyWithoutScopesNestedInput
  }

  export type ScopeUncheckedUpdateManyWithoutJobPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedJournalCreateManyChemistInput = {
    id?: number
    date: Date | string
    voucherNo: string
    ledgerHeadId: number
    depoId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyChemistInput = {
    id?: number
    employeeId: string
    orderNo: string
    date?: Date | string
    discount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionInfoCreateManyChemistInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScopeUpdateWithoutChemistInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUpdateManyWithoutScopesNestedInput
    user?: UserUpdateOneRequiredWithoutScopeNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutScopeNestedInput
  }

  export type ScopeUncheckedUpdateWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUncheckedUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUncheckedUpdateManyWithoutScopesNestedInput
  }

  export type ScopeUncheckedUpdateManyWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedJournalUpdateWithoutChemistInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutFixedJournalNestedInput
    ledgerHead?: LedgerHeadUpdateOneRequiredWithoutFixedJournalNestedInput
    inventory?: InventoryUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    ledgerHeadId?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateManyWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    ledgerHeadId?: IntFieldUpdateOperationsInput | number
    depoId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutChemistInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateManyWithoutOrderNestedInput
    orderStatus?: OrderStatusUpdateManyWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    orderStatus?: OrderStatusUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionInfoUpdateWithoutChemistInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUpdateManyWithoutTransactionInfoNestedInput
    customers?: CustomersUpdateOneWithoutTransactionInfoNestedInput
    user?: UserUpdateOneWithoutTransactionInfoNestedInput
    party?: PartyUpdateOneWithoutTransactionInfoNestedInput
    stakeholder?: StakeholderUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateManyWithoutChemistInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemistCreateManyDepoInput = {
    id?: number
    chemistId: string
    pharmacyName: string
    contactPerson: string
    contactNo: string
    address: string
    photo?: string | null
    discountRate?: number | null
    openingDueAmount?: number | null
    openingDate?: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedJournalCreateManyDepoInput = {
    id?: number
    date: Date | string
    voucherNo: string
    chemistId: string
    ledgerHeadId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateManyDepoInput = {
    id?: number
    date: Date | string
    productId: number
    employeeId?: string | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type JobPostCreateManyDepoInput = {
    id?: number
    postName: string
    qualification: string
    responsibility: string
    isDelete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCreateManyDepoInput = {
    id?: number
    transactionId?: number | null
    ledgerHeadId?: number | null
    date: Date | string
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChemistUpdateWithoutDepoInput = {
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ScopeUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutChemistNestedInput
    order?: OrderUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ScopeUncheckedUpdateManyWithoutChemistNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutChemistNestedInput
    order?: OrderUncheckedUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateManyWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedJournalUpdateWithoutDepoInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateOneRequiredWithoutFixedJournalNestedInput
    ledgerHead?: LedgerHeadUpdateOneRequiredWithoutFixedJournalNestedInput
    inventory?: InventoryUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    ledgerHeadId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateManyWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    ledgerHeadId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutDepoInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
    fixedJournal?: FixedJournalUpdateOneWithoutInventoryNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutInventoryNestedInput
    user?: UserUpdateOneWithoutInventoriesNestedInput
  }

  export type InventoryUncheckedUpdateWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryUncheckedUpdateManyWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobPostUpdateWithoutDepoInput = {
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: ScopeUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: ScopeUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateManyWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    postName?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUpdateWithoutDepoInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerHead?: LedgerHeadUpdateOneWithoutJournalNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutJournalNestedInput
    bankTransaction?: BankTransactionUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransaction?: BankTransactionUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateManyWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeUpdateWithoutDepoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUpdateManyWithoutScopesNestedInput
    user?: UserUpdateOneRequiredWithoutScopeNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutScopeNestedInput
  }

  export type ScopeUncheckedUpdateWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutScopesNestedInput
    stakeholder?: StakeholderUncheckedUpdateManyWithoutScopesNestedInput
  }

  export type ScopeUncheckedUpdateManyWithoutDepoInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionInfoCreateManyPartyInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    stakeholderId?: string | null
    employeeId?: string | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionInfoUpdateWithoutPartyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUpdateManyWithoutTransactionInfoNestedInput
    chemist?: ChemistUpdateOneWithoutTransactionInfoNestedInput
    customers?: CustomersUpdateOneWithoutTransactionInfoNestedInput
    user?: UserUpdateOneWithoutTransactionInfoNestedInput
    stakeholder?: StakeholderUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateWithoutPartyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateManyWithoutPartyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyStakeholderInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type stakeholderChemberCreateManyStakeholderInput = {
    id?: number
    address: string
    chemberDay: string
    chemberTime: string
    chemberName: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderOcationCreateManyStakeholderInput = {
    id?: number
    ocationName: string
    relation: string
    personName?: string | null
    dob?: Date | string | null
    otherInfo?: string | null
  }

  export type TransactionInfoCreateManyStakeholderInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    customerId?: number | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutStakeholderInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUpdateManyWithoutProductNestedInput
    subCategory?: SubCategoryUpdateOneRequiredWithoutProductNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeUpdateWithoutStakeholderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutScopesNestedInput
    depo?: DepoUpdateManyWithoutScopesNestedInput
    user?: UserUpdateOneRequiredWithoutScopeNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutScopeNestedInput
  }

  export type ScopeUncheckedUpdateWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutScopesNestedInput
    depo?: DepoUncheckedUpdateManyWithoutScopesNestedInput
  }

  export type ScopeUncheckedUpdateManyWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stakeholderChemberUpdateWithoutStakeholderInput = {
    address?: StringFieldUpdateOperationsInput | string
    chemberDay?: StringFieldUpdateOperationsInput | string
    chemberTime?: StringFieldUpdateOperationsInput | string
    chemberName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stakeholderChemberUncheckedUpdateWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    chemberDay?: StringFieldUpdateOperationsInput | string
    chemberTime?: StringFieldUpdateOperationsInput | string
    chemberName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stakeholderChemberUncheckedUpdateManyWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    chemberDay?: StringFieldUpdateOperationsInput | string
    chemberTime?: StringFieldUpdateOperationsInput | string
    chemberName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderOcationUpdateWithoutStakeholderInput = {
    ocationName?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StakeholderOcationUncheckedUpdateWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    ocationName?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StakeholderOcationUncheckedUpdateManyWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    ocationName?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionInfoUpdateWithoutStakeholderInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUpdateManyWithoutTransactionInfoNestedInput
    chemist?: ChemistUpdateOneWithoutTransactionInfoNestedInput
    customers?: CustomersUpdateOneWithoutTransactionInfoNestedInput
    user?: UserUpdateOneWithoutTransactionInfoNestedInput
    party?: PartyUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateManyWithoutStakeholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderCreateManyStakeholderDeisgnationInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    degreeId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderUpdateWithoutStakeholderDeisgnationInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutStakeholderNestedInput
    stakeholderDegree?: StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput
    scopes?: ScopeUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateWithoutStakeholderDeisgnationInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutStakeholderNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateManyWithoutStakeholderDeisgnationInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderCreateManyStakeholderDegreeInput = {
    id?: number
    scopeId?: number | null
    stakeId: string
    name: string
    designationId: number
    category: string
    officeAddress: string
    contactNo: string
    honorary: number
    paymentDate: Date | string
    rxCommitment: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StakeholderUpdateWithoutStakeholderDegreeInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutStakeholderNestedInput
    stakeholderDeisgnation?: StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput
    scopes?: ScopeUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateWithoutStakeholderDegreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutStakeholderNestedInput
    scopes?: ScopeUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateManyWithoutStakeholderDegreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionInfoCreateManyCustomersInput = {
    id?: number
    date: Date | string
    voucherNo: string
    invoiceNo?: string | null
    chemistId?: string | null
    stakeholderId?: string | null
    employeeId?: string | null
    partyId?: number | null
    voucherType: $Enums.VoucherType
    paymentType?: $Enums.PaymentType | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionInfoUpdateWithoutCustomersInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUpdateManyWithoutTransactionInfoNestedInput
    chemist?: ChemistUpdateOneWithoutTransactionInfoNestedInput
    user?: UserUpdateOneWithoutTransactionInfoNestedInput
    party?: PartyUpdateOneWithoutTransactionInfoNestedInput
    stakeholder?: StakeholderUpdateOneWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutTransactionInfoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionInfoNestedInput
  }

  export type TransactionInfoUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    chemistId?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    partyId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentType?: NullableEnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemistUpdateWithoutScopesInput = {
    chemistId?: StringFieldUpdateOperationsInput | string
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneRequiredWithoutChemistNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutChemistNestedInput
    order?: OrderUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateWithoutScopesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutChemistNestedInput
    order?: OrderUncheckedUpdateManyWithoutChemistNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutChemistNestedInput
  }

  export type ChemistUncheckedUpdateManyWithoutScopesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    pharmacyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    discountRate?: NullableIntFieldUpdateOperationsInput | number | null
    openingDueAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepoUpdateWithoutScopesInput = {
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUpdateManyWithoutDepoNestedInput
    journal?: JournalUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateWithoutScopesInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUncheckedUpdateManyWithoutDepoNestedInput
    FixedJournal?: FixedJournalUncheckedUpdateManyWithoutDepoNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutDepoNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutDepoNestedInput
    journal?: JournalUncheckedUpdateManyWithoutDepoNestedInput
  }

  export type DepoUncheckedUpdateManyWithoutScopesInput = {
    id?: IntFieldUpdateOperationsInput | number
    depoName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StakeholderUpdateWithoutScopesInput = {
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutStakeholderNestedInput
    stakeholderDegree?: StakeholderDegreeUpdateOneRequiredWithoutStakeholderNestedInput
    stakeholderDeisgnation?: StakeholderDeisgnationUpdateOneRequiredWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateWithoutScopesInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderChember?: stakeholderChemberUncheckedUpdateManyWithoutStakeholderNestedInput
    stakeholderOcation?: StakeholderOcationUncheckedUpdateManyWithoutStakeholderNestedInput
    transactionInfo?: TransactionInfoUncheckedUpdateManyWithoutStakeholderNestedInput
  }

  export type StakeholderUncheckedUpdateManyWithoutScopesInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    stakeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designationId?: IntFieldUpdateOperationsInput | number
    degreeId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    officeAddress?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    honorary?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rxCommitment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchCreateManyProductWiseTargetInput = {
    id?: number
    productId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TargetProductBatchUpdateWithoutProductWiseTargetInput = {
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTargetProductBatchNestedInput
  }

  export type TargetProductBatchUncheckedUpdateWithoutProductWiseTargetInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchUncheckedUpdateManyWithoutProductWiseTargetInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryCreateManyCategoryInput = {
    id?: number
    subCategoryName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubCategoryUpdateWithoutCategoryInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManySubCategoryInput = {
    id?: number
    name: string
    description: string
    stakeholderId?: number | null
    size: string
    unitId: number
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ProductUpdateWithoutSubCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUpdateManyWithoutProductNestedInput
    Stakeholder?: StakeholderUpdateOneWithoutProductNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSubCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyUnitInput = {
    id?: number
    name: string
    description: string
    subCategoryId: number
    stakeholderId?: number | null
    size: string
    mrp?: number
    tp?: number
    balance: number
    quantity: number
    unitPrice?: number
    date: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ProductUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUpdateManyWithoutProductNestedInput
    Stakeholder?: StakeholderUpdateOneWithoutProductNestedInput
    subCategory?: SubCategoryUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetProductBatch?: TargetProductBatchUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategoryId?: IntFieldUpdateOperationsInput | number
    stakeholderId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: StringFieldUpdateOperationsInput | string
    mrp?: FloatFieldUpdateOperationsInput | number
    tp?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerHeadCreateManyAccountHeadInput = {
    id?: number
    ledgerName: string
    ledgerCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerHeadUpdateWithoutAccountHeadInput = {
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedJournal?: FixedJournalUpdateManyWithoutLedgerHeadNestedInput
    journal?: JournalUpdateManyWithoutLedgerHeadNestedInput
  }

  export type LedgerHeadUncheckedUpdateWithoutAccountHeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedJournal?: FixedJournalUncheckedUpdateManyWithoutLedgerHeadNestedInput
    journal?: JournalUncheckedUpdateManyWithoutLedgerHeadNestedInput
  }

  export type LedgerHeadUncheckedUpdateManyWithoutAccountHeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerName?: StringFieldUpdateOperationsInput | string
    ledgerCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedJournalCreateManyLedgerHeadInput = {
    id?: number
    date: Date | string
    voucherNo: string
    chemistId: string
    depoId: number
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCreateManyLedgerHeadInput = {
    id?: number
    transactionId?: number | null
    date: Date | string
    depoId?: number | null
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedJournalUpdateWithoutLedgerHeadInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chemist?: ChemistUpdateOneRequiredWithoutFixedJournalNestedInput
    depo?: DepoUpdateOneRequiredWithoutFixedJournalNestedInput
    inventory?: InventoryUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateWithoutLedgerHeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutFixedJournalNestedInput
  }

  export type FixedJournalUncheckedUpdateManyWithoutLedgerHeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    chemistId?: StringFieldUpdateOperationsInput | string
    depoId?: IntFieldUpdateOperationsInput | number
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUpdateWithoutLedgerHeadInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneWithoutJournalNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutJournalNestedInput
    bankTransaction?: BankTransactionUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutLedgerHeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransaction?: BankTransactionUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateManyWithoutLedgerHeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchCreateManyProductInput = {
    id?: number
    productTargetId: number
    numberOfProduct: number
    insentiveAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateManyProductInput = {
    id?: number
    date: Date | string
    depoId?: number | null
    employeeId?: string | null
    transactionId?: number | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    orderId: number
    quintity: number
    tpRate: number
    amount: number
  }

  export type TargetProductBatchUpdateWithoutProductInput = {
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productWiseTarget?: ProductWiseTargetUpdateOneRequiredWithoutTargetProductBatchNestedInput
  }

  export type TargetProductBatchUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productTargetId?: IntFieldUpdateOperationsInput | number
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TargetProductBatchUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productTargetId?: IntFieldUpdateOperationsInput | number
    numberOfProduct?: IntFieldUpdateOperationsInput | number
    insentiveAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutProductInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
    depo?: DepoUpdateOneWithoutInventoryNestedInput
    fixedJournal?: FixedJournalUpdateOneWithoutInventoryNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutInventoryNestedInput
    user?: UserUpdateOneWithoutInventoriesNestedInput
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemUpdateWithoutProductInput = {
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type BankTransactionCreateManyBankAccountInput = {
    id?: number
    date: Date | string
    debitAmount?: number | null
    creditAmount?: number | null
    journalId?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateWithoutBankAccountInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneWithoutBankTransactionNestedInput
  }

  export type BankTransactionUncheckedUpdateWithoutBankAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    journalId?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyWithoutBankAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    journalId?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyTransactionInfoInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    employeeId?: string | null
    fixedJournalId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type JournalCreateManyTransactionInfoInput = {
    id?: number
    ledgerHeadId?: number | null
    date: Date | string
    depoId?: number | null
    creditAmount?: number | null
    debitAmount?: number | null
    narration?: string | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateWithoutTransactionInfoInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
    depo?: DepoUpdateOneWithoutInventoryNestedInput
    fixedJournal?: FixedJournalUpdateOneWithoutInventoryNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    user?: UserUpdateOneWithoutInventoriesNestedInput
  }

  export type InventoryUncheckedUpdateWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryUncheckedUpdateManyWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedJournalId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JournalUpdateWithoutTransactionInfoInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depo?: DepoUpdateOneWithoutJournalNestedInput
    ledgerHead?: LedgerHeadUpdateOneWithoutJournalNestedInput
    bankTransaction?: BankTransactionUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransaction?: BankTransactionUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateManyWithoutTransactionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledgerHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyJournalInput = {
    id?: number
    date: Date | string
    bankAccountId: number
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateWithoutJournalInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: BankAccountUpdateOneRequiredWithoutBankTransactionNestedInput
  }

  export type BankTransactionUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountId?: IntFieldUpdateOperationsInput | number
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountId?: IntFieldUpdateOperationsInput | number
    debitAmount?: NullableIntFieldUpdateOperationsInput | number | null
    creditAmount?: NullableIntFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyFixedJournalInput = {
    id?: number
    date: Date | string
    productId: number
    depoId?: number | null
    employeeId?: string | null
    transactionId?: number | null
    unitPrice?: number
    quantityAdd?: number | null
    quantityLess?: number | null
    debitAmount?: number | null
    creditAmount?: number | null
    isClosing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isFixted?: boolean
  }

  export type InventoryUpdateWithoutFixedJournalInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
    depo?: DepoUpdateOneWithoutInventoryNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    transactionInfo?: TransactionInfoUpdateOneWithoutInventoryNestedInput
    user?: UserUpdateOneWithoutInventoriesNestedInput
  }

  export type InventoryUncheckedUpdateWithoutFixedJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryUncheckedUpdateManyWithoutFixedJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    depoId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantityAdd?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityLess?: NullableFloatFieldUpdateOperationsInput | number | null
    debitAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isClosing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFixted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    productId: number
    quintity: number
    tpRate: number
    amount: number
  }

  export type OrderStatusCreateManyOrderInput = {
    id?: number
    status?: $Enums.OrdStatus
    comments?: string | null
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quintity?: IntFieldUpdateOperationsInput | number
    tpRate?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderStatusUpdateWithoutOrderInput = {
    status?: EnumOrdStatusFieldUpdateOperationsInput | $Enums.OrdStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumOrdStatusFieldUpdateOperationsInput | $Enums.OrdStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumOrdStatusFieldUpdateOperationsInput | $Enums.OrdStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevesCreateManyLeaveTypeInput = {
    id?: number
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    leaveReason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevesUpdateWithoutLeaveTypeInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLevesNestedInput
  }

  export type LevesUncheckedUpdateWithoutLeaveTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevesUncheckedUpdateManyWithoutLeaveTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveReason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}